---
title: 设计模式之工厂模式
date: 2017-08-27 17:13:22
tags: 
 - 设计模式 
 - 工厂模式
 - 创建型模式
categories: 
 - 设计模式
---


## 设计模式-创建型之工厂模式


创建型设计模式共六种：

* 简单工厂模式
* 工厂方法模式
* 抽象工厂模式
* 建造者模式
* 原型模式
* 单例模式

本篇讲三个工厂模式： 简单工厂、工厂方法、抽象工厂。

<!-- more -->

创建型设计模式是用来创建对象的，在面向对象的编程中最常用的一种创建对象方式是用new操作符产生一个对象实例。
创建型模式对类的实例化过程进行了抽象，能够将对象的创建与对象的使用过程分离。
### 简单工厂模式

#### 模式定义

简单工厂模式：又称静态工厂模式。在该模式中可以通过参数的不同返回不同的实例。简单工厂模式专门定义一个类来负责创建其他类的实例。被创建的实例通常都具有共同的分类。

#### 模式的结构

* Factory-工厂角色： 负责实现创建所有实例的内部逻辑。
* Product-抽象产品角色： 创建的所有对象的父类，负责描述所有实例所共有的公共接口。
* ConcreteProduct-具体产品角色：创建的目标，所有创建的对象都充当这个角色的某个具体类的实例。

当然，实际应用中可能没有这么严格的三个角色。但 `Factory`和 `ConcreteProduct `是必须的。 <br>

简单工厂的核心定义是：有一个工厂方法（也可以是工厂类）根据接收的参数 实例化具体的类，并且返回这个类的实例。

#### 实例分析

这里用一个生产宝马汽车的例子。现在有两个型号的宝马车：BMW320和BMW523。
假设此时没有宝马工厂。用户需要这个这两个型号的车的时候需要 自己去制造生产。代码如下：

没有工厂的时候：

``` java
    public class BMW320 {
        public BMW320 {
            System.out.println('生产320型号的宝马车');
        }
    }

    public class BMW523 {
        public BMW523 {
            System.out.println('生产320型号的宝马车');
        }
    }
    
    public class Customer {
        public static void main(String[] args) {
            BMW320 bmw320 = new BMW320();
            BMW523 bmw523 = new BMW523();
        }
    }
```
    
这样客户也造出了汽车，似乎也没啥毛病。问题在于：客户需要知道怎么去创建一款车（具体new 哪个类） 这样客户和车是耦合在一起的。但车型有很多的时候，客户就需要知道每一个型号的车对应哪个类。为了解耦，我们引入简单那工厂模式  ：创建一个工厂，将创建具体那个型号的宝马车的操作细节放到工厂里，客户直接使用工厂的创建产品的方法，传入具体的型号就好了。

  有了简单工厂：
 
  产品类
``` java
    abstract class BMW  {
    
    }
    
    public class BMW320 extends BMW { 
        public BMW320() {  
        System.out.println("制造-->BMW320");  
    }

    public class BMW523 extends BMW {  
        public BMW523(){  
            System.out.println("制造-->BMW523");  
        }  
    }
```

工厂类 

``` java
   public class BMWFactory {
       public BMW createBMW (int type) {
           switch (type) {
           
            case:  320 
                return new BMW320();
                
            case: 523
                return new BMW523();
                
            default:
                break;  
                    
           }
           return null;
       }
   }
```

客户类
    
``` java
    public class Customer {
        public static void main(Sting[] args) {
            BMWFactory  factory = new BMWFactory();
            BMW bmw320 = factory.createBMW(320);
            BMW bmw523 = factory.createBMW(523); 
        }   
    }
```
可以看到 具体实例化某一个class 的操作放到了工厂类里，客户只需要调用工厂方法并传参就OK了。


#### 模式分析

##### 简单工厂的优点：

* 客户端更方便了：无需记忆众多复杂的类名，只需要知道具体产品类所对应的参数。
* 责任分割： 创建产品的逻辑都放在工厂，客户端仅仅是消费产品，从而免去了直接创建产品对象的责任。


##### 简单工厂的缺点： 

* 违背开闭原则的 对修改关闭。当需要新增加一类产品的时候，除了增加创建该类产品的代码外还需要修改工厂类。

##### 简单工厂适用场景

* 工厂类负责创建的对象比较少：由于创建的对象少，不会造成工厂法法中的业务逻辑泰国复杂。


### 工厂方法

上面我们知道了，当产品种类多了后，工厂就会很庞大，且新增一类产品就要改工厂类。此时工厂方法模式就上场了。

#### 模式定义


在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将`产品类的实例化操作延迟到工厂子类`中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。


#### 模式的结构

* Factory-抽象工厂类：
    * 声明了工厂方法(Factory Method)，用于返回一个产品。抽象工厂是工厂方法模式的核心，所有创建对象的工厂类都必须实现该接口。
* ConcreteFactory-具体工厂类：
    * 它实现了抽象产品接口，一类工厂生产一类产品。
* Product-抽象产品类：
    *  定义产品的接口。可以是抽象类或接口。
* ConcreteProduct-具体产品类：
    * 实现抽象产品类的接口，产品和工厂一一对相应。

    
#### 实例分析

还是接着上边简单工厂造宝马车的例子。


产品类，和简单工厂里一样 
``` java
    abstract class BMW {  
        public BMW(){  
              
        }  
    }  
    public class BMW320 extends BMW {  
        public BMW320() {  
            System.out.println("制造-->BMW320");  
        }  
    }  
    public class BMW523 extends BMW{  
        public BMW523(){  
            System.out.println("制造-->BMW523");  
        }  
    }  
```        

工厂类： 抽象工厂类定义工厂类接口，工厂类创建具体的一类产品。

``` java
    interface FactoryBMW {  
        BMW createBMW();  
    }  
      
    public class FactoryBMW320 implements FactoryBMW{  
      
        @Override  
        public BMW320 createBMW() {  
      
            return new BMW320();  
        }  
      
    }  
    public class FactoryBMW523 implements FactoryBMW {  
        @Override  
        public BMW523 createBMW() {  
      
            return new BMW523();  
        }  
    }       
```
    
客户类：客户生产某类产品 直接实例化具体的工厂。

``` java
    public class Customer {  
        public static void main(String[] args) {  
            FactoryBMW320 factoryBMW320 = new FactoryBMW320();  //可通过配置文件实现 
            BMW320 bmw320 = factoryBMW320.createBMW();  
      
            FactoryBMW523 factoryBMW523 = new FactoryBMW523();  
            BMW523 bmw523 = factoryBMW523.createBMW();  
        }  
    }
```
    

#### 模式分析 

工厂方法模式是简单工厂模式的进一步抽象。由于使用了面向对象的多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。工厂方法模式可以允许在不修改工厂角色的情况下引进新产品。<br>

基于工厂角色和产品角色的`多态性`设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，是因为所有的具体工厂类都具有同一抽象父类。
    

##### 工厂方法模式优点

* `符合开闭原则`（克服了简单工厂的缺点）。引入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。


##### 工厂方法模式的缺点

* 系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。


##### 工厂方法模式的适用场景
* 当需要的产品种类多变，系统需要有比较好的扩展性时，可以考虑工厂模式，不同的产品用不同的实现工厂来组装。



##### 工厂方法模式疑问

到这里我是有点疑问的：工厂方法模式中，客户端就得知道生产某类产品对应的工厂类，当产品种类多的时候，那不就面临没有任何工厂模式时同样的问题？ 
这个问题可以通过配置文件解决。通过配置文件来存储具体工厂类ConcreteFactory的类名，更换新的具体工厂时无须修改源代码，系统扩展更为方便。

那么问题又来了：那我不用工厂方法模式，我生产具体的产品（new ConcreteProduct）时，也通过配置文件来存储产品类的类名，那不就不需要工厂类了吗？ 那工厂方法模式的意义是啥呢？我的理解是 ：实际工作中，工厂类 不只是简单的new ConcreteProduct(), 同时还做一些初始化操作，比如处理前置依赖等。把这些封装在工厂类内，使得代码封装程度更高。




### 抽象工厂 


为了更好的理解抽象工厂模式，先说两个概念：

* 产品等级结构 ：产品等级结构即产品的`继承结构`，如一个抽象类是电视机，其子类有海尔电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。

* 产品族 ：产品族是指由同一个工厂生产的，位于`不同产品等级结构`中的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中。

当系统所提供的工厂所需生产的具体产品并不是一个简单的对象，而是`多个位于不同产品等级结构`中属于不同类型的具体产品时需要使用抽象工厂模式。



#### 模式的结构

* Factory-抽象工厂类
    * 定义了一组用于创建一组产品的方法，每个方法对应一种产品。
    
* ConcreteFactory-具体工厂类
    * 实现抽象工厂中定义的创建一组产品的方法，生产一组产品。一对多。

* Product-抽象产品类
    * 定义产品接口
    
* ConcreteProduct-具体产品类：它定义具体工厂生产的具体产品对象，实现抽象产品接口中声明的业务方法。  


抽象工厂中声明了多个工厂方法，用于创建不同类型的产品。


#### 实例分析       

这里改造一下上面生产宝马汽车的例子。现在我们不是生产汽车了而是生产汽车配件。现需要两种汽车配件：汽车发动机，汽车空调。还是有两个宝马型号的汽车 BMW320、BMW523。

产品类
``` java
    //发动机以及型号    
    public interface Engine {    
      
    }    
    public class EngineA extends Engine{    
        public EngineA(){    
            System.out.println("制造-->EngineA");    
        }    
    }    
    public class EngineBextends Engine{    
        public EngineB(){    
            System.out.println("制造-->EngineB");    
        }    
    }    
      
    //空调以及型号    
    public interface Aircondition {    
      
    }    
    public class AirconditionA extends Aircondition{    
        public AirconditionA(){    
            System.out.println("制造-->AirconditionA");    
        }    
    }    
    public class AirconditionB extends Aircondition{    
        public AirconditionB(){    
            System.out.println("制造-->AirconditionB");    
        }    
    }   
```
 
 创建工厂类
 
``` java
    //创建工厂的接口   
    public interface AbstractFactory {    
        //制造发动机  
        public Engine createEngine();  
        //制造空调   
        public Aircondition createAircondition();   
    } 
    
    //为宝马320系列生产配件 
    public class FactoryBMW320 implements AbstractFactory{    
            
        @Override    
        public Engine createEngine() {      
            return new EngineA();    
        }    
        @Override    
        public Aircondition createAircondition() {    
            return new AirconditionA();    
        }    
    }    
    
    //宝马523系列配件 
    public class FactoryBMW523 implements AbstractFactory {    
        
         @Override    
        public Engine createEngine() {      
            return new EngineB();    
        }    
        @Override    
        public Aircondition createAircondition() {    
            return new AirconditionB();    
        }    
      
      
    }
        
    //客户端   
    public class Customer {    
        public static void main(String[] args){    
            //生产宝马320系列配件  
            FactoryBMW320 factoryBMW320 = new FactoryBMW320();    
            factoryBMW320.createEngine();  
            factoryBMW320.createAircondition();  
                
            //生产宝马523系列配件    
            FactoryBMW523 factoryBMW523 = new FactoryBMW523();    
            factoryBMW320.createEngine();  
            factoryBMW320.createAircondition();  
        }    
    }     
```
    
    
    
#### 模式分析

##### 抽象工厂模式的优点    
* 首先是该模式适应了某种业务场景
* 符合“开闭原则”：增加新的具体工厂和产品族很方便，无须修改已有系统。
 
##### 抽象工厂模式的缺点

* 在添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其`所有子类的修改`，显然会带来较大的不便。
* 开闭原则的倾斜性（增加新的工厂和产品族容易，`增加新的产品等级结构`麻烦）

##### 抽象工厂模式的适用场景   

* 当系统所提供的工厂所需生产的具体产品并不是一个简单的对象，而是`多个位于不同产品等级结构`中属于不同类型的具体产品时需要使用抽象工厂模式。

* 一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是重要的。
* 系统提供一个产品类的库，所有的 `产品以同样的接口`出现，从而使客户端不依赖于具体实现。
     

##### 与工厂方法的区别

抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构，一个工厂等级结构可以负责多个不同产品等级结构中的产品对象的创建 。当一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象时，抽象工厂模式比工厂方法模式更为简单、有效率。


### 工厂模式的退化

* 当`抽象工厂模式`中每一个具体工厂类只创建一个产品对象，也就是只存在一个产品等级结构时，抽象工厂模式退化成`工厂方法模式`；
* 当工厂方法模式中抽象工厂与具体工厂合并，提供一个统一的工厂来创建产品对象将创建对象的工厂方法设计为静态方法时，工厂方法模式退化成`简单工厂模式`。


三个工厂模式 完。


http://blog.csdn.net/jason0539/article/details/44956775

https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/creational.html


    