---
title: 非对称加密(公钥加密)及其应用
date: 2018-02-23 12:20:48
tags:
    - RSA
    - 非对称加密
    - 数字签名
categories:
   
---

### 什么是非对称加密
[维基百科](https://zh.wikipedia.org/wiki/ %E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86)已经解释的非常清楚了（只看对公开密钥加密的解释这部分，引用如下）。

> 公开密钥加密（英语：Public-key cryptography），也称为非对称加密（英语：asymmetric cryptography），是密码学的一种算法，它需要两个密钥，一个是公开密钥，另一个是私有密钥；一个用作加密的时候，另一个则用作解密。使用其中一个密钥把明文加密后所得的密文，只能用相对应的另一个密钥才能解密得到原本的明文；甚至连最初用来加密的密钥也不能用作解密。由于加密和解密需要两个不同的密钥，故被称为非对称加密；不同于加密和解密都使用同一个密钥的对称加密。虽然两个密钥在数学上相关，但如果知道了其中一个，并不能凭此计算出另外一个；因此其中一个可以公开，称为公钥，任意向外发布；不公开的密钥为私钥，必须由用户自行严格秘密保管，绝不通过任何途径向任何人提供，也不会透露给要通信的另一方，即使他被信任。

维基上说的说的有点啰嗦，精简一下就是：

<!-- more -->

> 加密解密通过一个秘钥对即公开密钥和私有密钥完成的。
> <br/>用公钥加密明文得到的密文，只能通过对应的私钥解密得到明文。
> （类似私钥加密明文得到密的文，只能通过对应的公钥解密得到明文）
> <br/> 密钥对是数学相关的。

在现实世界上可作比拟的例子是，一个传统保管箱，开门和关门都是使用同一把钥匙，这是对称加密；而一个公开的邮箱，投递口是任何人都可以寄信进去的，这可视为公钥；而只有邮箱主人拥有钥匙可以打开邮箱，这就视为私钥。这就是非对称加密。（以下说的公钥加密和对对称加密是一回事）


### 与对称加密的比较
对称加密的问题在于通信双方要事先交换密钥，而事先传递密钥的过程 存在密钥泄露的风险。密钥一旦泄露，数据就不安全了。 
而非对称加密，密钥对的私钥是保密的不需要事先传递或公开的，所以安全性更高。

注意，看网上的博文很多人对这里的理解是不太透彻的: 认为对称加密的问题在于加解密用同样的密钥，所以导致对称加密不安全的。 
 > 加解密使用同样的密钥-这是对称加密的概念也是其形式，把对称加密安全性差归咎于此不太妥（要强扯也┑(￣Д ￣)┍）。
 
 对称加密的安全性低，问题在于两点： 
 
  * 由于加密解密用同样的密钥，其密钥需要通信双方事先交换（或单向传递），密钥交换的过程存在泄漏的风险。
  * 由于密钥通信双方都知道，通信接收方可以泄漏发送方的密钥给其他人。 
    
而以上两个问题非对称加密都解决了：

  * 加密解密需要一对密钥来完成，其中私钥是不公开也不需要事先传递的，所以泄漏的概率更小。 
  * 公钥加密的信息只能通过其对应的私钥来解密，私钥是属于通信双方中某一方且保密的，而公钥是公开的，所以不存在泄漏对方密钥的风险。 
 
 所以，在保证密钥不被泄漏的前提下对称加密和非对称加密是一样安全的。 但是，对称加密中，通信双方在事后有泄漏对方密钥的可能。 如果再加一个条件通信双方的发送者对每一个接收者使用不同的密钥，这样就能保证对称加密和非对称加密一样安全了。 但是这两点都比较难保证：1.传递密钥过程的安全性依赖传递环境。2.需要每个人都要有很多很多密钥，不同的接收方用不同的密钥，密钥难以保管。
 
所以这个时候非对称加密华丽登场了。 
下面我们通过对具体的某一种非对称加密算法的学习来理解非对称加密的数学原理。这里我们选用应用最广泛的非对称加密算法之一：RSA加密算法。

### RSA算法
RSA算法的数学基础是：欧拉定理，此处不做解释。公钥加密算法根据其所依据的数学难题一般分为三类：大整数因式分解问题类、离散对数问题类，椭圆曲线类。RSA属于大数分解类，也是最好理解的。

下面直接介绍RSA算法的基础步骤；

#### 1. 生成公钥（PK）和私钥(SK)

* (1) 随意选两个大的素数p和q，p不等于q
* (2) 将p、q两个素数相乘得到n，即n=pq
* (3) 计算n的欧拉函数φ(n):根据公式 φ(n)=(p-1)(q-1)
* (4) 选择一个整数e，作为密钥，使得e和φ(n)互质，且e < φ(n)
* (5) 计算e对于φ(n)的模反元素d: 根据公式 ed mod φ(n)  = 1 ,计算出d的值，作为另一个密钥。
 所谓"模反元素"就是指有一个整数d，可以使得ed被φ(n)除的余数为1。
``` txt
        ed ≡ 1 (mod φ(n)) ==> 
        ed - 1 = kφ(n)  //求解二元一次方程 k 从1带入试就行了 
    
```
* (6) 通过以上步骤计算出 n 、e 、d 3个数据，其中（n、e）作为公钥，（n、d）作为私钥（也可以互换）
* (7) 生成公钥和私钥后就可以公开公钥了。

      

#### 2. 用公钥加密信息
信息发送方收到接收方公钥PK后，就可以用PK对数据加密。加密步骤如下。 其中明文为M，加密后的密文为C，公钥（n,e）

    
> 加密： M^e  mod n = C
 
 
#### 3. 用私钥解密信息
接收方持有私钥（N，D）,在接收到密文C后，通过私钥对其解密，得到明文M：

> 解密： C^d mod n = M  
 
### RSA 安全性分析

通常到这里我们会有个疑问？ 公钥和私钥存在一定的数学关系， 公钥公开，那么有没有可能通过公钥推导出私钥呢？ 如果能那不就不安全了吗。 答案是：能，但是很难。
问题变成 能否在已知 n和e的前提下，推导出d ?

``` txt
    ed ≡ 1 (mod φ(n))   //等价于 ed mod φ(n)  = 1 
    φ(n)=(p-1)(q-1)
    n=pq
```
结论：如果n可以被因数分解，d就可以算出。
但是，大整数的因式分解是很困难的，目前除了暴力破解，还没有更好的有效方式。

所以整数n的因式分解难度决定了RSA算法的可靠度。
>  RSA可靠性就是建立在分解两个大素数乘积的十分困难上。

这个难度是个什么概念呢？[引用](http://blog.csdn.net/woyaokaoyan/article/details/5169098)
>RSA算法的破解与密钥的长度有关，最常见的破解方法是因式分解，如果密钥的长度小于等于256位，一台较快的电脑可以在几个小时内成功分解其因子。位数越高因式分解所需时间也越长。1999年，一台Cray超级电脑用了5个月时间分解了512位长的密钥。而目前典型密钥长度是1028位。在512位RSA算法破解10年之后，一群研究人员报告(PDF)他们因式分解了768位RSA算法。他们是在2009年12月9日分解了768位、232数位数字的RSA-768密钥。分解一个768位RSA密钥所需时间是512位的数千倍，而1024位所需时间则是768位的一千多倍，因此在短时间内1024位仍然是安全的。研究人员表示1024位密钥预计也将会在10年内攻破，因此在未来三到四年内应逐步淘汰1024位RSA密钥。

思考一下大整数n 因式分解为什么难？有多难？

### RSA 算法实例
#### 生成公钥私钥
* 随机取大质数p=11，q=13，那n=11*13=143，φ(N)=(p-1)(q-1) = 120 
* 取一个e=7，由 ed mod φ(n)  = 1 计算出d=103。
``` txt0
        公钥（n,e） 即 （143, 7）
        私钥 (n,d) 即 （143, 103）
```
#### 用公钥加密
由于手工计算，为了使计算量小一点，我们将上面的公钥和私钥交换： 即公钥 （143, 103），私钥（143, 7）。取明文 m =2,加密过程如下：

``` txt
    密文 c =  m^e mod n
          =  2^103 mod 143 
          = 10141204801825835211973625643008 mod 143 
          = 63 
```
          

#### 用私钥解密

收到密文c = 63,通过 私钥（143，7）进行解密，解密过程如下：

``` txt
    明文  m = c^d mod n 
             = 63^7 mod 143
             = 3938980639167 mod 143 
             = 2 
```
至此，我们用RSA算法进行了一次加密解密，其实很简单，只是计算量可能会比较大。  

常见的公钥加密算法除了RSA。还有ElGamal、背包算法、椭圆曲线加密算法（英语：Elliptic Curve Cryptography, ECC）等。下面我们说下非对称加密的应用。

### 非对称加密的应用

先插入一个概念： `信息系统安全的基本属性`。

> 信息系统安全的基本属性: 保密性、完整性、可用性、不可抵赖性。

* 保密性：是应用系统的信息不被泄露给非授权的用户。常用保密技术：最小授权原则，信息加密等。
* 完整性：完整性是信息未经授权不能进行改变的特性。完整性是一种面向信息的安全性。
* 可用性： 可用性是应用系统面向用户的安全性能，不做赘述。
* 不可抵赖性：不可抵赖性也称作不可否认性，在应用系统的信息交互过程中，确信参与者的真实同一性。即所有参与者都不可能否认或抵赖曾经完成的操作和承诺。利用信息源证据可以防止发信方不真实地否认已发送信息，利用递交接收证据可以防止收信方事后否认已经接收的信息。

加密技术也是用来加强信息安全的，接下来说的几个非对称加密实际应用也是如此。
回归正题，接下来说非对称加密最广泛的应用之一：数字签名。

#### 数字签名 
    
> 数字签名在ISO7498—2标准中定义为：“附加在数据单元上的一些数据，或是对数据单元所作的密码变换，这种数据和变换允许数据单元的接收者用以确认数据单元来源和数据单元的完整性，并保护数据，防止被人（例如接收者）进行伪造”

首先搞清楚数字签名解决的是什么问题？ 然后看看什么是数字签名？最后分析下数字签名为什么能解决这些问题？

##### 数字签名解决什么问题？
纸质书信或文件根据亲笔签名或印章来证明其真实性，及防抵赖。对应上述信息安全的 完整性和不可抵赖性。 而数字签名则可以看做是对在网络中传输的报文的签名，作用自然也是为了保证信息的完整性及不可抵赖性。 

那下面我们看下数字签名是如何做到证明信息的完整性及防抵赖的？

##### 数字签名的实现方法？
建立在公钥密码技术上的数字签名方法有很多，有RSA签名、DSA签名和椭圆曲线数字签名算法（ECDSA）等等。下面对RSA签名进行详细分析。

这里需要理解[哈希-hash](https://baike.baidu.com/item/%E5%93%88%E5%B8%8C%E5%80%BC)的概念。简单说hash 就是计算机可以对任意内容计算出一个固定长度的值，且不会重复。

直接看图：

![数字签名](https://user-images.githubusercontent.com/25282685/60791212-b75c7680-a195-11e9-9c67-1404828ddaeb.png)


   （1）发送方采用某种摘要算法从报文中生成一个128位的散列值（称为报文摘要）；

　　（2）发送方用RSA算法和自己的私钥对这个散列值进行加密，产生一个摘要密文，这就是发送方的数字签名；

　　（3）将这个加密后的数字签名作为报文的附件和报文一起发送给接收方：

　　（4）接收方从接收到的原始报文中采用相同的摘要算法计算出128位的散列值；

　　（5）报文的接收方用RSA算法和发送方的公钥对报文附加的数字签名进行解密；

　　（6）如果两个散列值相同，那么接收方就能确认报文是由发送方签名的。

最常用的摘要算法叫做MD5（Message Digest 5）。MD5采用单向Hash函数将任意长度的“字节串”变换成一个128位的散列值，并且它是一个不可逆的字符串变换算法。



##### 数字签名为什么能保证信息完整性及不可抵赖性？

###### 信息的完整性
如果报文在网络传输过程中被修改，接收方收到此报文后，使用相同的摘要算法将计算出不同的报文摘要，这就保证了接收方可以判断报文自签名后到收到为止，是否被修改过。
###### 信息的不可抵赖性 
如果发送方A想让接收方误认为此报文是由发送方B签名发送的，由于发送方A不知道发送方B的私钥，所以接收方用发送方B的公钥对发送方A加密的报文摘要进行解密时，也将得出不同的报文摘要，这就保证了接收方可以判断报文是否是由指定的签名者发送。同时也可以看出，当两个散列值相同时，发送方B无法否认这个报文是他签名发送的。


##### 关于数字签名的一点问题

关于数字签名就说完了。但有个疑问：传输过程中原文没有被加密吗？是的。上面是无保密机制的数字签名。具有保密机制的RSA签名机制自己看[这边文章](http://www.elecfans.com/baike/tongxingjishu/chungshuwang/20110710205779.html)吧 。


#### 数字证书
关于上面数字签名有一个问题：信息接收方如何确认拿到的公钥就是期望的发送方的公钥？ 

举个例子：

小红与小绿写信。 小绿写完信后 用自己的私钥对信件摘要生成 ‘数字签名’ 连同信件一块发给小红。 小红收到信件后用小绿的公钥解密信件里的数字签名得到信件摘要。 这个过程没有问题。

但是有一天，第三者-小强出现了。小强偷偷将小红电脑里的小绿的公钥换成他自己的了，但此时小红还以为那是小绿的公钥。 因此，小强就可以冒充小绿，用自己的私钥对信件摘要进行 ‘数字签名’，发给小红。小红用小强掉包后的公钥对数字签名解密，还以为对方是小绿。

后来小红感觉不对劲，他发现自己无法确定公钥是否真的是小绿的。于是她想了一个办法，让小绿找“证书中心"（certificate authority，简称CA） 为自己的公钥做认证。认证机构用自己的私钥对小绿的公钥和一些相关信息一起加密，生成‘数字证书’。

小绿拿到‘数字证书’后，再给苏珊写信，只要在签名的同时，再附上数字证书就行了。
小红收信后，用CA的公钥解开数字证书，就可以拿到小绿的公钥了
，然后就能验证数字签名是否是小绿的。

这里我们先大概知道CA是一个第三方机构，用来对个人身份认证的，而认证的形式就是‘数字证书’。
这个例子中忽略了一个关键细节，如何确定证书的真实性呢？ 接下来我们细细介绍。

#### https 实例分析

https 是数字证书的应用之一。我们通过对https的从简介绍来理解数字证书。 
##### CA 
CA（certificate authority）证书授权中心。 受信任的第三方机构。 CA为每个使用公开密钥的用户发放一个数字证书。证书生成的过程可以认为就是CA用自己的私钥对公钥持有方的公钥及一些相关信息进行数字签名。

> 数字证书是一个经证书授权中心（CA）数字签名的包含公钥拥有者信息以及公钥的文件。

数字证书的作用是证明证书中列出的用户合法拥有证书中列出的公钥。
##### 根证书
而CA的公钥叫做根证书。 这些根证书是预先被安装在浏览器里的,用来解密服务器的证书的。
  
##### https 访问
通过https建立了一个安全 Web 事务之后，现代的浏览器都会自动获取所连接服务器的数字证书。如果服务器没有证书，安全连接就会失败。
浏览器预先安装了一些CA的根证书。浏览器用对应的根证书去解密网站服务器的数字证书获取到网站服务器的公钥。然后浏览器发送一个随机字符串给服务器，服务器用自己的私钥加密这个随机字符串后返回给浏览器，浏览器通过获得的公钥解密后比较这个随机字符串是否和发出去的一样。 如果一样，则说明服务器的公钥和证书里的公钥一致，则证明服务器就是服务器。

当然真实的https过程 比这个复杂很多，这里只是为了方便理解证书在非对称加密应用中的作用，忽略了很多技术细节。


### 最后

静静的学习完了，我们再来说下时下最热的加密币。加密币里的交易安全基础就是非对称加密算法。就以币王BTC（比特币）来说。

 > 比特币钱包: 是用来存放私钥和公钥的，而不是存放币的。
 <br/>比特币地址: 钱包公钥的哈希值（更短，方便保存和传播），用来收币的。 
 <br/>比特币使用了基于secp256k1椭圆曲线加密算法（非对称加密算法的一种）。
 <br/>一笔交易实质就是一个地址的一定数量的比特币转移到另一个地址。而交易过程安全则是由其非对称加密算法保障。



最最后总结下本文：

*  什么是非对称加密
*  RSA算法的原理和用法
*  什么是数字签名
*  什么是数字证书及数字证书的作用
*  又要上班了。


### 参考资料
[数字签名技术原理介绍](http://www.elecfans.com/baike/tongxingjishu/chungshuwang/20110710205779.html)
