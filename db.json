{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/img/s.png","path":"img/s.png","modified":1,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"f33a2bae2665fdddcdfe40d8831085f3797978b8","modified":1485187132000},{"_id":"source/CNAME","hash":"3c12c9d912db13e9094053e040d2f9ebece0aad7","modified":1520699905000},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1485184622000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1485184622000},{"_id":"themes/next/.gitignore","hash":"5f09fca02e030b7676c1d312cd88ce8fbccf381c","modified":1485184622000},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1485184622000},{"_id":"themes/next/.javascript_ignore","hash":"f9ea3c5395f8feb225a24e2c32baa79afda30c16","modified":1485184622000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1485184622000},{"_id":"themes/next/README.en.md","hash":"3b0c7998cf17f9cf9e1a5bfcd65679a43a00c817","modified":1485184622000},{"_id":"themes/next/README.md","hash":"500b5606eb6a09c979d16128f8b00f4bf9bc95ac","modified":1485184622000},{"_id":"themes/next/_config.yml","hash":"9d1daf4439479c4cdd19f725b8fb06106ca2f7fd","modified":1496508835000},{"_id":"themes/next/bower.json","hash":"5abc236d9cc2512f5457ed57c1fba76669eb7399","modified":1485184622000},{"_id":"themes/next/gulpfile.coffee","hash":"61ef0606a8134894d7ac796bc8d0fa4ba6a94483","modified":1485184622000},{"_id":"themes/next/package.json","hash":"877cb98025e59015532c4c9a04a33e2af4ad56f9","modified":1485184622000},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1489595587000},{"_id":"source/_posts/Javascript之执行上下文.md","hash":"6f3326a56d433731bb942ac3cbf3d186136fcb63","modified":1520697926000},{"_id":"source/_posts/Javascript语言之蜜汁this.md","hash":"911dec44d7976545726cdaa2fd14081c90052699","modified":1520697926000},{"_id":"source/_posts/hello-hexo.md","hash":"d8e98467708bc483b62f93061436709b5a2e2cd0","modified":1520703812000},{"_id":"source/_posts/javascript函数节流(throttle)和函数防抖(debounce)及其实现.md","hash":"785b536acbf4e5bb0da230d5637db38306205045","modified":1520697926000},{"_id":"source/_posts/《深度工作》笔记.md","hash":"fe42365c8a6cc48fb8e61e382832167ece45c842","modified":1520697926000},{"_id":"source/_posts/前端MVC.md","hash":"f41fc434133f08a55faef02401fe11313c6ac8a3","modified":1520697926000},{"_id":"source/_posts/深入理解JSX.md","hash":"4ffd172fded5fefc407e07f5e85907e6b44129d2","modified":1520697926000},{"_id":"source/_posts/理解Flux.md","hash":"330c4a313db514b40a3440319a56d470bd6025a8","modified":1520697926000},{"_id":"source/_posts/理解redux.md","hash":"2849776e8cbcb4e61bd98c60b6fdb44ef6693b31","modified":1520697926000},{"_id":"source/_posts/设计模式之工厂模式.md","hash":"a1f43105cafe24ea13883dd4b029ab6487cfcb17","modified":1520697926000},{"_id":"source/_posts/随笔：《王者荣耀》-论网游成瘾.md","hash":"d8f6d3af76e0be7a3f49a8d1c24f6445b4b0a6a0","modified":1520697926000},{"_id":"source/_posts/非对称加密及其应用.md","hash":"34998a49cdf7526b20573943a7ce2f484bea249c","modified":1520697926000},{"_id":"source/categories/index.md","hash":"4323dac601979e6cbf388f2a6a251bd8620e5c25","modified":1520697926000},{"_id":"source/img/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1485187169000},{"_id":"source/img/s.png","hash":"33b16e4425cd772192a5cd0d1f0aab6fa251d3b3","modified":1520697926000},{"_id":"source/tags/index.md","hash":"af8955876e2fb3e6a400c2d651b13a8aade0f937","modified":1520697926000},{"_id":"themes/next/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1485184622000},{"_id":"themes/next/.git/config","hash":"ca83ce520f770c3104c997d323b9f293dd920073","modified":1485184622000},{"_id":"themes/next/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1485184604000},{"_id":"themes/next/.git/index","hash":"da9b4c69a2b1c72a80d606ca05c662c5ca69f40a","modified":1520697067000},{"_id":"themes/next/.git/packed-refs","hash":"12ca02d8374d9a441a6c8a6c9ed061432cb0a8c9","modified":1485184622000},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5ab257af816986cd0e53f9527a92d5934ac70ae9","modified":1485184622000},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"c2024ded82143807c28a299c5fe6b927ef3525ff","modified":1485184622000},{"_id":"themes/next/languages/de.yml","hash":"1fdea1f84b7f691f5b4dd4d2b43eeb27b10fa0c8","modified":1485184622000},{"_id":"themes/next/languages/default.yml","hash":"767470a80dc257e23e14c3a78e8c52a46c9d6209","modified":1485184622000},{"_id":"themes/next/languages/en.yml","hash":"40057d6608e825d06e0864bac4dcd27ed88ada87","modified":1485184622000},{"_id":"themes/next/languages/fr-FR.yml","hash":"9fca01ef917d33ae2ae6bc04561ec6799dff5351","modified":1485184622000},{"_id":"themes/next/languages/id.yml","hash":"34396bef27c4ab9e9a3c5d3e3aa94b0e3b3a7b0d","modified":1485184622000},{"_id":"themes/next/languages/ja.yml","hash":"49f12149edcc1892b26a6207328cda64da20116d","modified":1485184622000},{"_id":"themes/next/languages/ko.yml","hash":"b6bc5d6b0c000deb44099b42d3aebb8c49dbfca9","modified":1485184622000},{"_id":"themes/next/languages/pt-BR.yml","hash":"7742ba4c0d682cbe1d38305332ebc928abd754b5","modified":1485184622000},{"_id":"themes/next/languages/pt.yml","hash":"6b660b117314cad93f08757601df3adb04c68beb","modified":1485184622000},{"_id":"themes/next/languages/ru.yml","hash":"257d11e626cbe4b9b78785a764190b9278f95c28","modified":1485184622000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"fe4cb6e1949bb0a83ef4b9cb1708ade707a37f61","modified":1489600855000},{"_id":"themes/next/languages/zh-hk.yml","hash":"34c84c6d04447a25bd5eac576922a13947c000e2","modified":1485184622000},{"_id":"themes/next/languages/zh-tw.yml","hash":"c97a5c41149de9b17f33439b0ecf0eff6fdae50e","modified":1485184622000},{"_id":"themes/next/layout/_layout.swig","hash":"2fa3c74066843a859fac77803324a1de51044da9","modified":1485184622000},{"_id":"themes/next/layout/archive.swig","hash":"b5b59d70fc1563f482fa07afd435752774ad5981","modified":1485184622000},{"_id":"themes/next/layout/category.swig","hash":"6422d196ceaff4220d54b8af770e7e957f3364ad","modified":1485184622000},{"_id":"themes/next/layout/index.swig","hash":"427d0b95b854e311ae363088ab39a393bf8fdc8b","modified":1485184622000},{"_id":"themes/next/layout/page.swig","hash":"3727fab9dadb967e9c2204edca787dc72264674a","modified":1485184622000},{"_id":"themes/next/layout/post.swig","hash":"e2e512142961ddfe77eba29eaa88f4a2ee43ae18","modified":1485184622000},{"_id":"themes/next/layout/schedule.swig","hash":"1f1cdc268f4ef773fd3ae693bbdf7d0b2f45c3a3","modified":1485184622000},{"_id":"themes/next/layout/tag.swig","hash":"07cf49c49c39a14dfbe9ce8e7d7eea3d4d0a4911","modified":1485184622000},{"_id":"themes/next/scripts/merge-configs.js","hash":"0c56be2e85c694247cfa327ea6d627b99ca265e8","modified":1485184622000},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1485184622000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1485184622000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1485184622000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1485184622000},{"_id":"themes/next/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1485184604000},{"_id":"themes/next/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1485184604000},{"_id":"themes/next/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1485184604000},{"_id":"themes/next/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1485184604000},{"_id":"themes/next/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1485184604000},{"_id":"themes/next/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1485184604000},{"_id":"themes/next/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1485184604000},{"_id":"themes/next/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1485184604000},{"_id":"themes/next/.git/hooks/update.sample","hash":"39355a075977d05708ef74e1b66d09a36e486df1","modified":1485184604000},{"_id":"themes/next/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1485184604000},{"_id":"themes/next/.git/logs/HEAD","hash":"9a8ab42ff67dcdb76ee2ab229e591de1cb375455","modified":1485184622000},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1485184622000},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1485184622000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"5864f5567ba5efeabcf6ea355013c0b603ee07f2","modified":1485184622000},{"_id":"themes/next/layout/_macro/post.swig","hash":"e6016def9b512188f4c2725399c9adc7bc41cdae","modified":1485184622000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"37e5b7c42ec17b9b6b786c5512bcc481a21c974e","modified":1485184622000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"43d8830bb19da4fc7a5773866be19fa066b62645","modified":1485184622000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"14e785adeb0e671ba0ff9a553e6f0d8def6c670c","modified":1485184622000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"78ccfc1dc915247c1fec3c86d742e0f4c2f6d99c","modified":1485184622000},{"_id":"themes/next/layout/_partials/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1485184622000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"d5ac38ad5064c9cdb44d1d98c7ac26f6bbee3a2c","modified":1489775828000},{"_id":"themes/next/layout/_partials/head.swig","hash":"ca56f92e2fa82b03853869f5073ee1a5626a4796","modified":1485184622000},{"_id":"themes/next/layout/_partials/header.swig","hash":"adab5c3f7b173f1b45454787f39dde07aea03483","modified":1485184622000},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"39d613e5a9f8389d4ea52d6082502af8e833b9f2","modified":1485184622000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1485184622000},{"_id":"themes/next/layout/_partials/search.swig","hash":"1431719d1dbba3f5ee385eebc46376d1a960b2d5","modified":1485184622000},{"_id":"themes/next/layout/_scripts/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1485184622000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1485184622000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1485184622000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"4512867d80d9eddfc3a0f5fea3c456f33aa9d522","modified":1485184622000},{"_id":"themes/next/scripts/tags/button.js","hash":"62e6dbeb53d07627a048132c79630b45d9a8f2cc","modified":1485184622000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1485184622000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1485184622000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1485184622000},{"_id":"themes/next/scripts/tags/note.js","hash":"6752925eedbdb939d8ec4d11bdfb75199f18dd70","modified":1485184622000},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1485184622000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1485184622000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1485184622000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1485184622000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1485184622000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1485184622000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1485184622000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1485184622000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1485184622000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1485184622000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1485184622000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1485184622000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1485184622000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1485184622000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1485184622000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1485184622000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1485184622000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1485184622000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1485184622000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1485184622000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1485184622000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1485184622000},{"_id":"themes/next/.git/refs/heads/master","hash":"2311b7302155cc3ec46e40ad16dc5c94e36328b4","modified":1485184622000},{"_id":"themes/next/layout/_components/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1485184622000},{"_id":"themes/next/layout/_components/algolia-search/dom.swig","hash":"636f1181dd5887a70b4a08ca8f655d4e46635792","modified":1485184622000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1485184622000},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1485184622000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"ff5523d5dacaa77a55a24e50e6e6530c3b98bfad","modified":1485184622000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1485184622000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1485184622000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1485184622000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1485184622000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1485184622000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1485184622000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1485184622000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1485184622000},{"_id":"themes/next/layout/_scripts/third-party/analytics.swig","hash":"394d9fff7951287cc90f52acc2d4cbfd1bae079d","modified":1485184622000},{"_id":"themes/next/layout/_scripts/third-party/comments.swig","hash":"4abc01bc870e1d7a783cdbd26166edc782a6a4f4","modified":1485184622000},{"_id":"themes/next/layout/_scripts/third-party/lean-analytics.swig","hash":"92dc60821307fc9769bea9b2d60adaeb798342af","modified":1485184622000},{"_id":"themes/next/layout/_scripts/third-party/localsearch.swig","hash":"b460e27db3dcd4ab40b17d8926a5c4e624f293a9","modified":1485184622000},{"_id":"themes/next/layout/_scripts/third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1485184622000},{"_id":"themes/next/layout/_scripts/third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1485184622000},{"_id":"themes/next/layout/_scripts/third-party/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1485184622000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1485184622000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"715d5b40dc52f319fe4bff0325beb874774d9bd9","modified":1485184622000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"78a83c38f69a8747bb74e420e6c9eeef1ea76525","modified":1485184622000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1485184622000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"b1c48593fab6012eafa7d67597c15e01bf4066ff","modified":1485187661000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"6dabdfebc2da44188ff4bc4bdb51ced004a7e56d","modified":1485187529000},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1485184622000},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"96b29f69b8b916b22f62c9959a117b5a968200a5","modified":1485184622000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1485184622000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1485184622000},{"_id":"themes/next/source/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1485184622000},{"_id":"themes/next/source/js/src/post-details.js","hash":"2038f54e289b6da5def09689e69f623187147be5","modified":1485184622000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1485184622000},{"_id":"themes/next/source/js/src/utils.js","hash":"384e17ff857f073060f5bf8c6e4f4b7353236331","modified":1485184622000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1485184622000},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1485184622000},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1485184622000},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1485184622000},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1485184622000},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1485184622000},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1485184622000},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1485184622000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"c1072942459fa0880e8a33a1bd929176b62b4171","modified":1485184622000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1485184622000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1485184622000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1485184622000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1485184622000},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1485184622000},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1485184622000},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1485184622000},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1485184622000},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1485184622000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1485184622000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1485184622000},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1485184622000},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1485184622000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1485184622000},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1485184622000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1485184622000},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1485184622000},{"_id":"themes/next/.git/logs/refs/heads/master","hash":"9a8ab42ff67dcdb76ee2ab229e591de1cb375455","modified":1485184622000},{"_id":"themes/next/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1485184622000},{"_id":"themes/next/layout/_scripts/third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1485184622000},{"_id":"themes/next/layout/_scripts/third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1485184622000},{"_id":"themes/next/layout/_scripts/third-party/analytics/busuanzi-counter.swig","hash":"4fcbf57c4918528ab51d3d042cff92cf5aefb599","modified":1485184622000},{"_id":"themes/next/layout/_scripts/third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1485184622000},{"_id":"themes/next/layout/_scripts/third-party/analytics/facebook-sdk.swig","hash":"394d008e5e94575280407ad8a1607a028026cbc3","modified":1485184622000},{"_id":"themes/next/layout/_scripts/third-party/analytics/google-analytics.swig","hash":"30a23fa7e816496fdec0e932aa42e2d13098a9c2","modified":1485184622000},{"_id":"themes/next/layout/_scripts/third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1485184622000},{"_id":"themes/next/layout/_scripts/third-party/comments/disqus.swig","hash":"fb1d04ede838b52ca7541973f86c3810f1ad396e","modified":1485184622000},{"_id":"themes/next/layout/_scripts/third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1485184622000},{"_id":"themes/next/layout/_scripts/third-party/comments/gentie.swig","hash":"03592d1d731592103a41ebb87437fe4b0a4c78ca","modified":1485184622000},{"_id":"themes/next/layout/_scripts/third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1485184622000},{"_id":"themes/next/layout/_scripts/third-party/comments/youyan.swig","hash":"ea8078fa9e10be2bb042749d8b6a97adc38f914c","modified":1485184622000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"b49efc66bd055a2d0be7deabfcb02ee72a9a28c8","modified":1485184622000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1485184622000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1485184622000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"10994990d6e0b4d965a728a22cf7f6ee29cae9f6","modified":1485184622000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1485184622000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1485184622000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1485184622000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"5304f99581da3a31de3ecec959b7adf9002fde83","modified":1485184622000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"54c90cf7bdbf5c596179d8dae6e671bad1292662","modified":1485184622000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1485184622000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"013619c472c7e4b08311c464fcbe9fcf5edde603","modified":1485184622000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1485184622000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1485184622000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1485184622000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1485184622000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1485184622000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"fda14bc35be2e1b332809b55b3d07155a833dbf4","modified":1485184622000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1485184622000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1485184622000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1485184622000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1485184622000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"82bbaa6322764779a1ac2e2c8390ce901c7972e2","modified":1485184622000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1485184622000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1485184622000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"ff9f163bb05c0709577040a875924d36c9ab99d6","modified":1485184622000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"dcf9fe43b2ef78b923118ba39efedb38760e76b1","modified":1485184622000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"1408209dfb9a22a0982a30bdbd14842c2b53f264","modified":1485184622000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1485184622000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"9b63bd8effc7cf4b96acdea4d73add7df934a222","modified":1485184622000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1485184622000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"9ccee9189c910b8a264802d7b2ec305d12dedcd0","modified":1485184622000},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1485184622000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1485184622000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1485184622000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1485184622000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1485184622000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1485184622000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1485184622000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1485184622000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1485184622000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1485184622000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1485184622000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"4eda182cbcc046dbf449aef97c02c230cf80a494","modified":1485184622000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1485184622000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"fb5b49426dee7f1508500e698d1b3c6b04c8fcce","modified":1485184622000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1485184622000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1485184622000},{"_id":"themes/next/.git/objects/pack/pack-70fa44f18a74f7390de80c3a31441723f4bc5273.idx","hash":"b4cf99299a1ffd0a310c392df8f4c5b4da218c50","modified":1485184622000},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1485184622000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1485184622000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1485184622000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1485184622000},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1485184622000},{"_id":"themes/next/.git/logs/refs/remotes/origin/HEAD","hash":"9a8ab42ff67dcdb76ee2ab229e591de1cb375455","modified":1485184622000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1485184622000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1485184622000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"c890ce7fe933abad7baf39764a01894924854e92","modified":1485184622000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1485184622000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1485184622000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1485184622000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"7778920dd105fa4de3a7ab206eeba30b1a7bac45","modified":1485184622000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1485184622000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1485184622000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1485184622000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1485184622000},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1485184622000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"4b7f81e1006e7acee3d1c840ccba155239f830cc","modified":1485184622000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1485184622000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"8fae54591877a73dff0b29b2be2e8935e3c63575","modified":1485184622000},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"fdfadbb4483043c7e0afd541ee9712389e633517","modified":1485184622000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1485184622000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"b25132fe6a7ad67059a2c3afc60feabb479bdd75","modified":1485184622000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1485184622000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"7f1aab694caf603809e33cff82beea84cd0128fd","modified":1485184622000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"c6dab7661a6b8c678b21b7eb273cef7100f970f6","modified":1485184622000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"e792c8dc41561c96d128e9b421187f1c3dc978a0","modified":1485184622000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1485184622000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"963105a531403d7aad6d9e5e23e3bfabb8ec065a","modified":1485184622000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1485184622000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"bfd806d0a9f21446a22df82ac02e37d0075cc3b5","modified":1485184622000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"2e7ec9aaa3293941106b1bdd09055246aa3c3dc6","modified":1485184622000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"0ca5bf57ea1e024d3b8a4eaf30c1418aacb10b97","modified":1485187682000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"c44f6a553ec7ea5508f2054a13be33a62a15d3a9","modified":1485184622000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1485184622000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1485184622000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"7690b9596ec3a49befbe529a5a2649abec0faf76","modified":1485184622000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"2d3abbc85b979a648e0e579e45f16a6eba49d1e7","modified":1485184622000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"234facd038f144bd0fe09a31ed1357c5d74c517f","modified":1485184622000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1485184622000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1485184622000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"b8969e1654eec89a0fd10d88b337fee9cb03cd44","modified":1485184622000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1485184622000},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"74d0ba86f698165d13402670382a822c8736a556","modified":1485184622000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"3eb73cee103b810fa56901577ecb9c9bb1793cff","modified":1485184622000},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"eba491ae624b4c843c8be4c94a044085dad4ba0f","modified":1485184622000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1485184622000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"b03f891883446f3a5548b7cc90d29c77e62f1053","modified":1485184622000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1485184622000},{"_id":"themes/next/source/css/_common/components/third-party/gentie.styl","hash":"586a3ec0f1015e7207cd6a2474362e068c341744","modified":1485184622000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1485184622000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"637c6b32c58ecf40041be6e911471cd82671919b","modified":1485184622000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"42348219db93a85d2ee23cb06cebd4d8ab121726","modified":1485184622000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1485184622000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1485184622000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1485184622000},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1485184622000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1485184622000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1485184622000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1485184622000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1485184622000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1485184622000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1485184622000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1485184622000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0","modified":1485184622000},{"_id":"themes/next/.git/objects/pack/pack-70fa44f18a74f7390de80c3a31441723f4bc5273.pack","hash":"38a8ff9d0c26e00a6808a13fad2010aa0838e15e","modified":1485184622000},{"_id":"public/categories/index.html","hash":"25a4aa67f1a8f674b4f2e266b478b24ce82db971","modified":1520703823393},{"_id":"public/tags/index.html","hash":"fb576ab0d4ce86ce4ca29cfbda4cd2185e9b5860","modified":1520703823394},{"_id":"public/archives/index.html","hash":"fabbcf2b2c2d4facff67eccef23bdf19d757f77b","modified":1520703823394},{"_id":"public/archives/page/2/index.html","hash":"8e2d63cd8b9af8e2a65d3f72a38a765b100723a5","modified":1520703823394},{"_id":"public/archives/2017/index.html","hash":"d48e84cb70c5ea9af9bdb14913dde9eb23525f9b","modified":1520703823394},{"_id":"public/archives/2017/03/index.html","hash":"f5f3fbe542a9d259c7cab51d44696c07020d2146","modified":1520703823394},{"_id":"public/archives/2017/04/index.html","hash":"d4707b5637ee980147ab4b12d1e28f6978dc3689","modified":1520703823394},{"_id":"public/archives/2017/05/index.html","hash":"f5318e18959a7e244979dd76aa0cbc2314b9f414","modified":1520703823394},{"_id":"public/archives/2017/07/index.html","hash":"67beeb0f8b5f02ff1ab76f200e9f2b68b584da89","modified":1520703823394},{"_id":"public/archives/2017/08/index.html","hash":"0c543b826ec689fd65d005fb62fa10e90026fb6f","modified":1520703823395},{"_id":"public/archives/2017/09/index.html","hash":"1f78bf44e69ea5942e3d103e0c6c17182b98ad5e","modified":1520703823395},{"_id":"public/archives/2017/10/index.html","hash":"8112971c1eaa516152f798674ebafd6fb112a8bc","modified":1520703823395},{"_id":"public/archives/2017/12/index.html","hash":"3fda64364764566bd0fff20abc2cbbbf3574bb7f","modified":1520703823395},{"_id":"public/archives/2018/index.html","hash":"e6879e9f50cb0152b7c9d4de602a0583e6842fcb","modified":1520703823395},{"_id":"public/archives/2018/02/index.html","hash":"2686ef26da5ba54975deb9aed6c5f9e500800f32","modified":1520703823395},{"_id":"public/archives/2018/03/index.html","hash":"c3d7399e34f2404aa8fa4f5e03386c236cd50b8e","modified":1520703823395},{"_id":"public/categories/javascript/index.html","hash":"a65ac70b3f47f44198e29d3179f48d095b175346","modified":1520703823395},{"_id":"public/categories/Hexo/index.html","hash":"7d6d10b4117af68a161fa18a0db1da26b0dffe5c","modified":1520703823395},{"_id":"public/categories/读书笔记/index.html","hash":"fee411e31f18cff462d63ecf1941c6a81756e6a5","modified":1520703823395},{"_id":"public/categories/架构模式/index.html","hash":"9e187f9cdf3823335daaa2615ad081fd3edd3a26","modified":1520703823395},{"_id":"public/categories/javascript/React/index.html","hash":"f1890b2ff283c36b5ebbf71ec32cacffb2244354","modified":1520703823395},{"_id":"public/categories/前端状态管理/index.html","hash":"a5bfc7baa8f4b38b0697b32ab6f94a04e32ef099","modified":1520703823395},{"_id":"public/categories/设计模式/index.html","hash":"f0077212356eacf5ffd6c2f560f935648e39c976","modified":1520703823395},{"_id":"public/categories/随笔/index.html","hash":"b1dcb49ae36f1b26bc109441c9eef7d725f53e72","modified":1520703823396},{"_id":"public/categories/架构模式/设计模式/index.html","hash":"5e58b61e4dd2b91ec15d179410dbc30e71d859cd","modified":1520703823396},{"_id":"public/tags/作用域链/index.html","hash":"d317ad83cdd6cdc9561c949568efb80644e88f3c","modified":1520703823396},{"_id":"public/tags/执行期上下文/index.html","hash":"97179c9d327f78226effbb997a357044ca72c828","modified":1520703823396},{"_id":"public/tags/javascript核心/index.html","hash":"74d0755843b7ef6878e8d87be79036c3daa6fce4","modified":1520703823396},{"_id":"public/tags/this/index.html","hash":"c3d589fa7e4d120ef0bb65e8d7e099a38d3c8a9c","modified":1520703823396},{"_id":"public/tags/博客/index.html","hash":"b014d59d8e1e42df1700c462324515abe908c159","modified":1520703823396},{"_id":"public/tags/hexo/index.html","hash":"5be05ceab6d7047487130508244c8d9fb90d504a","modified":1520703823396},{"_id":"public/tags/函数节流（throttle）/index.html","hash":"00a10ce134dcdb8eaea2dc4ff09e714edf35cdeb","modified":1520703823396},{"_id":"public/tags/函数防抖（debounce）/index.html","hash":"0c4096a21bd12ec6a842b740aa620a7212159795","modified":1520703823396},{"_id":"public/tags/深度工作/index.html","hash":"14b4e79f4a67e4922e7df1c39725986a27bfde47","modified":1520703823396},{"_id":"public/tags/MVC/index.html","hash":"e38b1671b452224079a342af7ed8b297c9b0acdd","modified":1520703823396},{"_id":"public/tags/MVP/index.html","hash":"534157cd9fc208e098654936969bdef2fcf10e00","modified":1520703823396},{"_id":"public/tags/JSX/index.html","hash":"9d39e53269cf97e78b3d962cb58d1d7e3902bd68","modified":1520703823396},{"_id":"public/tags/React/index.html","hash":"3cd1d217f1aa97164e226e5e18f1cf7c86cad0e7","modified":1520703823396},{"_id":"public/tags/flux/index.html","hash":"e93c7ab5f98d766080ec34faed4000cb1c167fd4","modified":1520703823396},{"_id":"public/tags/数据流/index.html","hash":"e099e3fc8e14ca0db81fb423b936a78506856dba","modified":1520703823396},{"_id":"public/tags/redux/index.html","hash":"86d34886fd7d0b6c2b4558a618c4433cd56b239a","modified":1520703823396},{"_id":"public/tags/设计模式/index.html","hash":"14ce27370b90f4eabada96d4cf9418007c0a87ec","modified":1520703823396},{"_id":"public/tags/工厂模式/index.html","hash":"0b1e5fee2de9be134c1ba76d78d898c52155d6af","modified":1520703823396},{"_id":"public/tags/创建型模式/index.html","hash":"cdc863b370dd448ce64ce299c8cf3c0e4148bc68","modified":1520703823396},{"_id":"public/tags/随笔/index.html","hash":"76bd720881f01ada5a5d11351ba6cdc6a40e78cc","modified":1520703823396},{"_id":"public/tags/游戏/index.html","hash":"54535177fa77df841da46ad65f1bd3e443325c79","modified":1520703823396},{"_id":"public/tags/RSA/index.html","hash":"e37238485ad10b5ad3cb2140632fdbf327d54eaf","modified":1520703823397},{"_id":"public/tags/非对称加密/index.html","hash":"b088dc2bdbc9321343f354f2a74b1836826ad60b","modified":1520703823397},{"_id":"public/tags/数字签名/index.html","hash":"87b93c2096133d6c914c66a034e7d1f17334fdd6","modified":1520703823397},{"_id":"public/2018/03/11/hello-hexo/index.html","hash":"881151417a7295e9e6cb14cc838fea1b1179f41c","modified":1520703823397},{"_id":"public/2018/02/23/非对称加密及其应用/index.html","hash":"ad69bb8736f0da25e5911a0ead830f155f2288a5","modified":1520703823397},{"_id":"public/2017/12/06/理解redux/index.html","hash":"96446e4aae55523c07690a40b806310404a08744","modified":1520703823397},{"_id":"public/2017/10/08/《深度工作》笔记/index.html","hash":"0e02ed77a7e7ee9517431119901b05f039fc8c3b","modified":1520703823397},{"_id":"public/2017/10/05/前端MVC/index.html","hash":"26d370c98671468fa0d01332b1a27b0ba1cb1180","modified":1520703823398},{"_id":"public/2017/09/16/理解Flux/index.html","hash":"b8b454cfa37a2c4a318d6ec5118cdb7673eb231f","modified":1520703823398},{"_id":"public/2017/08/27/设计模式之工厂模式/index.html","hash":"d79e760c0adce55478d792b915d10d68787d7d10","modified":1520703823398},{"_id":"public/2017/07/17/随笔：《王者荣耀》-论网游成瘾/index.html","hash":"ee90e67048b1649b14c51ed906ec108780627d03","modified":1520703823398},{"_id":"public/2017/07/10/深入理解JSX/index.html","hash":"e2ad19da5964d09f4a93ad7ce55be1f687f3dab0","modified":1520703823398},{"_id":"public/2017/05/07/javascript函数节流(throttle)和函数防抖(debounce)及其实现/index.html","hash":"b603392a1636b6339a1b792a1e099b9e860f30f2","modified":1520703823398},{"_id":"public/2017/04/09/Javascript之执行上下文/index.html","hash":"d9482b5e21563e9af55248a126583446941e15a1","modified":1520703823398},{"_id":"public/2017/03/27/Javascript语言之蜜汁this/index.html","hash":"03deeae21ea3a2ed5a8b8ab52aed26171a2cc57f","modified":1520703823398},{"_id":"public/index.html","hash":"d43f6a49b27d8af9c8255b0d2d0eeba22935f64d","modified":1520703823398},{"_id":"public/page/2/index.html","hash":"24188d21e63fde1404f3e8d192184adeda9706f7","modified":1520703823398},{"_id":"public/CNAME","hash":"3c12c9d912db13e9094053e040d2f9ebece0aad7","modified":1520703823449},{"_id":"public/img/s.png","hash":"33b16e4425cd772192a5cd0d1f0aab6fa251d3b3","modified":1520703823450},{"_id":"public/images/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1520703823450},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1520703823450},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1520703823450},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1520703823450},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1520703823450},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1520703823450},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1520703823450},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1520703823450},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1520703823450},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1520703823450},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1520703823450},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1520703823451},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1520703823451},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1520703823451},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1520703823451},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1520703823451},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1520703823451},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1520703823451},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1520703823451},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1520703823451},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1520703823451},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1520703823451},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1520703823451},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1520703823451},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1520703824213},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1520703824230},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1520703824234},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1520703824234},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1520703824239},{"_id":"public/js/src/algolia-search.js","hash":"96b29f69b8b916b22f62c9959a117b5a968200a5","modified":1520703824239},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1520703824239},{"_id":"public/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1520703824239},{"_id":"public/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1520703824240},{"_id":"public/js/src/post-details.js","hash":"2038f54e289b6da5def09689e69f623187147be5","modified":1520703824240},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1520703824240},{"_id":"public/js/src/utils.js","hash":"384e17ff857f073060f5bf8c6e4f4b7353236331","modified":1520703824240},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1520703824240},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1520703824240},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1520703824240},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1520703824240},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1520703824240},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1520703824240},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1520703824240},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1520703824240},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1520703824241},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1520703824241},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1520703824241},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1520703824241},{"_id":"public/js/src/schemes/pisces.js","hash":"9ccee9189c910b8a264802d7b2ec305d12dedcd0","modified":1520703824241},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1520703824241},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1520703824241},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1520703824241},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1520703824241},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1520703824241},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1520703824241},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1520703824241},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1520703824241},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1520703824241},{"_id":"public/css/main.css","hash":"f7e95c6d6fe7ff5f7c922dd5c84520516a2fa0be","modified":1520703824241},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1520703824241},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1520703824242},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1520703824242},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1520703824242},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1520703824242},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1520703824242},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"4eda182cbcc046dbf449aef97c02c230cf80a494","modified":1520703824242},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"fb5b49426dee7f1508500e698d1b3c6b04c8fcce","modified":1520703824242},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1520703824242},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1520703824243},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1520703824243},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0","modified":1520703824251}],"Category":[{"name":"javascript","_id":"cjelnshch00033gff3c5bwmnc"},{"name":"Hexo","_id":"cjelnshcx000d3gfffq7bdym9"},{"name":"读书笔记","_id":"cjelnshd1000j3gffk2pdoxs2"},{"name":"架构模式","_id":"cjelnshd6000q3gff5254db7k"},{"name":"React","parent":"cjelnshch00033gff3c5bwmnc","_id":"cjelnshda000v3gff0jzq4juk"},{"name":"前端状态管理","_id":"cjelnshdb000z3gffbue7r4c1"},{"name":"设计模式","_id":"cjelnshdc00183gffn007or1z"},{"name":"随笔","_id":"cjelnshdd001b3gff37lejijy"},{"name":"设计模式","parent":"cjelnshd6000q3gff5254db7k","_id":"cjelnshdf001g3gffkrdoqeks"}],"Data":[],"Page":[{"title":"分了个类","date":"2017-01-23T16:46:09.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分了个类\ndate: 2017-01-24 00:46:09\ntype: \"categories\"\n---\n","updated":"2018-03-10T16:05:26.000Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cjelnshc900013gffm42cb0r1","content":"","excerpt":"","more":""},{"title":"tags","date":"2017-03-15T17:20:21.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2017-03-16 01:20:21\ntype: \"tags\"\n---\n","updated":"2018-03-10T16:05:26.000Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjelnship002h3gffvlobhdqo","content":"","excerpt":"","more":""}],"Post":[{"title":"Javascript之执行上下文","date":"2017-04-09T08:21:50.000Z","_content":"\n### 关键词\n* 执行期上下文（excution context简称EC）：简称上下文（又叫执行环境）\n* 作用域链 （scope chain）\n* 变量对象（variable object简称VO）\n* 活动对象（activation object简称AO）\n\n### 概述\n执行上下文是Javascript中最重要的一个概念。每一段代码的执行都与它息息相关。理解了它，才能真正理解我们写的的javascript代码是如何运行的。\nECMA-262（5.1）中写道：当控制器转入 ECMAScript的可执行代码时，控制器会进入(注：创建)一个执行上下文。\n<!-- more -->\n#### 可执行代码\n这里先解释下上面提到的可执行代码，我们看一下ES5规范（以下从简了）\n\n* 全局代码：是指被作为ECMAScript程序处理的源代码文本。一个特定程序的全局代码不包括作为函数体被解析的源代码文本。\n* 函数代码：是指作为函数体被解析的源代码文本。不包括作为其嵌套函数的 函数体 被解析的源代码文本。\n* Eval 代码 是指提供给eval内置函数的源代码文本。（现在应用比较少，这一点本文忽略）\n\n\n现在可以对上面关于上下文的说法换一种说法：<br>\n\n* 当控制器转入 ECMAScript的全局代码，控制器会创建一个全局上下文。\n* 当转入函数代码，控制器会创建一个函数上下文。\n\n### 执行上下文\n我们已经知道了什么时候会创建一个上下文，那接下来就要说下上下文具体是个什么东西。<br>\nES5规范里说：执行上下文包含所有用于追踪与其相关的代码的执行进度的状态。<br>\n翻译一下是说：执行上下文里有代码执行时需要用到的东西。<br>\n现在问题就具体到了：执行上下文里都有什么？那么我们来看一下：\n\n#### 执行上下文的组成\n\n| 组件|内部组成 |作用|\n|--- |--- | ---|\n|变量对象（VO） | {vars:...,function declarations:...,arguments:...,...}| 指定一个词法环境对象，其环境数据用于保存由该执行上下文内的变量声明 和 函数声明。|\n|作用域链（scope chain）     | [ variable object + [[scope]]）  |指定一个词法环境对象，用于解析该执行环境内的代码创建的标识符引用。|\n|this指针|  |指定该执行上下文内的 ECMAScript代码中this关键字所关联的值。 |\n\n\n\n为了方便理解，一个执行上下文可以抽象为object。每一个执行上下文都有一系列的属性（我们称为上下文状态，即上面表格做左侧组件一列的属性）。接下来就对上面表格中的三个状态属性来一一说明。\n\n#### 变量对象  （VO）\n\n变量对象是与执行上下文相关的数据作用域(scope of data) ,用于存储被定义在上下文中的变量声明和函数声明(注意：不包括函数表达式[详见](http://www.cnblogs.com/TomXu/archive/2011/12/29/2290308.html)) 。<br>\n定义已经很明确了，我们通过具体的栗子看下全局上下文的VO：\n\n``` javascript\n    var foo = 2;        \n    function bar() {} // 函数声明\n    (function baz() {}); // 函数表达式   \n    console.log(\n      this.foo == foo, // true\n      window.bar == bar // true\n    );  \n    console.log(baz); // Uncaught ReferenceError: baz is not defined\n```\n该例中全局上下文中变量对象会有以下属性：    \n    \n|global VO||\n|---|---|   \n|foo | undefined --> 10|\n|bar | function... |    \n|built-ins（忽略）| 一些内置的全局变量\n\n这是全局上下文中的变量对象，除了全局上下文还有函数上下文，那么函数上下文是否是一样的呢？答案是稍微有点不一样：函数内活动对象（AO）用作变量对象。接下来我们看下AO。<br>\n\n>在global全局上下文中，变量对象也是全局对象自身[global object],如浏览器中是window,此时我们可以通过全局对象的属性来指向全局变量,通过this来访问全局对象。然而在函数上下文内我们是无法直接访问这个对象的,this也不指向这个对象。<br>\n    \n#### 函数的活动对象（AO）\n    \n当函数被调用者激活（即函数调用），活动对象 就被创建了。它包含普通参数即形参(formal parameters) 与特殊参数(arguments)对象(具有索引属性的参数映射表)。活动对象在函数上下文中作为变量对象使用。\n    \n   还是举个栗子看下函数的活动对象:\n``` javascript\n    function foo(x, y) {\n      console.log(z); //undefined\n      var z = 3;\n      console.log(z);//3\n      function bar() {} // 函数声明\n      (function baz() {}); // 函数表达式\n    }\n    foo(1, 2);\n```\n   上面当foo被调用时，foo函数上下文的活动对象(AO)被创建，其内容如下表格：\n  \n  \n|Activation object| |\n| ---|---|\n|x | 1 |\n|y | 2 |\n|arguments| { {0:{x:1}, {1:{y:1}} }|\n|z | undefined-->3|\n|bar| funciton |\n   \n   \n前面我们已经知道变量对象中不包含函数表达式，这里活动对象内也不包括函数表达式。\n\n我们已经知道了VO和AO的内容组成了，那么他们是什么时候被创建的，又是什么时候改变的呢？<br>\n>VO|AO在每次创建上下文时作为上下文的组成部分被创建，并填入初始值;值的更新出现在代码执行阶段。<br>\n\n\n上面两个例子中我们知道了，全局上下文中，我们定义的变量和声明的函数都作为全局上下文的变量对象的属性来保存，代码执行时标志符的查找也是从全局上下文的变量对象中查找。在某一个函数上下文中也类似，在当前上下文中的标志符会先在当前变量对象（函数上下文中是活动对象）中查找。但是当在当前上下文的变量对象找不到的时候会发生什么呢？答案是：完整的标志符解析是通过作用域链（scope chain）机制来完成的。（不容易啊，终于比较自然的把作用域链给引出来了）。那么我们来看一下什么是作用域链。\n\n#### 作用域链（scope chain）\n\n作用域链是一个 对象列表(list of objects) ，用以检索上下文代码中出现的 标识符(identifiers) 。先说结果：\n\n> scope chain = VO|AO + [[scope]] \n\n依然看个栗子：\n``` javascript\n    var x = 1;\n    function foo() { \n      var y = 2; \n      function bar() {\n        console.log(x + y);\n      } \n      return bar; \n    }\n     \n    foo()(); // 3\n```\n\n这段代码执行完，共创建了三个执行上下文：执行流进入这段全局代码会创建一个全局上下文，foo调用时创建foo上下文，bar被调用时创建bar上下文(foo()-->bar调用)。\n这里我们暂且只看一下bar的上下文，我们已经知道一个上下文的数据域即一个上下文的变量对象,在函数上下文即是活动对象（AO），那我们就看下bar函数的活动对象。<br>\n当执行流进入bar函数，且函数体内代码执行之前，javascript引擎会创建这个函数的AO：\n\n| AO||\n|---|---|\n|arguments|[callee: function, Symbol(Symbol.iterator): function]|\n\n我们看到bar函数提内代码执行之前创建的这个AO并没有函数体中需要用到的变量x和y,那么当代码执行到console.log(x + y)时，x和y是从哪里读取的呢？不难看出：y存在创建的foo函数上下文的活动对象中；x存在创建的全局上下文的变量对象中。好像是函数内可以访问到函数祖父级上下文的变量对象里的东西。实际上也是这样的。而能访问到祖父上下文的变量对象，正是通过函数的一个内部属性--[[scope]]实现的。\n\n##### [[scope]]\n[[scope]]是ECMA262规定的对象的私有属性，理论上只有JS引擎可以访问。\n\n* [[scope]]是所有祖父变量对象的层级链。\n* [[scope]]在函数创建时被存储－－静态（不变的），直至函数销毁。\n\n\n拓展阅读[例子](http://www.cnblogs.com/TomXu/archive/2012/01/18/2312463.html)。\n\n所以一个函数内代码执行时，函数内遇到的标志符就是这样先从当前上下文的活动对象内查找，若找不着继续查找父上下文的变量对象，直到查到全局上下文。而这也正是javascript中的`变量标志符查找机制`。\n\n\n##### 标志符解析机制\n我们直接看规范（ES3 10.1.4章节）：\n\n每个执行上下文都有一个与之相关联的作用域链（scope chain）。作用域链是一个由对象组成的链表，求值标志符的时候会对它搜索。当创建一个上下文时，根据当前上下文的代码类型（全局代码或函数代码）一个作用域链被创建，并用初始化对象填充（函数代码被填充为函数的[[scope]]属性值-接下来讲；全局代码初始化为空吧。当VO|AO被创建后，VO|AO被推到作用域链的前端）。一个上下文中代码执行时，其作用域链只会被 with 声明（见 12.10）和 catch 语句（见 12.14）所影响。标志符解析的具体规则：\n\n1. 获取作用域链中的下一个对象。如果没有，转到步骤 5。\n2. 调用结果(1) 的 [[HasProperty]] 方法，把标识符（Identifier）作为属性名传递。\n3. 如果结果(2) 为true，返回一个引用类型的值，其基对象（base objecqit）是结果(1),其property name是该Identifier。\n符。\n4. 转到步骤 1。\n5. 返回一个引用类型的值，其base object为 null，其property name 是Identifier。\n求值标识符的结果总是一个引用类型的值，其成员名字组件与标识符字符串相等。\n\n> 注：Reference(引用)类型的值是JS引擎使用的一种数据类型，它分为base object和property  name两个部分。假设在JS代码中有obj.prop这样的表达式，那么解释成Reference类型，base object是对象obj,而property name是字符串”prop”。--winter\n  \n\n#### this\n至此上下文里还有this没说，我的总结是：this通常指向激活当前上下文的那个对象。this值在进入上下文时确定，并且在上下文运行期间不能被改变。<br> \n``` javascript\n    console.log(this);// global object\n    var  obj = { a: function(){ \n                        console.log(this)\n                    }\n                  }; \n     obj.a();//obj 可以理解为：obj.a的上下文是被obj这个对象激活的。\n```\n当然this绑定还有一些其他规则。详见另一篇博文[javascript之蜜汁this](https://foreverwang.github.io/2017/03/27/Javascript%E8%AF%AD%E8%A8%80%E4%B9%8B%E8%9C%9C%E6%B1%81this/)。\n\n\n#### 总结一下上下文：<br>\n上下文分为全局上下文和函数上下文。<br>\n全局上下文没啥好总结的，我们就看在函数上下文的整个生命周期。\n\n执行流进入一个函数时，引擎不是简单的立即执行函数体内的代码，可分为两个阶段：\n\n* 第一阶段：上下文创建阶段\n\t* 一个函数上下文被创建，同时作为上下文的一部分的作用域链也被创建，并被初始化为函数[[scope]]属性的值。\n\t* 接着javascript引擎创建当前上下文的活动对象（AO）,并且将AO推入作用域链的最前端。\n\t* 确定this的值。\n\t\n* 第二阶段：代码逐行执行--变量赋值、函数引用等\t。\n\n#### 上下文栈（EC）\n以上部分我们对单个上下文的创建和组成做了详细的说明。而一段代码的执行往往是涉及到很多个上下文。而在代码执行过程中这些上下文之间是什么关系呢？ <br>\n活动的上下文在逻辑上组成一个上下文栈。栈底是全局上下文，而栈顶是当前激活的上下文。<br>\n当js引擎执行全局代码前，会首先创建一个全局上下文。全局上下文创建完毕后，全局代码开始逐行被执行。代码执行过程中当一个函数被调用时，此时引擎会创建一个函数上下文，并且将其`推入`到上下文栈顶。引擎总是执行当前在栈顶的上下文的代码，函数执行完毕，上下文栈将该函数上下文`弹出`，控制权返回给之前的上下文。ECMAScript程序中的执行流正式被这个机制控制者。\n\n##### 相关推荐：\n\n\n* [大叔的深入理解JavaScript系列（10）：JavaScript核心](http://www.cnblogs.com/TomXu/archive/2012/01/12/2308594.html)\n* [What is the Execution Context & Stack in JavaScript?](http://davidshariff.com/blog/what-is-the-execution-context-in-javascript/) [(译文)](http://yanhaijing.com/javascript/2014/04/29/what-is-the-execution-context-in-javascript/)\n*  [ winter的JavaScript中的\\[\\[scope\\]\\]和Scope Chain](http://www.cnblogs.com/winter-cn/archive/2008/07/07/1237168.html)\n\n##### 结语\n本文主要参考了[ES3规范的第10章节Execution Contexts](http://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%203rd%20edition,%20December%201999.pdf)。行文上部分参考上面两篇博文。写的过程中，发现把这个主题涉及的内容很连贯的串起来还是不容易的。而网上的关于该主题的博文也没有（我没找到）很好的把这些内容连贯的串起来的。所以整理此文。不管怎样，至少自己梳理来了一边，更清晰了。\n执行上下文大概就这些东西了吧。这大概也是整个javascript这门语言最核心且没有之一的东西了。\n\n\n\n\n\n\n\n    \n    \n    \n\n\n\n\n\n\n\n\n   \n  \n\n   \n   \n   \n   \n   \n   \n   \n   \n\n\n   \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/Javascript之执行上下文.md","raw":"---\ntitle: Javascript之执行上下文\ndate: 2017-04-09 16:21:50\ncategories: \n- javascript \ntags: \n- 作用域链\n- 执行期上下文\n- javascript核心\n\n---\n\n### 关键词\n* 执行期上下文（excution context简称EC）：简称上下文（又叫执行环境）\n* 作用域链 （scope chain）\n* 变量对象（variable object简称VO）\n* 活动对象（activation object简称AO）\n\n### 概述\n执行上下文是Javascript中最重要的一个概念。每一段代码的执行都与它息息相关。理解了它，才能真正理解我们写的的javascript代码是如何运行的。\nECMA-262（5.1）中写道：当控制器转入 ECMAScript的可执行代码时，控制器会进入(注：创建)一个执行上下文。\n<!-- more -->\n#### 可执行代码\n这里先解释下上面提到的可执行代码，我们看一下ES5规范（以下从简了）\n\n* 全局代码：是指被作为ECMAScript程序处理的源代码文本。一个特定程序的全局代码不包括作为函数体被解析的源代码文本。\n* 函数代码：是指作为函数体被解析的源代码文本。不包括作为其嵌套函数的 函数体 被解析的源代码文本。\n* Eval 代码 是指提供给eval内置函数的源代码文本。（现在应用比较少，这一点本文忽略）\n\n\n现在可以对上面关于上下文的说法换一种说法：<br>\n\n* 当控制器转入 ECMAScript的全局代码，控制器会创建一个全局上下文。\n* 当转入函数代码，控制器会创建一个函数上下文。\n\n### 执行上下文\n我们已经知道了什么时候会创建一个上下文，那接下来就要说下上下文具体是个什么东西。<br>\nES5规范里说：执行上下文包含所有用于追踪与其相关的代码的执行进度的状态。<br>\n翻译一下是说：执行上下文里有代码执行时需要用到的东西。<br>\n现在问题就具体到了：执行上下文里都有什么？那么我们来看一下：\n\n#### 执行上下文的组成\n\n| 组件|内部组成 |作用|\n|--- |--- | ---|\n|变量对象（VO） | {vars:...,function declarations:...,arguments:...,...}| 指定一个词法环境对象，其环境数据用于保存由该执行上下文内的变量声明 和 函数声明。|\n|作用域链（scope chain）     | [ variable object + [[scope]]）  |指定一个词法环境对象，用于解析该执行环境内的代码创建的标识符引用。|\n|this指针|  |指定该执行上下文内的 ECMAScript代码中this关键字所关联的值。 |\n\n\n\n为了方便理解，一个执行上下文可以抽象为object。每一个执行上下文都有一系列的属性（我们称为上下文状态，即上面表格做左侧组件一列的属性）。接下来就对上面表格中的三个状态属性来一一说明。\n\n#### 变量对象  （VO）\n\n变量对象是与执行上下文相关的数据作用域(scope of data) ,用于存储被定义在上下文中的变量声明和函数声明(注意：不包括函数表达式[详见](http://www.cnblogs.com/TomXu/archive/2011/12/29/2290308.html)) 。<br>\n定义已经很明确了，我们通过具体的栗子看下全局上下文的VO：\n\n``` javascript\n    var foo = 2;        \n    function bar() {} // 函数声明\n    (function baz() {}); // 函数表达式   \n    console.log(\n      this.foo == foo, // true\n      window.bar == bar // true\n    );  \n    console.log(baz); // Uncaught ReferenceError: baz is not defined\n```\n该例中全局上下文中变量对象会有以下属性：    \n    \n|global VO||\n|---|---|   \n|foo | undefined --> 10|\n|bar | function... |    \n|built-ins（忽略）| 一些内置的全局变量\n\n这是全局上下文中的变量对象，除了全局上下文还有函数上下文，那么函数上下文是否是一样的呢？答案是稍微有点不一样：函数内活动对象（AO）用作变量对象。接下来我们看下AO。<br>\n\n>在global全局上下文中，变量对象也是全局对象自身[global object],如浏览器中是window,此时我们可以通过全局对象的属性来指向全局变量,通过this来访问全局对象。然而在函数上下文内我们是无法直接访问这个对象的,this也不指向这个对象。<br>\n    \n#### 函数的活动对象（AO）\n    \n当函数被调用者激活（即函数调用），活动对象 就被创建了。它包含普通参数即形参(formal parameters) 与特殊参数(arguments)对象(具有索引属性的参数映射表)。活动对象在函数上下文中作为变量对象使用。\n    \n   还是举个栗子看下函数的活动对象:\n``` javascript\n    function foo(x, y) {\n      console.log(z); //undefined\n      var z = 3;\n      console.log(z);//3\n      function bar() {} // 函数声明\n      (function baz() {}); // 函数表达式\n    }\n    foo(1, 2);\n```\n   上面当foo被调用时，foo函数上下文的活动对象(AO)被创建，其内容如下表格：\n  \n  \n|Activation object| |\n| ---|---|\n|x | 1 |\n|y | 2 |\n|arguments| { {0:{x:1}, {1:{y:1}} }|\n|z | undefined-->3|\n|bar| funciton |\n   \n   \n前面我们已经知道变量对象中不包含函数表达式，这里活动对象内也不包括函数表达式。\n\n我们已经知道了VO和AO的内容组成了，那么他们是什么时候被创建的，又是什么时候改变的呢？<br>\n>VO|AO在每次创建上下文时作为上下文的组成部分被创建，并填入初始值;值的更新出现在代码执行阶段。<br>\n\n\n上面两个例子中我们知道了，全局上下文中，我们定义的变量和声明的函数都作为全局上下文的变量对象的属性来保存，代码执行时标志符的查找也是从全局上下文的变量对象中查找。在某一个函数上下文中也类似，在当前上下文中的标志符会先在当前变量对象（函数上下文中是活动对象）中查找。但是当在当前上下文的变量对象找不到的时候会发生什么呢？答案是：完整的标志符解析是通过作用域链（scope chain）机制来完成的。（不容易啊，终于比较自然的把作用域链给引出来了）。那么我们来看一下什么是作用域链。\n\n#### 作用域链（scope chain）\n\n作用域链是一个 对象列表(list of objects) ，用以检索上下文代码中出现的 标识符(identifiers) 。先说结果：\n\n> scope chain = VO|AO + [[scope]] \n\n依然看个栗子：\n``` javascript\n    var x = 1;\n    function foo() { \n      var y = 2; \n      function bar() {\n        console.log(x + y);\n      } \n      return bar; \n    }\n     \n    foo()(); // 3\n```\n\n这段代码执行完，共创建了三个执行上下文：执行流进入这段全局代码会创建一个全局上下文，foo调用时创建foo上下文，bar被调用时创建bar上下文(foo()-->bar调用)。\n这里我们暂且只看一下bar的上下文，我们已经知道一个上下文的数据域即一个上下文的变量对象,在函数上下文即是活动对象（AO），那我们就看下bar函数的活动对象。<br>\n当执行流进入bar函数，且函数体内代码执行之前，javascript引擎会创建这个函数的AO：\n\n| AO||\n|---|---|\n|arguments|[callee: function, Symbol(Symbol.iterator): function]|\n\n我们看到bar函数提内代码执行之前创建的这个AO并没有函数体中需要用到的变量x和y,那么当代码执行到console.log(x + y)时，x和y是从哪里读取的呢？不难看出：y存在创建的foo函数上下文的活动对象中；x存在创建的全局上下文的变量对象中。好像是函数内可以访问到函数祖父级上下文的变量对象里的东西。实际上也是这样的。而能访问到祖父上下文的变量对象，正是通过函数的一个内部属性--[[scope]]实现的。\n\n##### [[scope]]\n[[scope]]是ECMA262规定的对象的私有属性，理论上只有JS引擎可以访问。\n\n* [[scope]]是所有祖父变量对象的层级链。\n* [[scope]]在函数创建时被存储－－静态（不变的），直至函数销毁。\n\n\n拓展阅读[例子](http://www.cnblogs.com/TomXu/archive/2012/01/18/2312463.html)。\n\n所以一个函数内代码执行时，函数内遇到的标志符就是这样先从当前上下文的活动对象内查找，若找不着继续查找父上下文的变量对象，直到查到全局上下文。而这也正是javascript中的`变量标志符查找机制`。\n\n\n##### 标志符解析机制\n我们直接看规范（ES3 10.1.4章节）：\n\n每个执行上下文都有一个与之相关联的作用域链（scope chain）。作用域链是一个由对象组成的链表，求值标志符的时候会对它搜索。当创建一个上下文时，根据当前上下文的代码类型（全局代码或函数代码）一个作用域链被创建，并用初始化对象填充（函数代码被填充为函数的[[scope]]属性值-接下来讲；全局代码初始化为空吧。当VO|AO被创建后，VO|AO被推到作用域链的前端）。一个上下文中代码执行时，其作用域链只会被 with 声明（见 12.10）和 catch 语句（见 12.14）所影响。标志符解析的具体规则：\n\n1. 获取作用域链中的下一个对象。如果没有，转到步骤 5。\n2. 调用结果(1) 的 [[HasProperty]] 方法，把标识符（Identifier）作为属性名传递。\n3. 如果结果(2) 为true，返回一个引用类型的值，其基对象（base objecqit）是结果(1),其property name是该Identifier。\n符。\n4. 转到步骤 1。\n5. 返回一个引用类型的值，其base object为 null，其property name 是Identifier。\n求值标识符的结果总是一个引用类型的值，其成员名字组件与标识符字符串相等。\n\n> 注：Reference(引用)类型的值是JS引擎使用的一种数据类型，它分为base object和property  name两个部分。假设在JS代码中有obj.prop这样的表达式，那么解释成Reference类型，base object是对象obj,而property name是字符串”prop”。--winter\n  \n\n#### this\n至此上下文里还有this没说，我的总结是：this通常指向激活当前上下文的那个对象。this值在进入上下文时确定，并且在上下文运行期间不能被改变。<br> \n``` javascript\n    console.log(this);// global object\n    var  obj = { a: function(){ \n                        console.log(this)\n                    }\n                  }; \n     obj.a();//obj 可以理解为：obj.a的上下文是被obj这个对象激活的。\n```\n当然this绑定还有一些其他规则。详见另一篇博文[javascript之蜜汁this](https://foreverwang.github.io/2017/03/27/Javascript%E8%AF%AD%E8%A8%80%E4%B9%8B%E8%9C%9C%E6%B1%81this/)。\n\n\n#### 总结一下上下文：<br>\n上下文分为全局上下文和函数上下文。<br>\n全局上下文没啥好总结的，我们就看在函数上下文的整个生命周期。\n\n执行流进入一个函数时，引擎不是简单的立即执行函数体内的代码，可分为两个阶段：\n\n* 第一阶段：上下文创建阶段\n\t* 一个函数上下文被创建，同时作为上下文的一部分的作用域链也被创建，并被初始化为函数[[scope]]属性的值。\n\t* 接着javascript引擎创建当前上下文的活动对象（AO）,并且将AO推入作用域链的最前端。\n\t* 确定this的值。\n\t\n* 第二阶段：代码逐行执行--变量赋值、函数引用等\t。\n\n#### 上下文栈（EC）\n以上部分我们对单个上下文的创建和组成做了详细的说明。而一段代码的执行往往是涉及到很多个上下文。而在代码执行过程中这些上下文之间是什么关系呢？ <br>\n活动的上下文在逻辑上组成一个上下文栈。栈底是全局上下文，而栈顶是当前激活的上下文。<br>\n当js引擎执行全局代码前，会首先创建一个全局上下文。全局上下文创建完毕后，全局代码开始逐行被执行。代码执行过程中当一个函数被调用时，此时引擎会创建一个函数上下文，并且将其`推入`到上下文栈顶。引擎总是执行当前在栈顶的上下文的代码，函数执行完毕，上下文栈将该函数上下文`弹出`，控制权返回给之前的上下文。ECMAScript程序中的执行流正式被这个机制控制者。\n\n##### 相关推荐：\n\n\n* [大叔的深入理解JavaScript系列（10）：JavaScript核心](http://www.cnblogs.com/TomXu/archive/2012/01/12/2308594.html)\n* [What is the Execution Context & Stack in JavaScript?](http://davidshariff.com/blog/what-is-the-execution-context-in-javascript/) [(译文)](http://yanhaijing.com/javascript/2014/04/29/what-is-the-execution-context-in-javascript/)\n*  [ winter的JavaScript中的\\[\\[scope\\]\\]和Scope Chain](http://www.cnblogs.com/winter-cn/archive/2008/07/07/1237168.html)\n\n##### 结语\n本文主要参考了[ES3规范的第10章节Execution Contexts](http://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%203rd%20edition,%20December%201999.pdf)。行文上部分参考上面两篇博文。写的过程中，发现把这个主题涉及的内容很连贯的串起来还是不容易的。而网上的关于该主题的博文也没有（我没找到）很好的把这些内容连贯的串起来的。所以整理此文。不管怎样，至少自己梳理来了一边，更清晰了。\n执行上下文大概就这些东西了吧。这大概也是整个javascript这门语言最核心且没有之一的东西了。\n\n\n\n\n\n\n\n    \n    \n    \n\n\n\n\n\n\n\n\n   \n  \n\n   \n   \n   \n   \n   \n   \n   \n   \n\n\n   \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Javascript之执行上下文","published":1,"updated":"2018-03-10T16:05:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjelnshc400003gffne33t2i5","content":"<h3 id=\"关键词\"><a href=\"#关键词\" class=\"headerlink\" title=\"关键词\"></a>关键词</h3><ul>\n<li>执行期上下文（excution context简称EC）：简称上下文（又叫执行环境）</li>\n<li>作用域链 （scope chain）</li>\n<li>变量对象（variable object简称VO）</li>\n<li>活动对象（activation object简称AO）</li>\n</ul>\n<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>执行上下文是Javascript中最重要的一个概念。每一段代码的执行都与它息息相关。理解了它，才能真正理解我们写的的javascript代码是如何运行的。<br>ECMA-262（5.1）中写道：当控制器转入 ECMAScript的可执行代码时，控制器会进入(注：创建)一个执行上下文。<br><a id=\"more\"></a></p>\n<h4 id=\"可执行代码\"><a href=\"#可执行代码\" class=\"headerlink\" title=\"可执行代码\"></a>可执行代码</h4><p>这里先解释下上面提到的可执行代码，我们看一下ES5规范（以下从简了）</p>\n<ul>\n<li>全局代码：是指被作为ECMAScript程序处理的源代码文本。一个特定程序的全局代码不包括作为函数体被解析的源代码文本。</li>\n<li>函数代码：是指作为函数体被解析的源代码文本。不包括作为其嵌套函数的 函数体 被解析的源代码文本。</li>\n<li>Eval 代码 是指提供给eval内置函数的源代码文本。（现在应用比较少，这一点本文忽略）</li>\n</ul>\n<p>现在可以对上面关于上下文的说法换一种说法：<br></p>\n<ul>\n<li>当控制器转入 ECMAScript的全局代码，控制器会创建一个全局上下文。</li>\n<li>当转入函数代码，控制器会创建一个函数上下文。</li>\n</ul>\n<h3 id=\"执行上下文\"><a href=\"#执行上下文\" class=\"headerlink\" title=\"执行上下文\"></a>执行上下文</h3><p>我们已经知道了什么时候会创建一个上下文，那接下来就要说下上下文具体是个什么东西。<br><br>ES5规范里说：执行上下文包含所有用于追踪与其相关的代码的执行进度的状态。<br><br>翻译一下是说：执行上下文里有代码执行时需要用到的东西。<br><br>现在问题就具体到了：执行上下文里都有什么？那么我们来看一下：</p>\n<h4 id=\"执行上下文的组成\"><a href=\"#执行上下文的组成\" class=\"headerlink\" title=\"执行上下文的组成\"></a>执行上下文的组成</h4><table>\n<thead>\n<tr>\n<th>组件</th>\n<th>内部组成</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>变量对象（VO）</td>\n<td>{vars:…,function declarations:…,arguments:…,…}</td>\n<td>指定一个词法环境对象，其环境数据用于保存由该执行上下文内的变量声明 和 函数声明。</td>\n</tr>\n<tr>\n<td>作用域链（scope chain）</td>\n<td>[ variable object + [[scope]]）</td>\n<td>指定一个词法环境对象，用于解析该执行环境内的代码创建的标识符引用。</td>\n</tr>\n<tr>\n<td>this指针</td>\n<td></td>\n<td>指定该执行上下文内的 ECMAScript代码中this关键字所关联的值。</td>\n</tr>\n</tbody>\n</table>\n<p>为了方便理解，一个执行上下文可以抽象为object。每一个执行上下文都有一系列的属性（我们称为上下文状态，即上面表格做左侧组件一列的属性）。接下来就对上面表格中的三个状态属性来一一说明。</p>\n<h4 id=\"变量对象-（VO）\"><a href=\"#变量对象-（VO）\" class=\"headerlink\" title=\"变量对象  （VO）\"></a>变量对象  （VO）</h4><p>变量对象是与执行上下文相关的数据作用域(scope of data) ,用于存储被定义在上下文中的变量声明和函数声明(注意：不包括函数表达式<a href=\"http://www.cnblogs.com/TomXu/archive/2011/12/29/2290308.html\" target=\"_blank\" rel=\"external\">详见</a>) 。<br><br>定义已经很明确了，我们通过具体的栗子看下全局上下文的VO：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"number\">2</span>;        </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;&#125; <span class=\"comment\">// 函数声明</span></div><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">baz</span>(<span class=\"params\"></span>) </span>&#123;&#125;); <span class=\"comment\">// 函数表达式   </span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(</div><div class=\"line\">  <span class=\"keyword\">this</span>.foo == foo, <span class=\"comment\">// true</span></div><div class=\"line\">  <span class=\"built_in\">window</span>.bar == bar <span class=\"comment\">// true</span></div><div class=\"line\">);  </div><div class=\"line\"><span class=\"built_in\">console</span>.log(baz); <span class=\"comment\">// Uncaught ReferenceError: baz is not defined</span></div></pre></td></tr></table></figure>\n<p>该例中全局上下文中变量对象会有以下属性：    </p>\n<table>\n<thead>\n<tr>\n<th>global VO</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>foo</td>\n<td>undefined –&gt; 10</td>\n</tr>\n<tr>\n<td>bar</td>\n<td>function…</td>\n</tr>\n<tr>\n<td>built-ins（忽略）</td>\n<td>一些内置的全局变量</td>\n</tr>\n</tbody>\n</table>\n<p>这是全局上下文中的变量对象，除了全局上下文还有函数上下文，那么函数上下文是否是一样的呢？答案是稍微有点不一样：函数内活动对象（AO）用作变量对象。接下来我们看下AO。<br></p>\n<blockquote>\n<p>在global全局上下文中，变量对象也是全局对象自身[global object],如浏览器中是window,此时我们可以通过全局对象的属性来指向全局变量,通过this来访问全局对象。然而在函数上下文内我们是无法直接访问这个对象的,this也不指向这个对象。<br></p>\n</blockquote>\n<h4 id=\"函数的活动对象（AO）\"><a href=\"#函数的活动对象（AO）\" class=\"headerlink\" title=\"函数的活动对象（AO）\"></a>函数的活动对象（AO）</h4><p>当函数被调用者激活（即函数调用），活动对象 就被创建了。它包含普通参数即形参(formal parameters) 与特殊参数(arguments)对象(具有索引属性的参数映射表)。活动对象在函数上下文中作为变量对象使用。</p>\n<p>   还是举个栗子看下函数的活动对象:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">x, y</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(z); <span class=\"comment\">//undefined</span></div><div class=\"line\">  <span class=\"keyword\">var</span> z = <span class=\"number\">3</span>;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(z);<span class=\"comment\">//3</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;&#125; <span class=\"comment\">// 函数声明</span></div><div class=\"line\">  (<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">baz</span>(<span class=\"params\"></span>) </span>&#123;&#125;); <span class=\"comment\">// 函数表达式</span></div><div class=\"line\">&#125;</div><div class=\"line\">foo(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</div></pre></td></tr></table></figure></p>\n<p>   上面当foo被调用时，foo函数上下文的活动对象(AO)被创建，其内容如下表格：</p>\n<table>\n<thead>\n<tr>\n<th>Activation object</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>x</td>\n<td>1</td>\n</tr>\n<tr>\n<td>y</td>\n<td>2</td>\n</tr>\n<tr>\n<td>arguments</td>\n<td>{ {0:{x:1}, {1:{y:1}} }</td>\n</tr>\n<tr>\n<td>z</td>\n<td>undefined–&gt;3</td>\n</tr>\n<tr>\n<td>bar</td>\n<td>funciton</td>\n</tr>\n</tbody>\n</table>\n<p>前面我们已经知道变量对象中不包含函数表达式，这里活动对象内也不包括函数表达式。</p>\n<p>我们已经知道了VO和AO的内容组成了，那么他们是什么时候被创建的，又是什么时候改变的呢？<br></p>\n<blockquote>\n<p>VO|AO在每次创建上下文时作为上下文的组成部分被创建，并填入初始值;值的更新出现在代码执行阶段。<br></p>\n</blockquote>\n<p>上面两个例子中我们知道了，全局上下文中，我们定义的变量和声明的函数都作为全局上下文的变量对象的属性来保存，代码执行时标志符的查找也是从全局上下文的变量对象中查找。在某一个函数上下文中也类似，在当前上下文中的标志符会先在当前变量对象（函数上下文中是活动对象）中查找。但是当在当前上下文的变量对象找不到的时候会发生什么呢？答案是：完整的标志符解析是通过作用域链（scope chain）机制来完成的。（不容易啊，终于比较自然的把作用域链给引出来了）。那么我们来看一下什么是作用域链。</p>\n<h4 id=\"作用域链（scope-chain）\"><a href=\"#作用域链（scope-chain）\" class=\"headerlink\" title=\"作用域链（scope chain）\"></a>作用域链（scope chain）</h4><p>作用域链是一个 对象列表(list of objects) ，用以检索上下文代码中出现的 标识符(identifiers) 。先说结果：</p>\n<blockquote>\n<p>scope chain = VO|AO + [[scope]] </p>\n</blockquote>\n<p>依然看个栗子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123; </div><div class=\"line\">  <span class=\"keyword\">var</span> y = <span class=\"number\">2</span>; </div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(x + y);</div><div class=\"line\">  &#125; </div><div class=\"line\">  <span class=\"keyword\">return</span> bar; </div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\">foo()(); <span class=\"comment\">// 3</span></div></pre></td></tr></table></figure></p>\n<p>这段代码执行完，共创建了三个执行上下文：执行流进入这段全局代码会创建一个全局上下文，foo调用时创建foo上下文，bar被调用时创建bar上下文(foo()–&gt;bar调用)。<br>这里我们暂且只看一下bar的上下文，我们已经知道一个上下文的数据域即一个上下文的变量对象,在函数上下文即是活动对象（AO），那我们就看下bar函数的活动对象。<br><br>当执行流进入bar函数，且函数体内代码执行之前，javascript引擎会创建这个函数的AO：</p>\n<table>\n<thead>\n<tr>\n<th>AO</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>arguments</td>\n<td>[callee: function, Symbol(Symbol.iterator): function]</td>\n</tr>\n</tbody>\n</table>\n<p>我们看到bar函数提内代码执行之前创建的这个AO并没有函数体中需要用到的变量x和y,那么当代码执行到console.log(x + y)时，x和y是从哪里读取的呢？不难看出：y存在创建的foo函数上下文的活动对象中；x存在创建的全局上下文的变量对象中。好像是函数内可以访问到函数祖父级上下文的变量对象里的东西。实际上也是这样的。而能访问到祖父上下文的变量对象，正是通过函数的一个内部属性–[[scope]]实现的。</p>\n<h5 id=\"scope\"><a href=\"#scope\" class=\"headerlink\" title=\"[[scope]]\"></a>[[scope]]</h5><p>[[scope]]是ECMA262规定的对象的私有属性，理论上只有JS引擎可以访问。</p>\n<ul>\n<li>[[scope]]是所有祖父变量对象的层级链。</li>\n<li>[[scope]]在函数创建时被存储－－静态（不变的），直至函数销毁。</li>\n</ul>\n<p>拓展阅读<a href=\"http://www.cnblogs.com/TomXu/archive/2012/01/18/2312463.html\" target=\"_blank\" rel=\"external\">例子</a>。</p>\n<p>所以一个函数内代码执行时，函数内遇到的标志符就是这样先从当前上下文的活动对象内查找，若找不着继续查找父上下文的变量对象，直到查到全局上下文。而这也正是javascript中的<code>变量标志符查找机制</code>。</p>\n<h5 id=\"标志符解析机制\"><a href=\"#标志符解析机制\" class=\"headerlink\" title=\"标志符解析机制\"></a>标志符解析机制</h5><p>我们直接看规范（ES3 10.1.4章节）：</p>\n<p>每个执行上下文都有一个与之相关联的作用域链（scope chain）。作用域链是一个由对象组成的链表，求值标志符的时候会对它搜索。当创建一个上下文时，根据当前上下文的代码类型（全局代码或函数代码）一个作用域链被创建，并用初始化对象填充（函数代码被填充为函数的[[scope]]属性值-接下来讲；全局代码初始化为空吧。当VO|AO被创建后，VO|AO被推到作用域链的前端）。一个上下文中代码执行时，其作用域链只会被 with 声明（见 12.10）和 catch 语句（见 12.14）所影响。标志符解析的具体规则：</p>\n<ol>\n<li>获取作用域链中的下一个对象。如果没有，转到步骤 5。</li>\n<li>调用结果(1) 的 [[HasProperty]] 方法，把标识符（Identifier）作为属性名传递。</li>\n<li>如果结果(2) 为true，返回一个引用类型的值，其基对象（base objecqit）是结果(1),其property name是该Identifier。<br>符。</li>\n<li>转到步骤 1。</li>\n<li>返回一个引用类型的值，其base object为 null，其property name 是Identifier。<br>求值标识符的结果总是一个引用类型的值，其成员名字组件与标识符字符串相等。</li>\n</ol>\n<blockquote>\n<p>注：Reference(引用)类型的值是JS引擎使用的一种数据类型，它分为base object和property  name两个部分。假设在JS代码中有obj.prop这样的表达式，那么解释成Reference类型，base object是对象obj,而property name是字符串”prop”。–winter</p>\n</blockquote>\n<h4 id=\"this\"><a href=\"#this\" class=\"headerlink\" title=\"this\"></a>this</h4><p>至此上下文里还有this没说，我的总结是：this通常指向激活当前上下文的那个对象。this值在进入上下文时确定，并且在上下文运行期间不能被改变。<br><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);<span class=\"comment\">// global object</span></div><div class=\"line\"><span class=\"keyword\">var</span>  obj = &#123; <span class=\"attr\">a</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; </div><div class=\"line\">                    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>)</div><div class=\"line\">                &#125;</div><div class=\"line\">              &#125;; </div><div class=\"line\"> obj.a();<span class=\"comment\">//obj 可以理解为：obj.a的上下文是被obj这个对象激活的。</span></div></pre></td></tr></table></figure></p>\n<p>当然this绑定还有一些其他规则。详见另一篇博文<a href=\"https://foreverwang.github.io/2017/03/27/Javascript%E8%AF%AD%E8%A8%80%E4%B9%8B%E8%9C%9C%E6%B1%81this/\">javascript之蜜汁this</a>。</p>\n<h4 id=\"总结一下上下文：\"><a href=\"#总结一下上下文：\" class=\"headerlink\" title=\"总结一下上下文：\"></a>总结一下上下文：<br></h4><p>上下文分为全局上下文和函数上下文。<br><br>全局上下文没啥好总结的，我们就看在函数上下文的整个生命周期。</p>\n<p>执行流进入一个函数时，引擎不是简单的立即执行函数体内的代码，可分为两个阶段：</p>\n<ul>\n<li><p>第一阶段：上下文创建阶段</p>\n<ul>\n<li>一个函数上下文被创建，同时作为上下文的一部分的作用域链也被创建，并被初始化为函数[[scope]]属性的值。</li>\n<li>接着javascript引擎创建当前上下文的活动对象（AO）,并且将AO推入作用域链的最前端。</li>\n<li>确定this的值。</li>\n</ul>\n</li>\n<li><p>第二阶段：代码逐行执行–变量赋值、函数引用等    。</p>\n</li>\n</ul>\n<h4 id=\"上下文栈（EC）\"><a href=\"#上下文栈（EC）\" class=\"headerlink\" title=\"上下文栈（EC）\"></a>上下文栈（EC）</h4><p>以上部分我们对单个上下文的创建和组成做了详细的说明。而一段代码的执行往往是涉及到很多个上下文。而在代码执行过程中这些上下文之间是什么关系呢？ <br><br>活动的上下文在逻辑上组成一个上下文栈。栈底是全局上下文，而栈顶是当前激活的上下文。<br><br>当js引擎执行全局代码前，会首先创建一个全局上下文。全局上下文创建完毕后，全局代码开始逐行被执行。代码执行过程中当一个函数被调用时，此时引擎会创建一个函数上下文，并且将其<code>推入</code>到上下文栈顶。引擎总是执行当前在栈顶的上下文的代码，函数执行完毕，上下文栈将该函数上下文<code>弹出</code>，控制权返回给之前的上下文。ECMAScript程序中的执行流正式被这个机制控制者。</p>\n<h5 id=\"相关推荐：\"><a href=\"#相关推荐：\" class=\"headerlink\" title=\"相关推荐：\"></a>相关推荐：</h5><ul>\n<li><a href=\"http://www.cnblogs.com/TomXu/archive/2012/01/12/2308594.html\" target=\"_blank\" rel=\"external\">大叔的深入理解JavaScript系列（10）：JavaScript核心</a></li>\n<li><a href=\"http://davidshariff.com/blog/what-is-the-execution-context-in-javascript/\" target=\"_blank\" rel=\"external\">What is the Execution Context &amp; Stack in JavaScript?</a> <a href=\"http://yanhaijing.com/javascript/2014/04/29/what-is-the-execution-context-in-javascript/\" target=\"_blank\" rel=\"external\">(译文)</a></li>\n<li><a href=\"http://www.cnblogs.com/winter-cn/archive/2008/07/07/1237168.html\" target=\"_blank\" rel=\"external\"> winter的JavaScript中的[[scope]]和Scope Chain</a></li>\n</ul>\n<h5 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h5><p>本文主要参考了<a href=\"http://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%203rd%20edition,%20December%201999.pdf\" target=\"_blank\" rel=\"external\">ES3规范的第10章节Execution Contexts</a>。行文上部分参考上面两篇博文。写的过程中，发现把这个主题涉及的内容很连贯的串起来还是不容易的。而网上的关于该主题的博文也没有（我没找到）很好的把这些内容连贯的串起来的。所以整理此文。不管怎样，至少自己梳理来了一边，更清晰了。<br>执行上下文大概就这些东西了吧。这大概也是整个javascript这门语言最核心且没有之一的东西了。</p>\n","excerpt":"<h3 id=\"关键词\"><a href=\"#关键词\" class=\"headerlink\" title=\"关键词\"></a>关键词</h3><ul>\n<li>执行期上下文（excution context简称EC）：简称上下文（又叫执行环境）</li>\n<li>作用域链 （scope chain）</li>\n<li>变量对象（variable object简称VO）</li>\n<li>活动对象（activation object简称AO）</li>\n</ul>\n<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>执行上下文是Javascript中最重要的一个概念。每一段代码的执行都与它息息相关。理解了它，才能真正理解我们写的的javascript代码是如何运行的。<br>ECMA-262（5.1）中写道：当控制器转入 ECMAScript的可执行代码时，控制器会进入(注：创建)一个执行上下文。<br>","more":"</p>\n<h4 id=\"可执行代码\"><a href=\"#可执行代码\" class=\"headerlink\" title=\"可执行代码\"></a>可执行代码</h4><p>这里先解释下上面提到的可执行代码，我们看一下ES5规范（以下从简了）</p>\n<ul>\n<li>全局代码：是指被作为ECMAScript程序处理的源代码文本。一个特定程序的全局代码不包括作为函数体被解析的源代码文本。</li>\n<li>函数代码：是指作为函数体被解析的源代码文本。不包括作为其嵌套函数的 函数体 被解析的源代码文本。</li>\n<li>Eval 代码 是指提供给eval内置函数的源代码文本。（现在应用比较少，这一点本文忽略）</li>\n</ul>\n<p>现在可以对上面关于上下文的说法换一种说法：<br></p>\n<ul>\n<li>当控制器转入 ECMAScript的全局代码，控制器会创建一个全局上下文。</li>\n<li>当转入函数代码，控制器会创建一个函数上下文。</li>\n</ul>\n<h3 id=\"执行上下文\"><a href=\"#执行上下文\" class=\"headerlink\" title=\"执行上下文\"></a>执行上下文</h3><p>我们已经知道了什么时候会创建一个上下文，那接下来就要说下上下文具体是个什么东西。<br><br>ES5规范里说：执行上下文包含所有用于追踪与其相关的代码的执行进度的状态。<br><br>翻译一下是说：执行上下文里有代码执行时需要用到的东西。<br><br>现在问题就具体到了：执行上下文里都有什么？那么我们来看一下：</p>\n<h4 id=\"执行上下文的组成\"><a href=\"#执行上下文的组成\" class=\"headerlink\" title=\"执行上下文的组成\"></a>执行上下文的组成</h4><table>\n<thead>\n<tr>\n<th>组件</th>\n<th>内部组成</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>变量对象（VO）</td>\n<td>{vars:…,function declarations:…,arguments:…,…}</td>\n<td>指定一个词法环境对象，其环境数据用于保存由该执行上下文内的变量声明 和 函数声明。</td>\n</tr>\n<tr>\n<td>作用域链（scope chain）</td>\n<td>[ variable object + [[scope]]）</td>\n<td>指定一个词法环境对象，用于解析该执行环境内的代码创建的标识符引用。</td>\n</tr>\n<tr>\n<td>this指针</td>\n<td></td>\n<td>指定该执行上下文内的 ECMAScript代码中this关键字所关联的值。</td>\n</tr>\n</tbody>\n</table>\n<p>为了方便理解，一个执行上下文可以抽象为object。每一个执行上下文都有一系列的属性（我们称为上下文状态，即上面表格做左侧组件一列的属性）。接下来就对上面表格中的三个状态属性来一一说明。</p>\n<h4 id=\"变量对象-（VO）\"><a href=\"#变量对象-（VO）\" class=\"headerlink\" title=\"变量对象  （VO）\"></a>变量对象  （VO）</h4><p>变量对象是与执行上下文相关的数据作用域(scope of data) ,用于存储被定义在上下文中的变量声明和函数声明(注意：不包括函数表达式<a href=\"http://www.cnblogs.com/TomXu/archive/2011/12/29/2290308.html\">详见</a>) 。<br><br>定义已经很明确了，我们通过具体的栗子看下全局上下文的VO：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"number\">2</span>;        </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;&#125; <span class=\"comment\">// 函数声明</span></div><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">baz</span>(<span class=\"params\"></span>) </span>&#123;&#125;); <span class=\"comment\">// 函数表达式   </span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(</div><div class=\"line\">  <span class=\"keyword\">this</span>.foo == foo, <span class=\"comment\">// true</span></div><div class=\"line\">  <span class=\"built_in\">window</span>.bar == bar <span class=\"comment\">// true</span></div><div class=\"line\">);  </div><div class=\"line\"><span class=\"built_in\">console</span>.log(baz); <span class=\"comment\">// Uncaught ReferenceError: baz is not defined</span></div></pre></td></tr></table></figure>\n<p>该例中全局上下文中变量对象会有以下属性：    </p>\n<table>\n<thead>\n<tr>\n<th>global VO</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>foo</td>\n<td>undefined –&gt; 10</td>\n</tr>\n<tr>\n<td>bar</td>\n<td>function…</td>\n</tr>\n<tr>\n<td>built-ins（忽略）</td>\n<td>一些内置的全局变量</td>\n</tr>\n</tbody>\n</table>\n<p>这是全局上下文中的变量对象，除了全局上下文还有函数上下文，那么函数上下文是否是一样的呢？答案是稍微有点不一样：函数内活动对象（AO）用作变量对象。接下来我们看下AO。<br></p>\n<blockquote>\n<p>在global全局上下文中，变量对象也是全局对象自身[global object],如浏览器中是window,此时我们可以通过全局对象的属性来指向全局变量,通过this来访问全局对象。然而在函数上下文内我们是无法直接访问这个对象的,this也不指向这个对象。<br></p>\n</blockquote>\n<h4 id=\"函数的活动对象（AO）\"><a href=\"#函数的活动对象（AO）\" class=\"headerlink\" title=\"函数的活动对象（AO）\"></a>函数的活动对象（AO）</h4><p>当函数被调用者激活（即函数调用），活动对象 就被创建了。它包含普通参数即形参(formal parameters) 与特殊参数(arguments)对象(具有索引属性的参数映射表)。活动对象在函数上下文中作为变量对象使用。</p>\n<p>   还是举个栗子看下函数的活动对象:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">x, y</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(z); <span class=\"comment\">//undefined</span></div><div class=\"line\">  <span class=\"keyword\">var</span> z = <span class=\"number\">3</span>;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(z);<span class=\"comment\">//3</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;&#125; <span class=\"comment\">// 函数声明</span></div><div class=\"line\">  (<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">baz</span>(<span class=\"params\"></span>) </span>&#123;&#125;); <span class=\"comment\">// 函数表达式</span></div><div class=\"line\">&#125;</div><div class=\"line\">foo(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</div></pre></td></tr></table></figure></p>\n<p>   上面当foo被调用时，foo函数上下文的活动对象(AO)被创建，其内容如下表格：</p>\n<table>\n<thead>\n<tr>\n<th>Activation object</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>x</td>\n<td>1</td>\n</tr>\n<tr>\n<td>y</td>\n<td>2</td>\n</tr>\n<tr>\n<td>arguments</td>\n<td>{ {0:{x:1}, {1:{y:1}} }</td>\n</tr>\n<tr>\n<td>z</td>\n<td>undefined–&gt;3</td>\n</tr>\n<tr>\n<td>bar</td>\n<td>funciton</td>\n</tr>\n</tbody>\n</table>\n<p>前面我们已经知道变量对象中不包含函数表达式，这里活动对象内也不包括函数表达式。</p>\n<p>我们已经知道了VO和AO的内容组成了，那么他们是什么时候被创建的，又是什么时候改变的呢？<br></p>\n<blockquote>\n<p>VO|AO在每次创建上下文时作为上下文的组成部分被创建，并填入初始值;值的更新出现在代码执行阶段。<br></p>\n</blockquote>\n<p>上面两个例子中我们知道了，全局上下文中，我们定义的变量和声明的函数都作为全局上下文的变量对象的属性来保存，代码执行时标志符的查找也是从全局上下文的变量对象中查找。在某一个函数上下文中也类似，在当前上下文中的标志符会先在当前变量对象（函数上下文中是活动对象）中查找。但是当在当前上下文的变量对象找不到的时候会发生什么呢？答案是：完整的标志符解析是通过作用域链（scope chain）机制来完成的。（不容易啊，终于比较自然的把作用域链给引出来了）。那么我们来看一下什么是作用域链。</p>\n<h4 id=\"作用域链（scope-chain）\"><a href=\"#作用域链（scope-chain）\" class=\"headerlink\" title=\"作用域链（scope chain）\"></a>作用域链（scope chain）</h4><p>作用域链是一个 对象列表(list of objects) ，用以检索上下文代码中出现的 标识符(identifiers) 。先说结果：</p>\n<blockquote>\n<p>scope chain = VO|AO + [[scope]] </p>\n</blockquote>\n<p>依然看个栗子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123; </div><div class=\"line\">  <span class=\"keyword\">var</span> y = <span class=\"number\">2</span>; </div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(x + y);</div><div class=\"line\">  &#125; </div><div class=\"line\">  <span class=\"keyword\">return</span> bar; </div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\">foo()(); <span class=\"comment\">// 3</span></div></pre></td></tr></table></figure></p>\n<p>这段代码执行完，共创建了三个执行上下文：执行流进入这段全局代码会创建一个全局上下文，foo调用时创建foo上下文，bar被调用时创建bar上下文(foo()–&gt;bar调用)。<br>这里我们暂且只看一下bar的上下文，我们已经知道一个上下文的数据域即一个上下文的变量对象,在函数上下文即是活动对象（AO），那我们就看下bar函数的活动对象。<br><br>当执行流进入bar函数，且函数体内代码执行之前，javascript引擎会创建这个函数的AO：</p>\n<table>\n<thead>\n<tr>\n<th>AO</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>arguments</td>\n<td>[callee: function, Symbol(Symbol.iterator): function]</td>\n</tr>\n</tbody>\n</table>\n<p>我们看到bar函数提内代码执行之前创建的这个AO并没有函数体中需要用到的变量x和y,那么当代码执行到console.log(x + y)时，x和y是从哪里读取的呢？不难看出：y存在创建的foo函数上下文的活动对象中；x存在创建的全局上下文的变量对象中。好像是函数内可以访问到函数祖父级上下文的变量对象里的东西。实际上也是这样的。而能访问到祖父上下文的变量对象，正是通过函数的一个内部属性–[[scope]]实现的。</p>\n<h5 id=\"scope\"><a href=\"#scope\" class=\"headerlink\" title=\"[[scope]]\"></a>[[scope]]</h5><p>[[scope]]是ECMA262规定的对象的私有属性，理论上只有JS引擎可以访问。</p>\n<ul>\n<li>[[scope]]是所有祖父变量对象的层级链。</li>\n<li>[[scope]]在函数创建时被存储－－静态（不变的），直至函数销毁。</li>\n</ul>\n<p>拓展阅读<a href=\"http://www.cnblogs.com/TomXu/archive/2012/01/18/2312463.html\">例子</a>。</p>\n<p>所以一个函数内代码执行时，函数内遇到的标志符就是这样先从当前上下文的活动对象内查找，若找不着继续查找父上下文的变量对象，直到查到全局上下文。而这也正是javascript中的<code>变量标志符查找机制</code>。</p>\n<h5 id=\"标志符解析机制\"><a href=\"#标志符解析机制\" class=\"headerlink\" title=\"标志符解析机制\"></a>标志符解析机制</h5><p>我们直接看规范（ES3 10.1.4章节）：</p>\n<p>每个执行上下文都有一个与之相关联的作用域链（scope chain）。作用域链是一个由对象组成的链表，求值标志符的时候会对它搜索。当创建一个上下文时，根据当前上下文的代码类型（全局代码或函数代码）一个作用域链被创建，并用初始化对象填充（函数代码被填充为函数的[[scope]]属性值-接下来讲；全局代码初始化为空吧。当VO|AO被创建后，VO|AO被推到作用域链的前端）。一个上下文中代码执行时，其作用域链只会被 with 声明（见 12.10）和 catch 语句（见 12.14）所影响。标志符解析的具体规则：</p>\n<ol>\n<li>获取作用域链中的下一个对象。如果没有，转到步骤 5。</li>\n<li>调用结果(1) 的 [[HasProperty]] 方法，把标识符（Identifier）作为属性名传递。</li>\n<li>如果结果(2) 为true，返回一个引用类型的值，其基对象（base objecqit）是结果(1),其property name是该Identifier。<br>符。</li>\n<li>转到步骤 1。</li>\n<li>返回一个引用类型的值，其base object为 null，其property name 是Identifier。<br>求值标识符的结果总是一个引用类型的值，其成员名字组件与标识符字符串相等。</li>\n</ol>\n<blockquote>\n<p>注：Reference(引用)类型的值是JS引擎使用的一种数据类型，它分为base object和property  name两个部分。假设在JS代码中有obj.prop这样的表达式，那么解释成Reference类型，base object是对象obj,而property name是字符串”prop”。–winter</p>\n</blockquote>\n<h4 id=\"this\"><a href=\"#this\" class=\"headerlink\" title=\"this\"></a>this</h4><p>至此上下文里还有this没说，我的总结是：this通常指向激活当前上下文的那个对象。this值在进入上下文时确定，并且在上下文运行期间不能被改变。<br><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);<span class=\"comment\">// global object</span></div><div class=\"line\"><span class=\"keyword\">var</span>  obj = &#123; <span class=\"attr\">a</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; </div><div class=\"line\">                    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>)</div><div class=\"line\">                &#125;</div><div class=\"line\">              &#125;; </div><div class=\"line\"> obj.a();<span class=\"comment\">//obj 可以理解为：obj.a的上下文是被obj这个对象激活的。</span></div></pre></td></tr></table></figure></p>\n<p>当然this绑定还有一些其他规则。详见另一篇博文<a href=\"https://foreverwang.github.io/2017/03/27/Javascript%E8%AF%AD%E8%A8%80%E4%B9%8B%E8%9C%9C%E6%B1%81this/\">javascript之蜜汁this</a>。</p>\n<h4 id=\"总结一下上下文：\"><a href=\"#总结一下上下文：\" class=\"headerlink\" title=\"总结一下上下文：\"></a>总结一下上下文：<br></h4><p>上下文分为全局上下文和函数上下文。<br><br>全局上下文没啥好总结的，我们就看在函数上下文的整个生命周期。</p>\n<p>执行流进入一个函数时，引擎不是简单的立即执行函数体内的代码，可分为两个阶段：</p>\n<ul>\n<li><p>第一阶段：上下文创建阶段</p>\n<ul>\n<li>一个函数上下文被创建，同时作为上下文的一部分的作用域链也被创建，并被初始化为函数[[scope]]属性的值。</li>\n<li>接着javascript引擎创建当前上下文的活动对象（AO）,并且将AO推入作用域链的最前端。</li>\n<li>确定this的值。</li>\n</ul>\n</li>\n<li><p>第二阶段：代码逐行执行–变量赋值、函数引用等    。</p>\n</li>\n</ul>\n<h4 id=\"上下文栈（EC）\"><a href=\"#上下文栈（EC）\" class=\"headerlink\" title=\"上下文栈（EC）\"></a>上下文栈（EC）</h4><p>以上部分我们对单个上下文的创建和组成做了详细的说明。而一段代码的执行往往是涉及到很多个上下文。而在代码执行过程中这些上下文之间是什么关系呢？ <br><br>活动的上下文在逻辑上组成一个上下文栈。栈底是全局上下文，而栈顶是当前激活的上下文。<br><br>当js引擎执行全局代码前，会首先创建一个全局上下文。全局上下文创建完毕后，全局代码开始逐行被执行。代码执行过程中当一个函数被调用时，此时引擎会创建一个函数上下文，并且将其<code>推入</code>到上下文栈顶。引擎总是执行当前在栈顶的上下文的代码，函数执行完毕，上下文栈将该函数上下文<code>弹出</code>，控制权返回给之前的上下文。ECMAScript程序中的执行流正式被这个机制控制者。</p>\n<h5 id=\"相关推荐：\"><a href=\"#相关推荐：\" class=\"headerlink\" title=\"相关推荐：\"></a>相关推荐：</h5><ul>\n<li><a href=\"http://www.cnblogs.com/TomXu/archive/2012/01/12/2308594.html\">大叔的深入理解JavaScript系列（10）：JavaScript核心</a></li>\n<li><a href=\"http://davidshariff.com/blog/what-is-the-execution-context-in-javascript/\">What is the Execution Context &amp; Stack in JavaScript?</a> <a href=\"http://yanhaijing.com/javascript/2014/04/29/what-is-the-execution-context-in-javascript/\">(译文)</a></li>\n<li><a href=\"http://www.cnblogs.com/winter-cn/archive/2008/07/07/1237168.html\"> winter的JavaScript中的[[scope]]和Scope Chain</a></li>\n</ul>\n<h5 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h5><p>本文主要参考了<a href=\"http://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%203rd%20edition,%20December%201999.pdf\">ES3规范的第10章节Execution Contexts</a>。行文上部分参考上面两篇博文。写的过程中，发现把这个主题涉及的内容很连贯的串起来还是不容易的。而网上的关于该主题的博文也没有（我没找到）很好的把这些内容连贯的串起来的。所以整理此文。不管怎样，至少自己梳理来了一边，更清晰了。<br>执行上下文大概就这些东西了吧。这大概也是整个javascript这门语言最核心且没有之一的东西了。</p>"},{"title":"Javascript语言之蜜汁this","date":"2017-03-26T17:51:38.000Z","_content":"\nthis关键字是Javascript中最重要的机制之一。关于介绍他的文章也比比皆是，而大多都浅尝辄止，浮于表面。故整理此篇。\n### 先看几个题目\n题目1 //默认绑定  严格模式 非严格模式\n\n``` javascript\n    function foo(){\n      console.log(this.a);\n    }\n    var a = '2';\n    (function(){\n      'use strict';\n      foo(); \n    })()\n```\n<!-- more -->\n        \n\n题目2 //隐式绑定\n``` javascript\n    function foo(){\n        console.log(this.a);\n    }\n    var a = 1;\n    var obj2 = {\n        a: 2,\n        foo:foo\n    }\n    var obj1 = {\n        a: 1,\n        obj2: obj2\n    }\n    \n    obj1.obj2.foo() \n```\n题目3 \n   \n``` javascript\n    function foo(){\n        console.log(this.a);\n    }\n    \n    var a = 2;\n    var o = {a:3,foo:foo};\n    var p = {a:4};\n    \n    (p.foo = o.foo)() \n    \n    //知识点：赋值表达式的返回值\n```\n题目4 \n``` javascript\n    var obj1 = {\n        a: 1,\n        foo: function(){\n          console.log(this.a);\n        }\n    };\n    var obj2 = { a: 2 };\n    var obj3 = { a: 3};\n    obj1.foo.bind(obj2).call(obj3) \n```\n    //知识点： bind实现\n  \n  上面4个题目的答案都是：2 。<br/>\n  如果你都答对了，那可以继续往下看了,以下是正文。本文先说为什么要用this，再说怎么用this。\n    \n### 为什么要用this?\n\n\n先看以下这段简单的代码\n``` javascript\n    function speak() {\n        var greeting = \"Hello, I'm \" + this.name;\n        console.log( greeting );\n    }\n    \n    var me = {\n        name: \"小a\"\n    };\n    \n    var you = {\n        name: \"小b\"\n    };\n    \n    speak.call( me ); // Hello, I'm 小a\n    speak.call( you ); // Hello, I'm 小b\n```\n* 以上代码可以在不同上下文对象（me 和 you）中重复使用speak函数。\n* 如果不使用this,就要给 speak显示传入一个上下文对象（如下）\n        \n``` javascript\n        function speak(content) {\n            var greeting = \"Hello, I'm \" + content.name;\n            console.log( greeting );\n        }\n      \n        speak(me);  // Hello, I'm 小a\n        speak(you); // Hello, I'm 小b\n```\n显然，this提供了一种更优雅的方式来隐式传递一个对象的引用，因此可以使API设计得更加简洁且易于复用。   \n随着使用的模式越来越复杂，显示传递上下文对象会让代码变得越来越混乱，使用this则不会这样。\n           \n### this是什么？\n\n说起this,这要看执行上下文是什么。javascript中根据可执行的种类分全局执行上下文和函数执行上下文（ES6有了块级上下文）。（关于执行上下文见另一篇[博文](https://foreverwang.github.io/2017/04/09/Javascript%E4%B9%8B%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/)）\n在全局执行上下文中（在任何函数体外部）很简单，this指代全局对象，无论是否在严格模式下。以下说的都是在函数上下文中的this。\n#### this常见误区\n* this 不指向函数自身（就没必要附加例子了）\n* this 任何情况下也不指向函数的词法作用域        \n``` javascript\n        function foo(){\n            var a = 2;\n            this.bar();\n        }\n        function bar(){\n            console.log(this.a);\n        }\n        \n        foo()//undefined\n```\n    这段代码试图通过this联通 foo和bar的词法作用域，从而让bar可以访问foo作用域里的变量a,当然这里是不能如愿的。不能使用this来引用一个词法作用域内部的东西。\n\n \n\n\n\n#### this到底是啥\n this 是在运行时进行绑定的，并不是在编写时绑定，他的上下文取决于函数调用时的各种条件。<br/> （this的值只和函数调用有关，和函数定义无关---这个说法是不对的，有两个例外：bind 和箭头函数，后面说）\n 当一个函数被调用的时候，进入这个函数的执行上下文。执行上下文里包含：函数的活动对象（函数传入的参数等）；作用域链 （函数调用栈等）；this就是上下文的其中一个属性，会在函数执行过程中用到。\n\n### this绑定规则（4个）\n先找确定函数的调用位置，调用栈\n#### 1.默认绑定\n先说结论：\n\n* 什么是默认绑定： 非严格模式下，this指向全局对象；严格模式下，this为undefined\n* 何时会走默认绑定：独立函数调用\n\n函数在不带任何修饰的进行调用（即独立函数调用）的时候，this会走默认绑定规则。\n<br>非严格模式下：this指向全局对象\n``` javascript\n        function foo(){\n            console.log(this.a);\n        }\n        var a = 2;\n        foo();//2 \n```\n严格模式下：this为undefined\n``` javascript\n     function foo(){\n         'use strict';\n          console.log(this.a);\n     }\n     var a = 2;\n     foo()//Cannot read property 'a' of undefined\n```\n这里要注意一点， 对于默认绑定，决定this绑定对象的不是调用位置是否处于严格模式，而是函数体是否处于严格模式，这也是题目1中 看似是在严格模式下，this却绑定到了全局对象\n``` javascript\n    function foo(){\n      //foo函数体处于非严格模式\n      console.log(this.a);\n    }\n    var a = '2';\n    (function(){\n      'use strict';\n      //该立即执行的函数表达式内处于严格模式这里的this为undefined\n      console.log(this);//undefined\n      foo(); //2\n    })()  \n```\n#### 2.隐式绑定\n先说结论:<br>\n当函数被调用时，函数引用有上下文对象，隐式绑定规则会把函数调用中的this绑定到这个上下文对象\n再看题目2<br>\n``` javascript\n    function foo(){\n        console.log(this.a);\n    }\n    var a = 1;\n    var obj2 = {\n        a: 2,\n        foo:foo\n    }\n    var obj1 = {\n        a: 1,\n        obj2: obj2\n    }\n    \n    obj1.obj2.foo() //2\n    //对象属性引用链中只有最顶层(属性的直接调用方)会影响调用位置\n```\n<br>\n   隐式丢失（严格来说此处并没有绑定过，也没有丢失一说，只是看上去像是丢失了）\n``` javascript\n    function foo(){\n        console.log(this.a);\n    }\n    var obj = {\n        a: 1,\n       foo: foo\n    }\n  \n    var bar = obj.foo;//函数别名\n    var a = 2;\n    bar();\n```\n  虽然bar是obj.foo的一个引用，实际上，他引用的是foo本身，此时的bar调用 就是一个不带任何修饰的函数调用，因此应用了默认绑定。<br>\n 其实本例有两个关键点：\n \n  * 赋值表达式的返回值（犀牛书6版81页）： var bar = obj.foo;返回的是右值，右值指向foo的引用\n  * 不管如何引用，只看调用时 调用是bar() ---> foo()\n\n此时再看题目3，就很清晰了\n``` javascript\n    function foo(){\n        console.log(this.a);\n    }\n    \n    var a = 2;\n    var o = {a:3,foo:foo};\n    var p = {a:4};\n    \n    //o.foo();//3\n    (p.foo = o.foo)() //p.foo = o.foo的返回值是等号的右值-->foo的引用，此处相当于直接调用foo()\n    //p.foo()//4\n```\n\n#### 3.显示绑定 \n\n先说结论：\n\n* 函数调用时通过 apply 或者 call 硬绑定this 对象(apply和call的区别这里就不赘述了)\n* 通过ES5的 Function.prototype.bind 返回一个绑定了this了的新函数\n\n看一个硬绑定的典型应用场景:接受不确定参数\n``` javascript\n    function foo(sth){\n        console.log( this.a,sth );\n        return this.a + sth;\n    }\n    var obj = {\n        a: 1\n    }\n\n    var bar = function(){\n        return foo.apply(obj,arguments);\n    }\n    \n    var b = bar(1);\n    console.log(b);//  2  \n```\n另一种方法是创建一个可复用的辅助函数（bind）\n``` javascript\n    function foo(sth){\n        console.log( this.a,sth );\n        return this.a + sth;\n    }\n    \n    //简单的辅助绑定函数\n    function bind(fn,obj){\n        return function(){\n            return fn.apply(obj,arguments);\n        }\n    }\n    \n     var obj = {\n        a: 1\n    }\n    \n    var bar = bind(foo,obj);\n    var b = bar(1);\n    console.log(b);//2\n```\n\n   由于硬绑定是一种很常用的模式，ES5提供了内置的Function.prototype.bind方法：<br>\n   `bind方法`(犀牛书第6版190页)将返回一个新的函数，以函数调用的方式调用新的函数将会把原始函数当做bind的第一个参数的方法来调用，传入新函数的任何实参都将传入原始函数。根据定义，用ES3很容易模拟bind方法，即上面代码中我们自定义的bind函数（这里只是把最基本的绑定this模拟了，参数柯里化等没有模拟，可以看MDN bind的polyfill写法，这里不贴了）。\n  <br>\n此时，再看题目4应该就很清晰了：\n``` javascript\n    var obj1 = {\n        a: 1,\n        foo: function(){\n          console.log(this.a);\n        }\n    };\n    var obj2 = { a: 2 };\n    var obj3 = { a: 3};\n    obj1.foo.bind(obj2).call(obj3)    \n```\n    \n  最后一行中 obj1.foo.bind(obj2)  等价于以下\n``` javascript\n    function bar(){\n        obj1.foo.apply(obj2,arguments)\n    }\n```\n   所以foo.bind(obj2)后返回了一个新的函数，这个函数被调用的时候的this被绑定到obj2，再call(obj3) 也是改变不了这个事实。\n \n   bind方法和this的关系就是以上了，由于bind方法实在是很重要并且很好用，所以这里把bind方法说完。\n   <br>\n   \n   bind方法不仅是把函数绑定至一个对象，他还附带其他功能： \n   <br>\n   \n * bind()的另一个最简单的用法是使一个函数拥有`预设的初始参数`。\n 这些参数（如果有的话）作为bind()的第二个参数开始跟在this（或其他对象）后面，之后它们会被插入到目标函数的参数列表的开始位置，调用绑定函数时传递给绑定函数的参数会跟在它们的后面。这个附带的应用即是函数式编程中的\"柯里化\"(currying)的一种（todo:关于柯里化以后再深入研究下）。\n\n``` javascript\n        function foo(y,z){\n            return this.x + y + z;\n        }\n        \n        var baz = fo.bind({x:1},2);\n        baz(3);\n```\n   \n bind方法返回一个函数对象，这个函数对象的length属性是绑定函数的形参个数减去绑定实参个数（length值不能小于0）。\n        \n * bind返回的函数被`用作构造函数`，将忽略传入bind的this,原始函数就会以构造函数的形式调用。bind时传入的实参会原封不动的传入原始函数，调用绑定函数是传入的参数紧跟其后。      \n        \n   \n#### 4.new 绑定 \n先看下new 一个构造函数都发生了什么：\n\n* 新建一个新对象（继承自Constructor.prototype）\n* 将构造函数的作用域赋给新对象，因此this指向这个新对象\n* 执行构造函数内的代码（为这个对象添加属性）\n* 隐式返回这个对象（如果构造函数内没有显示return 非null对象值）\n   \n很清晰，new 的时候 this绑定到 创建的新对象。通常是返回的那个对象实例。\n多说一句，起始在js中没有构造函数一说，只有构造调用一说。   \n   \n\n\n#### 绑定优先级   \n四种绑定规则说完了，那么问题来了，如果有多重规则同时作用时，优先级是怎样的呢？\n先回顾一下四种规则：\n\n* 默认绑定（严格模式、非严格模式）\n* 隐式绑定（对象属性调用）\n* 显示绑定（apply/call、bind）\n* new 绑定\n\n\n直接说结论吧 <br>\nnew 绑定 > 显示绑定 > 隐士绑定 \n<br>在没有前三种绑定规则的时候就应用默认绑定。\n\n至此，貌似事件处理函数中的 this还没说。事件处理函数又分DOM2级事件处理函数（addEventListener）;和内联事件处理函数。前者指向绑定事件的DOM可以归到显示绑定吧，只是这一步引擎帮你做了。后者this指向全局对象属于默认绑定，不再赘述。\n\n### 绑定例外\n在规则的世界里一切秩序井然，然而世事总有些例外，this绑定也不例外。\n\n#### 被忽略的this\n\n当把 null或者undefined作为this的绑定对象传入 call,apply,bind,这些值在调用时会被忽略，实际应用的是默认绑定规则。\n``` javascript\n    function foo(){\n      console.log(this.a);\n    }\n    var a = 2;\n    foo.call(null);//2\n```\n既然有这个机制，通常他就应该是有用的。那什么时候我们会用到null 、nudefined值呢?\n当你只想用来传递参数而不关心this的话，这是个不错的选择\n\n\n``` javascript\n    //使用apply(...)来展开一个数组，并当做参数传入一个函数\n    function foo(a,b){\n        console.log('a:'+a,'b:'+b);\n    }\n    //当然，ES6中我们可以用 ...操作符来代替apply展开数组了\n    \n    foo.apply(null,[2,3]) //a:2,b:3\n    \n    //使用bind(...)对参数进行柯里化（预设一些参数）\n    var bar = foo.bind(null,2);\n    bar(3);//a:2,b:3\n```\n至此，this讲解就接近尾声了--还有关于this的最后一点：this词法。\n    \n### this词法\n 我们知道javascript使用了词法作用域，但javascript的this机制某种程度上很像动态作用域，因为this的值通常跟函数调用有关，而跟词法作用域无关。<br>\n 事情一直到ES6之前是这样的。ES6箭头函数使得this的值和词法作用域联系起来。\n \n * 箭头函数里this值不实用前面的任何规则，而是定义该箭头函数式执行上下文里this的值。\n * 箭头函数的this绑定无法被修改 (new 也不行)\n\n\n又到了举个栗子的时候了：\n``` javascript\n\t\tfunction foo(){\n\t\t\treturn (a) => {\n\t\t\t\t//this继承自foo\n\t\t\t\tconsole.log(this.a);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar obj1 = {a:2};\n\t\tvar obj3 = {a:3};\n\t\tvar bar = foo.call(obj1);\n\t   bar.call(obj2);//2\n```\n感觉这个箭头函数里的this值似曾相识？是的，在ES6之前，我们就经常使用一种和箭头函数一样的模式。\n``` javascript\n\tfunction foo(){\n\t\tvar self = this; \n\t\tsetTimeout(function(){\n\t\t\tconsole.log(self.a);\n\t\t},100);\n\t}\t\n\t\n\tvar obj = {a:2};\n\tfoo.call(obj);//2\n```\n（完）\n\n关于this的细节就讲完了。this作为执行上下文的一个属性，由于他的规则比较多所以单独拿出来说。关于执行上下文的其他内容甚至更为重要，接下来建议拓展阅读另一篇博文[javascript之执行上下文](https://foreverwang.github.io/2017/04/09/Javascript%E4%B9%8B%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/)。\n私以为搞透执行上下文，是真正理解javascript这门语言的必要条件。\n\t\n\t\n\t\n\n\n### 参考资料\n* [《你不知道的javascipt》](https://github.com/getify/You-Dont-Know-JS/tree/master/this%20%26%20object%20prototypes)\n* 《javascript权威指南》\n","source":"_posts/Javascript语言之蜜汁this.md","raw":"---\ntitle: Javascript语言之蜜汁this\ndate: 2017-03-27 01:51:38\ncategories: \n- javascript \ntags: \n- this\n- javascript核心\n---\n\nthis关键字是Javascript中最重要的机制之一。关于介绍他的文章也比比皆是，而大多都浅尝辄止，浮于表面。故整理此篇。\n### 先看几个题目\n题目1 //默认绑定  严格模式 非严格模式\n\n``` javascript\n    function foo(){\n      console.log(this.a);\n    }\n    var a = '2';\n    (function(){\n      'use strict';\n      foo(); \n    })()\n```\n<!-- more -->\n        \n\n题目2 //隐式绑定\n``` javascript\n    function foo(){\n        console.log(this.a);\n    }\n    var a = 1;\n    var obj2 = {\n        a: 2,\n        foo:foo\n    }\n    var obj1 = {\n        a: 1,\n        obj2: obj2\n    }\n    \n    obj1.obj2.foo() \n```\n题目3 \n   \n``` javascript\n    function foo(){\n        console.log(this.a);\n    }\n    \n    var a = 2;\n    var o = {a:3,foo:foo};\n    var p = {a:4};\n    \n    (p.foo = o.foo)() \n    \n    //知识点：赋值表达式的返回值\n```\n题目4 \n``` javascript\n    var obj1 = {\n        a: 1,\n        foo: function(){\n          console.log(this.a);\n        }\n    };\n    var obj2 = { a: 2 };\n    var obj3 = { a: 3};\n    obj1.foo.bind(obj2).call(obj3) \n```\n    //知识点： bind实现\n  \n  上面4个题目的答案都是：2 。<br/>\n  如果你都答对了，那可以继续往下看了,以下是正文。本文先说为什么要用this，再说怎么用this。\n    \n### 为什么要用this?\n\n\n先看以下这段简单的代码\n``` javascript\n    function speak() {\n        var greeting = \"Hello, I'm \" + this.name;\n        console.log( greeting );\n    }\n    \n    var me = {\n        name: \"小a\"\n    };\n    \n    var you = {\n        name: \"小b\"\n    };\n    \n    speak.call( me ); // Hello, I'm 小a\n    speak.call( you ); // Hello, I'm 小b\n```\n* 以上代码可以在不同上下文对象（me 和 you）中重复使用speak函数。\n* 如果不使用this,就要给 speak显示传入一个上下文对象（如下）\n        \n``` javascript\n        function speak(content) {\n            var greeting = \"Hello, I'm \" + content.name;\n            console.log( greeting );\n        }\n      \n        speak(me);  // Hello, I'm 小a\n        speak(you); // Hello, I'm 小b\n```\n显然，this提供了一种更优雅的方式来隐式传递一个对象的引用，因此可以使API设计得更加简洁且易于复用。   \n随着使用的模式越来越复杂，显示传递上下文对象会让代码变得越来越混乱，使用this则不会这样。\n           \n### this是什么？\n\n说起this,这要看执行上下文是什么。javascript中根据可执行的种类分全局执行上下文和函数执行上下文（ES6有了块级上下文）。（关于执行上下文见另一篇[博文](https://foreverwang.github.io/2017/04/09/Javascript%E4%B9%8B%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/)）\n在全局执行上下文中（在任何函数体外部）很简单，this指代全局对象，无论是否在严格模式下。以下说的都是在函数上下文中的this。\n#### this常见误区\n* this 不指向函数自身（就没必要附加例子了）\n* this 任何情况下也不指向函数的词法作用域        \n``` javascript\n        function foo(){\n            var a = 2;\n            this.bar();\n        }\n        function bar(){\n            console.log(this.a);\n        }\n        \n        foo()//undefined\n```\n    这段代码试图通过this联通 foo和bar的词法作用域，从而让bar可以访问foo作用域里的变量a,当然这里是不能如愿的。不能使用this来引用一个词法作用域内部的东西。\n\n \n\n\n\n#### this到底是啥\n this 是在运行时进行绑定的，并不是在编写时绑定，他的上下文取决于函数调用时的各种条件。<br/> （this的值只和函数调用有关，和函数定义无关---这个说法是不对的，有两个例外：bind 和箭头函数，后面说）\n 当一个函数被调用的时候，进入这个函数的执行上下文。执行上下文里包含：函数的活动对象（函数传入的参数等）；作用域链 （函数调用栈等）；this就是上下文的其中一个属性，会在函数执行过程中用到。\n\n### this绑定规则（4个）\n先找确定函数的调用位置，调用栈\n#### 1.默认绑定\n先说结论：\n\n* 什么是默认绑定： 非严格模式下，this指向全局对象；严格模式下，this为undefined\n* 何时会走默认绑定：独立函数调用\n\n函数在不带任何修饰的进行调用（即独立函数调用）的时候，this会走默认绑定规则。\n<br>非严格模式下：this指向全局对象\n``` javascript\n        function foo(){\n            console.log(this.a);\n        }\n        var a = 2;\n        foo();//2 \n```\n严格模式下：this为undefined\n``` javascript\n     function foo(){\n         'use strict';\n          console.log(this.a);\n     }\n     var a = 2;\n     foo()//Cannot read property 'a' of undefined\n```\n这里要注意一点， 对于默认绑定，决定this绑定对象的不是调用位置是否处于严格模式，而是函数体是否处于严格模式，这也是题目1中 看似是在严格模式下，this却绑定到了全局对象\n``` javascript\n    function foo(){\n      //foo函数体处于非严格模式\n      console.log(this.a);\n    }\n    var a = '2';\n    (function(){\n      'use strict';\n      //该立即执行的函数表达式内处于严格模式这里的this为undefined\n      console.log(this);//undefined\n      foo(); //2\n    })()  \n```\n#### 2.隐式绑定\n先说结论:<br>\n当函数被调用时，函数引用有上下文对象，隐式绑定规则会把函数调用中的this绑定到这个上下文对象\n再看题目2<br>\n``` javascript\n    function foo(){\n        console.log(this.a);\n    }\n    var a = 1;\n    var obj2 = {\n        a: 2,\n        foo:foo\n    }\n    var obj1 = {\n        a: 1,\n        obj2: obj2\n    }\n    \n    obj1.obj2.foo() //2\n    //对象属性引用链中只有最顶层(属性的直接调用方)会影响调用位置\n```\n<br>\n   隐式丢失（严格来说此处并没有绑定过，也没有丢失一说，只是看上去像是丢失了）\n``` javascript\n    function foo(){\n        console.log(this.a);\n    }\n    var obj = {\n        a: 1,\n       foo: foo\n    }\n  \n    var bar = obj.foo;//函数别名\n    var a = 2;\n    bar();\n```\n  虽然bar是obj.foo的一个引用，实际上，他引用的是foo本身，此时的bar调用 就是一个不带任何修饰的函数调用，因此应用了默认绑定。<br>\n 其实本例有两个关键点：\n \n  * 赋值表达式的返回值（犀牛书6版81页）： var bar = obj.foo;返回的是右值，右值指向foo的引用\n  * 不管如何引用，只看调用时 调用是bar() ---> foo()\n\n此时再看题目3，就很清晰了\n``` javascript\n    function foo(){\n        console.log(this.a);\n    }\n    \n    var a = 2;\n    var o = {a:3,foo:foo};\n    var p = {a:4};\n    \n    //o.foo();//3\n    (p.foo = o.foo)() //p.foo = o.foo的返回值是等号的右值-->foo的引用，此处相当于直接调用foo()\n    //p.foo()//4\n```\n\n#### 3.显示绑定 \n\n先说结论：\n\n* 函数调用时通过 apply 或者 call 硬绑定this 对象(apply和call的区别这里就不赘述了)\n* 通过ES5的 Function.prototype.bind 返回一个绑定了this了的新函数\n\n看一个硬绑定的典型应用场景:接受不确定参数\n``` javascript\n    function foo(sth){\n        console.log( this.a,sth );\n        return this.a + sth;\n    }\n    var obj = {\n        a: 1\n    }\n\n    var bar = function(){\n        return foo.apply(obj,arguments);\n    }\n    \n    var b = bar(1);\n    console.log(b);//  2  \n```\n另一种方法是创建一个可复用的辅助函数（bind）\n``` javascript\n    function foo(sth){\n        console.log( this.a,sth );\n        return this.a + sth;\n    }\n    \n    //简单的辅助绑定函数\n    function bind(fn,obj){\n        return function(){\n            return fn.apply(obj,arguments);\n        }\n    }\n    \n     var obj = {\n        a: 1\n    }\n    \n    var bar = bind(foo,obj);\n    var b = bar(1);\n    console.log(b);//2\n```\n\n   由于硬绑定是一种很常用的模式，ES5提供了内置的Function.prototype.bind方法：<br>\n   `bind方法`(犀牛书第6版190页)将返回一个新的函数，以函数调用的方式调用新的函数将会把原始函数当做bind的第一个参数的方法来调用，传入新函数的任何实参都将传入原始函数。根据定义，用ES3很容易模拟bind方法，即上面代码中我们自定义的bind函数（这里只是把最基本的绑定this模拟了，参数柯里化等没有模拟，可以看MDN bind的polyfill写法，这里不贴了）。\n  <br>\n此时，再看题目4应该就很清晰了：\n``` javascript\n    var obj1 = {\n        a: 1,\n        foo: function(){\n          console.log(this.a);\n        }\n    };\n    var obj2 = { a: 2 };\n    var obj3 = { a: 3};\n    obj1.foo.bind(obj2).call(obj3)    \n```\n    \n  最后一行中 obj1.foo.bind(obj2)  等价于以下\n``` javascript\n    function bar(){\n        obj1.foo.apply(obj2,arguments)\n    }\n```\n   所以foo.bind(obj2)后返回了一个新的函数，这个函数被调用的时候的this被绑定到obj2，再call(obj3) 也是改变不了这个事实。\n \n   bind方法和this的关系就是以上了，由于bind方法实在是很重要并且很好用，所以这里把bind方法说完。\n   <br>\n   \n   bind方法不仅是把函数绑定至一个对象，他还附带其他功能： \n   <br>\n   \n * bind()的另一个最简单的用法是使一个函数拥有`预设的初始参数`。\n 这些参数（如果有的话）作为bind()的第二个参数开始跟在this（或其他对象）后面，之后它们会被插入到目标函数的参数列表的开始位置，调用绑定函数时传递给绑定函数的参数会跟在它们的后面。这个附带的应用即是函数式编程中的\"柯里化\"(currying)的一种（todo:关于柯里化以后再深入研究下）。\n\n``` javascript\n        function foo(y,z){\n            return this.x + y + z;\n        }\n        \n        var baz = fo.bind({x:1},2);\n        baz(3);\n```\n   \n bind方法返回一个函数对象，这个函数对象的length属性是绑定函数的形参个数减去绑定实参个数（length值不能小于0）。\n        \n * bind返回的函数被`用作构造函数`，将忽略传入bind的this,原始函数就会以构造函数的形式调用。bind时传入的实参会原封不动的传入原始函数，调用绑定函数是传入的参数紧跟其后。      \n        \n   \n#### 4.new 绑定 \n先看下new 一个构造函数都发生了什么：\n\n* 新建一个新对象（继承自Constructor.prototype）\n* 将构造函数的作用域赋给新对象，因此this指向这个新对象\n* 执行构造函数内的代码（为这个对象添加属性）\n* 隐式返回这个对象（如果构造函数内没有显示return 非null对象值）\n   \n很清晰，new 的时候 this绑定到 创建的新对象。通常是返回的那个对象实例。\n多说一句，起始在js中没有构造函数一说，只有构造调用一说。   \n   \n\n\n#### 绑定优先级   \n四种绑定规则说完了，那么问题来了，如果有多重规则同时作用时，优先级是怎样的呢？\n先回顾一下四种规则：\n\n* 默认绑定（严格模式、非严格模式）\n* 隐式绑定（对象属性调用）\n* 显示绑定（apply/call、bind）\n* new 绑定\n\n\n直接说结论吧 <br>\nnew 绑定 > 显示绑定 > 隐士绑定 \n<br>在没有前三种绑定规则的时候就应用默认绑定。\n\n至此，貌似事件处理函数中的 this还没说。事件处理函数又分DOM2级事件处理函数（addEventListener）;和内联事件处理函数。前者指向绑定事件的DOM可以归到显示绑定吧，只是这一步引擎帮你做了。后者this指向全局对象属于默认绑定，不再赘述。\n\n### 绑定例外\n在规则的世界里一切秩序井然，然而世事总有些例外，this绑定也不例外。\n\n#### 被忽略的this\n\n当把 null或者undefined作为this的绑定对象传入 call,apply,bind,这些值在调用时会被忽略，实际应用的是默认绑定规则。\n``` javascript\n    function foo(){\n      console.log(this.a);\n    }\n    var a = 2;\n    foo.call(null);//2\n```\n既然有这个机制，通常他就应该是有用的。那什么时候我们会用到null 、nudefined值呢?\n当你只想用来传递参数而不关心this的话，这是个不错的选择\n\n\n``` javascript\n    //使用apply(...)来展开一个数组，并当做参数传入一个函数\n    function foo(a,b){\n        console.log('a:'+a,'b:'+b);\n    }\n    //当然，ES6中我们可以用 ...操作符来代替apply展开数组了\n    \n    foo.apply(null,[2,3]) //a:2,b:3\n    \n    //使用bind(...)对参数进行柯里化（预设一些参数）\n    var bar = foo.bind(null,2);\n    bar(3);//a:2,b:3\n```\n至此，this讲解就接近尾声了--还有关于this的最后一点：this词法。\n    \n### this词法\n 我们知道javascript使用了词法作用域，但javascript的this机制某种程度上很像动态作用域，因为this的值通常跟函数调用有关，而跟词法作用域无关。<br>\n 事情一直到ES6之前是这样的。ES6箭头函数使得this的值和词法作用域联系起来。\n \n * 箭头函数里this值不实用前面的任何规则，而是定义该箭头函数式执行上下文里this的值。\n * 箭头函数的this绑定无法被修改 (new 也不行)\n\n\n又到了举个栗子的时候了：\n``` javascript\n\t\tfunction foo(){\n\t\t\treturn (a) => {\n\t\t\t\t//this继承自foo\n\t\t\t\tconsole.log(this.a);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar obj1 = {a:2};\n\t\tvar obj3 = {a:3};\n\t\tvar bar = foo.call(obj1);\n\t   bar.call(obj2);//2\n```\n感觉这个箭头函数里的this值似曾相识？是的，在ES6之前，我们就经常使用一种和箭头函数一样的模式。\n``` javascript\n\tfunction foo(){\n\t\tvar self = this; \n\t\tsetTimeout(function(){\n\t\t\tconsole.log(self.a);\n\t\t},100);\n\t}\t\n\t\n\tvar obj = {a:2};\n\tfoo.call(obj);//2\n```\n（完）\n\n关于this的细节就讲完了。this作为执行上下文的一个属性，由于他的规则比较多所以单独拿出来说。关于执行上下文的其他内容甚至更为重要，接下来建议拓展阅读另一篇博文[javascript之执行上下文](https://foreverwang.github.io/2017/04/09/Javascript%E4%B9%8B%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/)。\n私以为搞透执行上下文，是真正理解javascript这门语言的必要条件。\n\t\n\t\n\t\n\n\n### 参考资料\n* [《你不知道的javascipt》](https://github.com/getify/You-Dont-Know-JS/tree/master/this%20%26%20object%20prototypes)\n* 《javascript权威指南》\n","slug":"Javascript语言之蜜汁this","published":1,"updated":"2018-03-10T16:05:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjelnshcc00023gff0dtg0bw6","content":"<p>this关键字是Javascript中最重要的机制之一。关于介绍他的文章也比比皆是，而大多都浅尝辄止，浮于表面。故整理此篇。</p>\n<h3 id=\"先看几个题目\"><a href=\"#先看几个题目\" class=\"headerlink\" title=\"先看几个题目\"></a>先看几个题目</h3><p>题目1 //默认绑定  严格模式 非严格模式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">'2'</span>;</div><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\"><span class=\"meta\">  'use strict'</span>;</div><div class=\"line\">  foo(); </div><div class=\"line\">&#125;)()</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>题目2 //隐式绑定<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;</div><div class=\"line\">    <span class=\"attr\">a</span>: <span class=\"number\">2</span>,</div><div class=\"line\">    <span class=\"attr\">foo</span>:foo</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</div><div class=\"line\">    <span class=\"attr\">a</span>: <span class=\"number\">1</span>,</div><div class=\"line\">    <span class=\"attr\">obj2</span>: obj2</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">obj1.obj2.foo()</div></pre></td></tr></table></figure></p>\n<p>题目3 </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> o = &#123;<span class=\"attr\">a</span>:<span class=\"number\">3</span>,<span class=\"attr\">foo</span>:foo&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> p = &#123;<span class=\"attr\">a</span>:<span class=\"number\">4</span>&#125;;</div><div class=\"line\"></div><div class=\"line\">(p.foo = o.foo)() </div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//知识点：赋值表达式的返回值</span></div></pre></td></tr></table></figure>\n<p>题目4<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</div><div class=\"line\">    <span class=\"attr\">a</span>: <span class=\"number\">1</span>,</div><div class=\"line\">    <span class=\"attr\">foo</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123; <span class=\"attr\">a</span>: <span class=\"number\">2</span> &#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> obj3 = &#123; <span class=\"attr\">a</span>: <span class=\"number\">3</span>&#125;;</div><div class=\"line\">obj1.foo.bind(obj2).call(obj3)</div></pre></td></tr></table></figure></p>\n<pre><code>//知识点： bind实现\n</code></pre><p>  上面4个题目的答案都是：2 。<br><br>  如果你都答对了，那可以继续往下看了,以下是正文。本文先说为什么要用this，再说怎么用this。</p>\n<h3 id=\"为什么要用this\"><a href=\"#为什么要用this\" class=\"headerlink\" title=\"为什么要用this?\"></a>为什么要用this?</h3><p>先看以下这段简单的代码<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">speak</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> greeting = <span class=\"string\">\"Hello, I'm \"</span> + <span class=\"keyword\">this</span>.name;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log( greeting );</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> me = &#123;</div><div class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">\"小a\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> you = &#123;</div><div class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">\"小b\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">speak.call( me ); <span class=\"comment\">// Hello, I'm 小a</span></div><div class=\"line\">speak.call( you ); <span class=\"comment\">// Hello, I'm 小b</span></div></pre></td></tr></table></figure></p>\n<ul>\n<li>以上代码可以在不同上下文对象（me 和 you）中重复使用speak函数。</li>\n<li>如果不使用this,就要给 speak显示传入一个上下文对象（如下）</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">speak</span>(<span class=\"params\">content</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> greeting = <span class=\"string\">\"Hello, I'm \"</span> + content.name;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log( greeting );</div><div class=\"line\">&#125;</div><div class=\"line\">      </div><div class=\"line\">speak(me);  <span class=\"comment\">// Hello, I'm 小a</span></div><div class=\"line\">speak(you); <span class=\"comment\">// Hello, I'm 小b</span></div></pre></td></tr></table></figure>\n<p>显然，this提供了一种更优雅的方式来隐式传递一个对象的引用，因此可以使API设计得更加简洁且易于复用。<br>随着使用的模式越来越复杂，显示传递上下文对象会让代码变得越来越混乱，使用this则不会这样。</p>\n<h3 id=\"this是什么？\"><a href=\"#this是什么？\" class=\"headerlink\" title=\"this是什么？\"></a>this是什么？</h3><p>说起this,这要看执行上下文是什么。javascript中根据可执行的种类分全局执行上下文和函数执行上下文（ES6有了块级上下文）。（关于执行上下文见另一篇<a href=\"https://foreverwang.github.io/2017/04/09/Javascript%E4%B9%8B%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/\">博文</a>）<br>在全局执行上下文中（在任何函数体外部）很简单，this指代全局对象，无论是否在严格模式下。以下说的都是在函数上下文中的this。</p>\n<h4 id=\"this常见误区\"><a href=\"#this常见误区\" class=\"headerlink\" title=\"this常见误区\"></a>this常见误区</h4><ul>\n<li>this 不指向函数自身（就没必要附加例子了）</li>\n<li><p>this 任何情况下也不指向函数的词法作用域        </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</div><div class=\"line\">    <span class=\"keyword\">this</span>.bar();</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">foo()<span class=\"comment\">//undefined</span></div></pre></td></tr></table></figure>\n<p>  这段代码试图通过this联通 foo和bar的词法作用域，从而让bar可以访问foo作用域里的变量a,当然这里是不能如愿的。不能使用this来引用一个词法作用域内部的东西。</p>\n</li>\n</ul>\n<h4 id=\"this到底是啥\"><a href=\"#this到底是啥\" class=\"headerlink\" title=\"this到底是啥\"></a>this到底是啥</h4><p> this 是在运行时进行绑定的，并不是在编写时绑定，他的上下文取决于函数调用时的各种条件。<br> （this的值只和函数调用有关，和函数定义无关—这个说法是不对的，有两个例外：bind 和箭头函数，后面说）<br> 当一个函数被调用的时候，进入这个函数的执行上下文。执行上下文里包含：函数的活动对象（函数传入的参数等）；作用域链 （函数调用栈等）；this就是上下文的其中一个属性，会在函数执行过程中用到。</p>\n<h3 id=\"this绑定规则（4个）\"><a href=\"#this绑定规则（4个）\" class=\"headerlink\" title=\"this绑定规则（4个）\"></a>this绑定规则（4个）</h3><p>先找确定函数的调用位置，调用栈</p>\n<h4 id=\"1-默认绑定\"><a href=\"#1-默认绑定\" class=\"headerlink\" title=\"1.默认绑定\"></a>1.默认绑定</h4><p>先说结论：</p>\n<ul>\n<li>什么是默认绑定： 非严格模式下，this指向全局对象；严格模式下，this为undefined</li>\n<li>何时会走默认绑定：独立函数调用</li>\n</ul>\n<p>函数在不带任何修饰的进行调用（即独立函数调用）的时候，this会走默认绑定规则。<br><br>非严格模式下：this指向全局对象<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</div><div class=\"line\">foo();<span class=\"comment\">//2</span></div></pre></td></tr></table></figure></p>\n<p>严格模式下：this为undefined<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\"><span class=\"meta\">    'use strict'</span>;</div><div class=\"line\">     <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</div><div class=\"line\">foo()<span class=\"comment\">//Cannot read property 'a' of undefined</span></div></pre></td></tr></table></figure></p>\n<p>这里要注意一点， 对于默认绑定，决定this绑定对象的不是调用位置是否处于严格模式，而是函数体是否处于严格模式，这也是题目1中 看似是在严格模式下，this却绑定到了全局对象<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"comment\">//foo函数体处于非严格模式</span></div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">'2'</span>;</div><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\"><span class=\"meta\">  'use strict'</span>;</div><div class=\"line\">  <span class=\"comment\">//该立即执行的函数表达式内处于严格模式这里的this为undefined</span></div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);<span class=\"comment\">//undefined</span></div><div class=\"line\">  foo(); <span class=\"comment\">//2</span></div><div class=\"line\">&#125;)()</div></pre></td></tr></table></figure></p>\n<h4 id=\"2-隐式绑定\"><a href=\"#2-隐式绑定\" class=\"headerlink\" title=\"2.隐式绑定\"></a>2.隐式绑定</h4><p>先说结论:<br><br>当函数被调用时，函数引用有上下文对象，隐式绑定规则会把函数调用中的this绑定到这个上下文对象<br>再看题目2<br><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;</div><div class=\"line\">    <span class=\"attr\">a</span>: <span class=\"number\">2</span>,</div><div class=\"line\">    <span class=\"attr\">foo</span>:foo</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</div><div class=\"line\">    <span class=\"attr\">a</span>: <span class=\"number\">1</span>,</div><div class=\"line\">    <span class=\"attr\">obj2</span>: obj2</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">obj1.obj2.foo() <span class=\"comment\">//2</span></div><div class=\"line\"><span class=\"comment\">//对象属性引用链中只有最顶层(属性的直接调用方)会影响调用位置</span></div></pre></td></tr></table></figure></p>\n<p><br><br>   隐式丢失（严格来说此处并没有绑定过，也没有丢失一说，只是看上去像是丢失了）<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</div><div class=\"line\">    <span class=\"attr\">a</span>: <span class=\"number\">1</span>,</div><div class=\"line\">   <span class=\"attr\">foo</span>: foo</div><div class=\"line\">&#125;</div><div class=\"line\">  </div><div class=\"line\"><span class=\"keyword\">var</span> bar = obj.foo;<span class=\"comment\">//函数别名</span></div><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</div><div class=\"line\">bar();</div></pre></td></tr></table></figure></p>\n<p>  虽然bar是obj.foo的一个引用，实际上，他引用的是foo本身，此时的bar调用 就是一个不带任何修饰的函数调用，因此应用了默认绑定。<br><br> 其实本例有两个关键点：</p>\n<ul>\n<li>赋值表达式的返回值（犀牛书6版81页）： var bar = obj.foo;返回的是右值，右值指向foo的引用</li>\n<li>不管如何引用，只看调用时 调用是bar() —&gt; foo()</li>\n</ul>\n<p>此时再看题目3，就很清晰了<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> o = &#123;<span class=\"attr\">a</span>:<span class=\"number\">3</span>,<span class=\"attr\">foo</span>:foo&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> p = &#123;<span class=\"attr\">a</span>:<span class=\"number\">4</span>&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//o.foo();//3</span></div><div class=\"line\">(p.foo = o.foo)() <span class=\"comment\">//p.foo = o.foo的返回值是等号的右值--&gt;foo的引用，此处相当于直接调用foo()</span></div><div class=\"line\"><span class=\"comment\">//p.foo()//4</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"3-显示绑定\"><a href=\"#3-显示绑定\" class=\"headerlink\" title=\"3.显示绑定\"></a>3.显示绑定</h4><p>先说结论：</p>\n<ul>\n<li>函数调用时通过 apply 或者 call 硬绑定this 对象(apply和call的区别这里就不赘述了)</li>\n<li>通过ES5的 Function.prototype.bind 返回一个绑定了this了的新函数</li>\n</ul>\n<p>看一个硬绑定的典型应用场景:接受不确定参数<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">sth</span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a,sth );</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a + sth;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</div><div class=\"line\">    <span class=\"attr\">a</span>: <span class=\"number\">1</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> bar = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> foo.apply(obj,<span class=\"built_in\">arguments</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> b = bar(<span class=\"number\">1</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(b);<span class=\"comment\">//  2</span></div></pre></td></tr></table></figure></p>\n<p>另一种方法是创建一个可复用的辅助函数（bind）<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">sth</span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a,sth );</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a + sth;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//简单的辅助绑定函数</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bind</span>(<span class=\"params\">fn,obj</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> fn.apply(obj,<span class=\"built_in\">arguments</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"> <span class=\"keyword\">var</span> obj = &#123;</div><div class=\"line\">    <span class=\"attr\">a</span>: <span class=\"number\">1</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> bar = bind(foo,obj);</div><div class=\"line\"><span class=\"keyword\">var</span> b = bar(<span class=\"number\">1</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(b);<span class=\"comment\">//2</span></div></pre></td></tr></table></figure></p>\n<p>   由于硬绑定是一种很常用的模式，ES5提供了内置的Function.prototype.bind方法：<br><br>   <code>bind方法</code>(犀牛书第6版190页)将返回一个新的函数，以函数调用的方式调用新的函数将会把原始函数当做bind的第一个参数的方法来调用，传入新函数的任何实参都将传入原始函数。根据定义，用ES3很容易模拟bind方法，即上面代码中我们自定义的bind函数（这里只是把最基本的绑定this模拟了，参数柯里化等没有模拟，可以看MDN bind的polyfill写法，这里不贴了）。<br>  <br><br>此时，再看题目4应该就很清晰了：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</div><div class=\"line\">    <span class=\"attr\">a</span>: <span class=\"number\">1</span>,</div><div class=\"line\">    <span class=\"attr\">foo</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123; <span class=\"attr\">a</span>: <span class=\"number\">2</span> &#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> obj3 = &#123; <span class=\"attr\">a</span>: <span class=\"number\">3</span>&#125;;</div><div class=\"line\">obj1.foo.bind(obj2).call(obj3)</div></pre></td></tr></table></figure></p>\n<p>  最后一行中 obj1.foo.bind(obj2)  等价于以下<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    obj1.foo.apply(obj2,<span class=\"built_in\">arguments</span>)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>   所以foo.bind(obj2)后返回了一个新的函数，这个函数被调用的时候的this被绑定到obj2，再call(obj3) 也是改变不了这个事实。</p>\n<p>   bind方法和this的关系就是以上了，由于bind方法实在是很重要并且很好用，所以这里把bind方法说完。<br>   <br></p>\n<p>   bind方法不仅是把函数绑定至一个对象，他还附带其他功能：<br>   <br></p>\n<ul>\n<li>bind()的另一个最简单的用法是使一个函数拥有<code>预设的初始参数</code>。<br>这些参数（如果有的话）作为bind()的第二个参数开始跟在this（或其他对象）后面，之后它们会被插入到目标函数的参数列表的开始位置，调用绑定函数时传递给绑定函数的参数会跟在它们的后面。这个附带的应用即是函数式编程中的”柯里化”(currying)的一种（todo:关于柯里化以后再深入研究下）。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">y,z</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.x + y + z;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> baz = fo.bind(&#123;<span class=\"attr\">x</span>:<span class=\"number\">1</span>&#125;,<span class=\"number\">2</span>);</div><div class=\"line\">baz(<span class=\"number\">3</span>);</div></pre></td></tr></table></figure>\n<p> bind方法返回一个函数对象，这个函数对象的length属性是绑定函数的形参个数减去绑定实参个数（length值不能小于0）。</p>\n<ul>\n<li>bind返回的函数被<code>用作构造函数</code>，将忽略传入bind的this,原始函数就会以构造函数的形式调用。bind时传入的实参会原封不动的传入原始函数，调用绑定函数是传入的参数紧跟其后。      </li>\n</ul>\n<h4 id=\"4-new-绑定\"><a href=\"#4-new-绑定\" class=\"headerlink\" title=\"4.new 绑定\"></a>4.new 绑定</h4><p>先看下new 一个构造函数都发生了什么：</p>\n<ul>\n<li>新建一个新对象（继承自Constructor.prototype）</li>\n<li>将构造函数的作用域赋给新对象，因此this指向这个新对象</li>\n<li>执行构造函数内的代码（为这个对象添加属性）</li>\n<li>隐式返回这个对象（如果构造函数内没有显示return 非null对象值）</li>\n</ul>\n<p>很清晰，new 的时候 this绑定到 创建的新对象。通常是返回的那个对象实例。<br>多说一句，起始在js中没有构造函数一说，只有构造调用一说。   </p>\n<h4 id=\"绑定优先级\"><a href=\"#绑定优先级\" class=\"headerlink\" title=\"绑定优先级\"></a>绑定优先级</h4><p>四种绑定规则说完了，那么问题来了，如果有多重规则同时作用时，优先级是怎样的呢？<br>先回顾一下四种规则：</p>\n<ul>\n<li>默认绑定（严格模式、非严格模式）</li>\n<li>隐式绑定（对象属性调用）</li>\n<li>显示绑定（apply/call、bind）</li>\n<li>new 绑定</li>\n</ul>\n<p>直接说结论吧 <br><br>new 绑定 &gt; 显示绑定 &gt; 隐士绑定<br><br>在没有前三种绑定规则的时候就应用默认绑定。</p>\n<p>至此，貌似事件处理函数中的 this还没说。事件处理函数又分DOM2级事件处理函数（addEventListener）;和内联事件处理函数。前者指向绑定事件的DOM可以归到显示绑定吧，只是这一步引擎帮你做了。后者this指向全局对象属于默认绑定，不再赘述。</p>\n<h3 id=\"绑定例外\"><a href=\"#绑定例外\" class=\"headerlink\" title=\"绑定例外\"></a>绑定例外</h3><p>在规则的世界里一切秩序井然，然而世事总有些例外，this绑定也不例外。</p>\n<h4 id=\"被忽略的this\"><a href=\"#被忽略的this\" class=\"headerlink\" title=\"被忽略的this\"></a>被忽略的this</h4><p>当把 null或者undefined作为this的绑定对象传入 call,apply,bind,这些值在调用时会被忽略，实际应用的是默认绑定规则。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</div><div class=\"line\">foo.call(<span class=\"literal\">null</span>);<span class=\"comment\">//2</span></div></pre></td></tr></table></figure></p>\n<p>既然有这个机制，通常他就应该是有用的。那什么时候我们会用到null 、nudefined值呢?<br>当你只想用来传递参数而不关心this的话，这是个不错的选择</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//使用apply(...)来展开一个数组，并当做参数传入一个函数</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">a,b</span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'a:'</span>+a,<span class=\"string\">'b:'</span>+b);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//当然，ES6中我们可以用 ...操作符来代替apply展开数组了</span></div><div class=\"line\"></div><div class=\"line\">foo.apply(<span class=\"literal\">null</span>,[<span class=\"number\">2</span>,<span class=\"number\">3</span>]) <span class=\"comment\">//a:2,b:3</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//使用bind(...)对参数进行柯里化（预设一些参数）</span></div><div class=\"line\"><span class=\"keyword\">var</span> bar = foo.bind(<span class=\"literal\">null</span>,<span class=\"number\">2</span>);</div><div class=\"line\">bar(<span class=\"number\">3</span>);<span class=\"comment\">//a:2,b:3</span></div></pre></td></tr></table></figure>\n<p>至此，this讲解就接近尾声了–还有关于this的最后一点：this词法。</p>\n<h3 id=\"this词法\"><a href=\"#this词法\" class=\"headerlink\" title=\"this词法\"></a>this词法</h3><p> 我们知道javascript使用了词法作用域，但javascript的this机制某种程度上很像动态作用域，因为this的值通常跟函数调用有关，而跟词法作用域无关。<br><br> 事情一直到ES6之前是这样的。ES6箭头函数使得this的值和词法作用域联系起来。</p>\n<ul>\n<li>箭头函数里this值不实用前面的任何规则，而是定义该箭头函数式执行上下文里this的值。</li>\n<li>箭头函数的this绑定无法被修改 (new 也不行)</li>\n</ul>\n<p>又到了举个栗子的时候了：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">a</span>) =&gt;</span> &#123;</div><div class=\"line\">\t\t<span class=\"comment\">//this继承自foo</span></div><div class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;<span class=\"attr\">a</span>:<span class=\"number\">2</span>&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> obj3 = &#123;<span class=\"attr\">a</span>:<span class=\"number\">3</span>&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> bar = foo.call(obj1);</div><div class=\"line\">  bar.call(obj2);<span class=\"comment\">//2</span></div></pre></td></tr></table></figure></p>\n<p>感觉这个箭头函数里的this值似曾相识？是的，在ES6之前，我们就经常使用一种和箭头函数一样的模式。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span>; </div><div class=\"line\">\tsetTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"built_in\">console</span>.log(self.a);</div><div class=\"line\">\t&#125;,<span class=\"number\">100</span>);</div><div class=\"line\">&#125;\t</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> obj = &#123;<span class=\"attr\">a</span>:<span class=\"number\">2</span>&#125;;</div><div class=\"line\">foo.call(obj);<span class=\"comment\">//2</span></div></pre></td></tr></table></figure></p>\n<p>（完）</p>\n<p>关于this的细节就讲完了。this作为执行上下文的一个属性，由于他的规则比较多所以单独拿出来说。关于执行上下文的其他内容甚至更为重要，接下来建议拓展阅读另一篇博文<a href=\"https://foreverwang.github.io/2017/04/09/Javascript%E4%B9%8B%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/\">javascript之执行上下文</a>。<br>私以为搞透执行上下文，是真正理解javascript这门语言的必要条件。</p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><ul>\n<li><a href=\"https://github.com/getify/You-Dont-Know-JS/tree/master/this%20%26%20object%20prototypes\" target=\"_blank\" rel=\"external\">《你不知道的javascipt》</a></li>\n<li>《javascript权威指南》</li>\n</ul>\n","excerpt":"<p>this关键字是Javascript中最重要的机制之一。关于介绍他的文章也比比皆是，而大多都浅尝辄止，浮于表面。故整理此篇。</p>\n<h3 id=\"先看几个题目\"><a href=\"#先看几个题目\" class=\"headerlink\" title=\"先看几个题目\"></a>先看几个题目</h3><p>题目1 //默认绑定  严格模式 非严格模式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">'2'</span>;</div><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\"><span class=\"meta\">  'use strict'</span>;</div><div class=\"line\">  foo(); </div><div class=\"line\">&#125;)()</div></pre></td></tr></table></figure>","more":"<p>题目2 //隐式绑定<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;</div><div class=\"line\">    <span class=\"attr\">a</span>: <span class=\"number\">2</span>,</div><div class=\"line\">    <span class=\"attr\">foo</span>:foo</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</div><div class=\"line\">    <span class=\"attr\">a</span>: <span class=\"number\">1</span>,</div><div class=\"line\">    <span class=\"attr\">obj2</span>: obj2</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">obj1.obj2.foo()</div></pre></td></tr></table></figure></p>\n<p>题目3 </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> o = &#123;<span class=\"attr\">a</span>:<span class=\"number\">3</span>,<span class=\"attr\">foo</span>:foo&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> p = &#123;<span class=\"attr\">a</span>:<span class=\"number\">4</span>&#125;;</div><div class=\"line\"></div><div class=\"line\">(p.foo = o.foo)() </div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//知识点：赋值表达式的返回值</span></div></pre></td></tr></table></figure>\n<p>题目4<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</div><div class=\"line\">    <span class=\"attr\">a</span>: <span class=\"number\">1</span>,</div><div class=\"line\">    <span class=\"attr\">foo</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123; <span class=\"attr\">a</span>: <span class=\"number\">2</span> &#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> obj3 = &#123; <span class=\"attr\">a</span>: <span class=\"number\">3</span>&#125;;</div><div class=\"line\">obj1.foo.bind(obj2).call(obj3)</div></pre></td></tr></table></figure></p>\n<pre><code>//知识点： bind实现\n</code></pre><p>  上面4个题目的答案都是：2 。<br/><br>  如果你都答对了，那可以继续往下看了,以下是正文。本文先说为什么要用this，再说怎么用this。</p>\n<h3 id=\"为什么要用this\"><a href=\"#为什么要用this\" class=\"headerlink\" title=\"为什么要用this?\"></a>为什么要用this?</h3><p>先看以下这段简单的代码<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">speak</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> greeting = <span class=\"string\">\"Hello, I'm \"</span> + <span class=\"keyword\">this</span>.name;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log( greeting );</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> me = &#123;</div><div class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">\"小a\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> you = &#123;</div><div class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">\"小b\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">speak.call( me ); <span class=\"comment\">// Hello, I'm 小a</span></div><div class=\"line\">speak.call( you ); <span class=\"comment\">// Hello, I'm 小b</span></div></pre></td></tr></table></figure></p>\n<ul>\n<li>以上代码可以在不同上下文对象（me 和 you）中重复使用speak函数。</li>\n<li>如果不使用this,就要给 speak显示传入一个上下文对象（如下）</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">speak</span>(<span class=\"params\">content</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> greeting = <span class=\"string\">\"Hello, I'm \"</span> + content.name;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log( greeting );</div><div class=\"line\">&#125;</div><div class=\"line\">      </div><div class=\"line\">speak(me);  <span class=\"comment\">// Hello, I'm 小a</span></div><div class=\"line\">speak(you); <span class=\"comment\">// Hello, I'm 小b</span></div></pre></td></tr></table></figure>\n<p>显然，this提供了一种更优雅的方式来隐式传递一个对象的引用，因此可以使API设计得更加简洁且易于复用。<br>随着使用的模式越来越复杂，显示传递上下文对象会让代码变得越来越混乱，使用this则不会这样。</p>\n<h3 id=\"this是什么？\"><a href=\"#this是什么？\" class=\"headerlink\" title=\"this是什么？\"></a>this是什么？</h3><p>说起this,这要看执行上下文是什么。javascript中根据可执行的种类分全局执行上下文和函数执行上下文（ES6有了块级上下文）。（关于执行上下文见另一篇<a href=\"https://foreverwang.github.io/2017/04/09/Javascript%E4%B9%8B%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/\">博文</a>）<br>在全局执行上下文中（在任何函数体外部）很简单，this指代全局对象，无论是否在严格模式下。以下说的都是在函数上下文中的this。</p>\n<h4 id=\"this常见误区\"><a href=\"#this常见误区\" class=\"headerlink\" title=\"this常见误区\"></a>this常见误区</h4><ul>\n<li>this 不指向函数自身（就没必要附加例子了）</li>\n<li><p>this 任何情况下也不指向函数的词法作用域        </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</div><div class=\"line\">    <span class=\"keyword\">this</span>.bar();</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">foo()<span class=\"comment\">//undefined</span></div></pre></td></tr></table></figure>\n<p>  这段代码试图通过this联通 foo和bar的词法作用域，从而让bar可以访问foo作用域里的变量a,当然这里是不能如愿的。不能使用this来引用一个词法作用域内部的东西。</p>\n</li>\n</ul>\n<h4 id=\"this到底是啥\"><a href=\"#this到底是啥\" class=\"headerlink\" title=\"this到底是啥\"></a>this到底是啥</h4><p> this 是在运行时进行绑定的，并不是在编写时绑定，他的上下文取决于函数调用时的各种条件。<br/> （this的值只和函数调用有关，和函数定义无关—这个说法是不对的，有两个例外：bind 和箭头函数，后面说）<br> 当一个函数被调用的时候，进入这个函数的执行上下文。执行上下文里包含：函数的活动对象（函数传入的参数等）；作用域链 （函数调用栈等）；this就是上下文的其中一个属性，会在函数执行过程中用到。</p>\n<h3 id=\"this绑定规则（4个）\"><a href=\"#this绑定规则（4个）\" class=\"headerlink\" title=\"this绑定规则（4个）\"></a>this绑定规则（4个）</h3><p>先找确定函数的调用位置，调用栈</p>\n<h4 id=\"1-默认绑定\"><a href=\"#1-默认绑定\" class=\"headerlink\" title=\"1.默认绑定\"></a>1.默认绑定</h4><p>先说结论：</p>\n<ul>\n<li>什么是默认绑定： 非严格模式下，this指向全局对象；严格模式下，this为undefined</li>\n<li>何时会走默认绑定：独立函数调用</li>\n</ul>\n<p>函数在不带任何修饰的进行调用（即独立函数调用）的时候，this会走默认绑定规则。<br><br>非严格模式下：this指向全局对象<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</div><div class=\"line\">foo();<span class=\"comment\">//2</span></div></pre></td></tr></table></figure></p>\n<p>严格模式下：this为undefined<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\"><span class=\"meta\">    'use strict'</span>;</div><div class=\"line\">     <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</div><div class=\"line\">foo()<span class=\"comment\">//Cannot read property 'a' of undefined</span></div></pre></td></tr></table></figure></p>\n<p>这里要注意一点， 对于默认绑定，决定this绑定对象的不是调用位置是否处于严格模式，而是函数体是否处于严格模式，这也是题目1中 看似是在严格模式下，this却绑定到了全局对象<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"comment\">//foo函数体处于非严格模式</span></div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">'2'</span>;</div><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\"><span class=\"meta\">  'use strict'</span>;</div><div class=\"line\">  <span class=\"comment\">//该立即执行的函数表达式内处于严格模式这里的this为undefined</span></div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);<span class=\"comment\">//undefined</span></div><div class=\"line\">  foo(); <span class=\"comment\">//2</span></div><div class=\"line\">&#125;)()</div></pre></td></tr></table></figure></p>\n<h4 id=\"2-隐式绑定\"><a href=\"#2-隐式绑定\" class=\"headerlink\" title=\"2.隐式绑定\"></a>2.隐式绑定</h4><p>先说结论:<br><br>当函数被调用时，函数引用有上下文对象，隐式绑定规则会把函数调用中的this绑定到这个上下文对象<br>再看题目2<br><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;</div><div class=\"line\">    <span class=\"attr\">a</span>: <span class=\"number\">2</span>,</div><div class=\"line\">    <span class=\"attr\">foo</span>:foo</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</div><div class=\"line\">    <span class=\"attr\">a</span>: <span class=\"number\">1</span>,</div><div class=\"line\">    <span class=\"attr\">obj2</span>: obj2</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">obj1.obj2.foo() <span class=\"comment\">//2</span></div><div class=\"line\"><span class=\"comment\">//对象属性引用链中只有最顶层(属性的直接调用方)会影响调用位置</span></div></pre></td></tr></table></figure></p>\n<p><br><br>   隐式丢失（严格来说此处并没有绑定过，也没有丢失一说，只是看上去像是丢失了）<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</div><div class=\"line\">    <span class=\"attr\">a</span>: <span class=\"number\">1</span>,</div><div class=\"line\">   <span class=\"attr\">foo</span>: foo</div><div class=\"line\">&#125;</div><div class=\"line\">  </div><div class=\"line\"><span class=\"keyword\">var</span> bar = obj.foo;<span class=\"comment\">//函数别名</span></div><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</div><div class=\"line\">bar();</div></pre></td></tr></table></figure></p>\n<p>  虽然bar是obj.foo的一个引用，实际上，他引用的是foo本身，此时的bar调用 就是一个不带任何修饰的函数调用，因此应用了默认绑定。<br><br> 其实本例有两个关键点：</p>\n<ul>\n<li>赋值表达式的返回值（犀牛书6版81页）： var bar = obj.foo;返回的是右值，右值指向foo的引用</li>\n<li>不管如何引用，只看调用时 调用是bar() —&gt; foo()</li>\n</ul>\n<p>此时再看题目3，就很清晰了<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> o = &#123;<span class=\"attr\">a</span>:<span class=\"number\">3</span>,<span class=\"attr\">foo</span>:foo&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> p = &#123;<span class=\"attr\">a</span>:<span class=\"number\">4</span>&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//o.foo();//3</span></div><div class=\"line\">(p.foo = o.foo)() <span class=\"comment\">//p.foo = o.foo的返回值是等号的右值--&gt;foo的引用，此处相当于直接调用foo()</span></div><div class=\"line\"><span class=\"comment\">//p.foo()//4</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"3-显示绑定\"><a href=\"#3-显示绑定\" class=\"headerlink\" title=\"3.显示绑定\"></a>3.显示绑定</h4><p>先说结论：</p>\n<ul>\n<li>函数调用时通过 apply 或者 call 硬绑定this 对象(apply和call的区别这里就不赘述了)</li>\n<li>通过ES5的 Function.prototype.bind 返回一个绑定了this了的新函数</li>\n</ul>\n<p>看一个硬绑定的典型应用场景:接受不确定参数<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">sth</span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a,sth );</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a + sth;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</div><div class=\"line\">    <span class=\"attr\">a</span>: <span class=\"number\">1</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> bar = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> foo.apply(obj,<span class=\"built_in\">arguments</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> b = bar(<span class=\"number\">1</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(b);<span class=\"comment\">//  2</span></div></pre></td></tr></table></figure></p>\n<p>另一种方法是创建一个可复用的辅助函数（bind）<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">sth</span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a,sth );</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a + sth;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//简单的辅助绑定函数</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bind</span>(<span class=\"params\">fn,obj</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> fn.apply(obj,<span class=\"built_in\">arguments</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"> <span class=\"keyword\">var</span> obj = &#123;</div><div class=\"line\">    <span class=\"attr\">a</span>: <span class=\"number\">1</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> bar = bind(foo,obj);</div><div class=\"line\"><span class=\"keyword\">var</span> b = bar(<span class=\"number\">1</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(b);<span class=\"comment\">//2</span></div></pre></td></tr></table></figure></p>\n<p>   由于硬绑定是一种很常用的模式，ES5提供了内置的Function.prototype.bind方法：<br><br>   <code>bind方法</code>(犀牛书第6版190页)将返回一个新的函数，以函数调用的方式调用新的函数将会把原始函数当做bind的第一个参数的方法来调用，传入新函数的任何实参都将传入原始函数。根据定义，用ES3很容易模拟bind方法，即上面代码中我们自定义的bind函数（这里只是把最基本的绑定this模拟了，参数柯里化等没有模拟，可以看MDN bind的polyfill写法，这里不贴了）。<br>  <br><br>此时，再看题目4应该就很清晰了：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</div><div class=\"line\">    <span class=\"attr\">a</span>: <span class=\"number\">1</span>,</div><div class=\"line\">    <span class=\"attr\">foo</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123; <span class=\"attr\">a</span>: <span class=\"number\">2</span> &#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> obj3 = &#123; <span class=\"attr\">a</span>: <span class=\"number\">3</span>&#125;;</div><div class=\"line\">obj1.foo.bind(obj2).call(obj3)</div></pre></td></tr></table></figure></p>\n<p>  最后一行中 obj1.foo.bind(obj2)  等价于以下<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    obj1.foo.apply(obj2,<span class=\"built_in\">arguments</span>)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>   所以foo.bind(obj2)后返回了一个新的函数，这个函数被调用的时候的this被绑定到obj2，再call(obj3) 也是改变不了这个事实。</p>\n<p>   bind方法和this的关系就是以上了，由于bind方法实在是很重要并且很好用，所以这里把bind方法说完。<br>   <br></p>\n<p>   bind方法不仅是把函数绑定至一个对象，他还附带其他功能：<br>   <br></p>\n<ul>\n<li>bind()的另一个最简单的用法是使一个函数拥有<code>预设的初始参数</code>。<br>这些参数（如果有的话）作为bind()的第二个参数开始跟在this（或其他对象）后面，之后它们会被插入到目标函数的参数列表的开始位置，调用绑定函数时传递给绑定函数的参数会跟在它们的后面。这个附带的应用即是函数式编程中的”柯里化”(currying)的一种（todo:关于柯里化以后再深入研究下）。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">y,z</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.x + y + z;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> baz = fo.bind(&#123;<span class=\"attr\">x</span>:<span class=\"number\">1</span>&#125;,<span class=\"number\">2</span>);</div><div class=\"line\">baz(<span class=\"number\">3</span>);</div></pre></td></tr></table></figure>\n<p> bind方法返回一个函数对象，这个函数对象的length属性是绑定函数的形参个数减去绑定实参个数（length值不能小于0）。</p>\n<ul>\n<li>bind返回的函数被<code>用作构造函数</code>，将忽略传入bind的this,原始函数就会以构造函数的形式调用。bind时传入的实参会原封不动的传入原始函数，调用绑定函数是传入的参数紧跟其后。      </li>\n</ul>\n<h4 id=\"4-new-绑定\"><a href=\"#4-new-绑定\" class=\"headerlink\" title=\"4.new 绑定\"></a>4.new 绑定</h4><p>先看下new 一个构造函数都发生了什么：</p>\n<ul>\n<li>新建一个新对象（继承自Constructor.prototype）</li>\n<li>将构造函数的作用域赋给新对象，因此this指向这个新对象</li>\n<li>执行构造函数内的代码（为这个对象添加属性）</li>\n<li>隐式返回这个对象（如果构造函数内没有显示return 非null对象值）</li>\n</ul>\n<p>很清晰，new 的时候 this绑定到 创建的新对象。通常是返回的那个对象实例。<br>多说一句，起始在js中没有构造函数一说，只有构造调用一说。   </p>\n<h4 id=\"绑定优先级\"><a href=\"#绑定优先级\" class=\"headerlink\" title=\"绑定优先级\"></a>绑定优先级</h4><p>四种绑定规则说完了，那么问题来了，如果有多重规则同时作用时，优先级是怎样的呢？<br>先回顾一下四种规则：</p>\n<ul>\n<li>默认绑定（严格模式、非严格模式）</li>\n<li>隐式绑定（对象属性调用）</li>\n<li>显示绑定（apply/call、bind）</li>\n<li>new 绑定</li>\n</ul>\n<p>直接说结论吧 <br><br>new 绑定 &gt; 显示绑定 &gt; 隐士绑定<br><br>在没有前三种绑定规则的时候就应用默认绑定。</p>\n<p>至此，貌似事件处理函数中的 this还没说。事件处理函数又分DOM2级事件处理函数（addEventListener）;和内联事件处理函数。前者指向绑定事件的DOM可以归到显示绑定吧，只是这一步引擎帮你做了。后者this指向全局对象属于默认绑定，不再赘述。</p>\n<h3 id=\"绑定例外\"><a href=\"#绑定例外\" class=\"headerlink\" title=\"绑定例外\"></a>绑定例外</h3><p>在规则的世界里一切秩序井然，然而世事总有些例外，this绑定也不例外。</p>\n<h4 id=\"被忽略的this\"><a href=\"#被忽略的this\" class=\"headerlink\" title=\"被忽略的this\"></a>被忽略的this</h4><p>当把 null或者undefined作为this的绑定对象传入 call,apply,bind,这些值在调用时会被忽略，实际应用的是默认绑定规则。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</div><div class=\"line\">foo.call(<span class=\"literal\">null</span>);<span class=\"comment\">//2</span></div></pre></td></tr></table></figure></p>\n<p>既然有这个机制，通常他就应该是有用的。那什么时候我们会用到null 、nudefined值呢?<br>当你只想用来传递参数而不关心this的话，这是个不错的选择</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//使用apply(...)来展开一个数组，并当做参数传入一个函数</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">a,b</span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'a:'</span>+a,<span class=\"string\">'b:'</span>+b);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//当然，ES6中我们可以用 ...操作符来代替apply展开数组了</span></div><div class=\"line\"></div><div class=\"line\">foo.apply(<span class=\"literal\">null</span>,[<span class=\"number\">2</span>,<span class=\"number\">3</span>]) <span class=\"comment\">//a:2,b:3</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//使用bind(...)对参数进行柯里化（预设一些参数）</span></div><div class=\"line\"><span class=\"keyword\">var</span> bar = foo.bind(<span class=\"literal\">null</span>,<span class=\"number\">2</span>);</div><div class=\"line\">bar(<span class=\"number\">3</span>);<span class=\"comment\">//a:2,b:3</span></div></pre></td></tr></table></figure>\n<p>至此，this讲解就接近尾声了–还有关于this的最后一点：this词法。</p>\n<h3 id=\"this词法\"><a href=\"#this词法\" class=\"headerlink\" title=\"this词法\"></a>this词法</h3><p> 我们知道javascript使用了词法作用域，但javascript的this机制某种程度上很像动态作用域，因为this的值通常跟函数调用有关，而跟词法作用域无关。<br><br> 事情一直到ES6之前是这样的。ES6箭头函数使得this的值和词法作用域联系起来。</p>\n<ul>\n<li>箭头函数里this值不实用前面的任何规则，而是定义该箭头函数式执行上下文里this的值。</li>\n<li>箭头函数的this绑定无法被修改 (new 也不行)</li>\n</ul>\n<p>又到了举个栗子的时候了：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">a</span>) =&gt;</span> &#123;</div><div class=\"line\">\t\t<span class=\"comment\">//this继承自foo</span></div><div class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;<span class=\"attr\">a</span>:<span class=\"number\">2</span>&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> obj3 = &#123;<span class=\"attr\">a</span>:<span class=\"number\">3</span>&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> bar = foo.call(obj1);</div><div class=\"line\">  bar.call(obj2);<span class=\"comment\">//2</span></div></pre></td></tr></table></figure></p>\n<p>感觉这个箭头函数里的this值似曾相识？是的，在ES6之前，我们就经常使用一种和箭头函数一样的模式。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span>; </div><div class=\"line\">\tsetTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"built_in\">console</span>.log(self.a);</div><div class=\"line\">\t&#125;,<span class=\"number\">100</span>);</div><div class=\"line\">&#125;\t</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> obj = &#123;<span class=\"attr\">a</span>:<span class=\"number\">2</span>&#125;;</div><div class=\"line\">foo.call(obj);<span class=\"comment\">//2</span></div></pre></td></tr></table></figure></p>\n<p>（完）</p>\n<p>关于this的细节就讲完了。this作为执行上下文的一个属性，由于他的规则比较多所以单独拿出来说。关于执行上下文的其他内容甚至更为重要，接下来建议拓展阅读另一篇博文<a href=\"https://foreverwang.github.io/2017/04/09/Javascript%E4%B9%8B%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/\">javascript之执行上下文</a>。<br>私以为搞透执行上下文，是真正理解javascript这门语言的必要条件。</p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><ul>\n<li><a href=\"https://github.com/getify/You-Dont-Know-JS/tree/master/this%20%26%20object%20prototypes\">《你不知道的javascipt》</a></li>\n<li>《javascript权威指南》</li>\n</ul>"},{"layout":"photo","title":"hexo + github pages搭建个人博客","photos":["http://bruce.u.qiniudn.com/2013/11/27/reading/photos-0.jpg"],"_content":"[Hexo官网](https://hexo.io/)\n### hexo报错解决\n\n<!-- more -->\n\n* hexo init  报错  \n\t\n\t ```bash\n\t npm uninstall dtrace-provider \n\t ```\n\n* hero server 报错\n\n\t```bash \n\t  npm install hexo --no-optional\n\t```\n\t通常这个命令能解决，（我这解决不了 就找到报错的地方，看了下这个报错没啥影响就注释掉了，不然强迫症）\n\t\n\t\n### github pages\n\n#### 在github 新建仓库\n仓库命名： username.github.io, 此时就可以访问 username.github.io了\n\n#### github pages 和 hexo 关联\n\n- hexo -g 会生成一个静态网站（第一次会生成一个public目录），这个静态文件可以直接访问。\n- 需要将hexo生成的静态网站，提交(git commit)到github上。\n\n#### 通过hexo 命令将静态站点push到github\n\n* 安装插件hexo-deployer-git\n\n ```bash\n npm install hexo-deployer-git --save\n ```\n\n* 修改 hexo的 _config.yml\n\t\t\n\t```bash\n\tdeploy:\n\t  type: git\n\t  repo: https://github.com/username/username.github.io.git\n\t  branch: master\n\t```\n\t  \n\t  \n#### 更换hexo主题\n* 克隆主题到themes路径下\n\n ```bash \n git clone https://github.com/iissnan/hexo-theme-next themes/next\n ```\n\n\n  注意：主题文件夹放到themes下 文件夹命名和配置文件里保持一致\n\n* 修改站点配置文件 _config.yml\n\n\t```bash \n\ttheme: next\n\t```\n  \n  \n#### hexo添加分类页面\n* 新建分类页\n\t\n\t```bash\n\thexo new page categories\n\t```\n* 在 source/categories 目录的 index.md 中修改:\n\n\t\ttitle: 分类\n\t\tdate: 2015-12-02 12:44:45\n\t\ttype: 'categories'\n\n\t\t \n#### hexo 常用命令\n\n * 新建一篇博客\n \n\t```bash\t\t\n\thexo new filename\n\t```\n\n* 起本地服务\n\t\n\t```bash\t\n\thexo s \n\t```\n\n* 生成静态站点\n\n ```bash  \n   \thexo g\n   \t```\n\t   \n* 发布\n\t\n\t```bash  \t\n\thexo d \n\t```\n\t   \n* 清除本地缓存\n\t\n\t```bash   \n\thexo clean\n\t``` \n\t\n#### 使用技巧\n* git deploy 面用户名和密码提交github \n在github 添加ssh key 公钥后 通过ssh 的方式提交代码\n\n\t```bash\n\tdeploy:\n\t  type: git\n\t  repo: git@github.com:xxx\n\t  branch: master\n\t```\n\n\n\n\n","source":"_posts/hello-hexo.md","raw":"---\nlayout: photo\ntitle:  hexo + github pages搭建个人博客\ncategories: \n- Hexo \ntags: \n- 博客 \n- hexo\n\nphotos:\n- http://bruce.u.qiniudn.com/2013/11/27/reading/photos-0.jpg\n\n---\n[Hexo官网](https://hexo.io/)\n### hexo报错解决\n\n<!-- more -->\n\n* hexo init  报错  \n\t\n\t ```bash\n\t npm uninstall dtrace-provider \n\t ```\n\n* hero server 报错\n\n\t```bash \n\t  npm install hexo --no-optional\n\t```\n\t通常这个命令能解决，（我这解决不了 就找到报错的地方，看了下这个报错没啥影响就注释掉了，不然强迫症）\n\t\n\t\n### github pages\n\n#### 在github 新建仓库\n仓库命名： username.github.io, 此时就可以访问 username.github.io了\n\n#### github pages 和 hexo 关联\n\n- hexo -g 会生成一个静态网站（第一次会生成一个public目录），这个静态文件可以直接访问。\n- 需要将hexo生成的静态网站，提交(git commit)到github上。\n\n#### 通过hexo 命令将静态站点push到github\n\n* 安装插件hexo-deployer-git\n\n ```bash\n npm install hexo-deployer-git --save\n ```\n\n* 修改 hexo的 _config.yml\n\t\t\n\t```bash\n\tdeploy:\n\t  type: git\n\t  repo: https://github.com/username/username.github.io.git\n\t  branch: master\n\t```\n\t  \n\t  \n#### 更换hexo主题\n* 克隆主题到themes路径下\n\n ```bash \n git clone https://github.com/iissnan/hexo-theme-next themes/next\n ```\n\n\n  注意：主题文件夹放到themes下 文件夹命名和配置文件里保持一致\n\n* 修改站点配置文件 _config.yml\n\n\t```bash \n\ttheme: next\n\t```\n  \n  \n#### hexo添加分类页面\n* 新建分类页\n\t\n\t```bash\n\thexo new page categories\n\t```\n* 在 source/categories 目录的 index.md 中修改:\n\n\t\ttitle: 分类\n\t\tdate: 2015-12-02 12:44:45\n\t\ttype: 'categories'\n\n\t\t \n#### hexo 常用命令\n\n * 新建一篇博客\n \n\t```bash\t\t\n\thexo new filename\n\t```\n\n* 起本地服务\n\t\n\t```bash\t\n\thexo s \n\t```\n\n* 生成静态站点\n\n ```bash  \n   \thexo g\n   \t```\n\t   \n* 发布\n\t\n\t```bash  \t\n\thexo d \n\t```\n\t   \n* 清除本地缓存\n\t\n\t```bash   \n\thexo clean\n\t``` \n\t\n#### 使用技巧\n* git deploy 面用户名和密码提交github \n在github 添加ssh key 公钥后 通过ssh 的方式提交代码\n\n\t```bash\n\tdeploy:\n\t  type: git\n\t  repo: git@github.com:xxx\n\t  branch: master\n\t```\n\n\n\n\n","slug":"hello-hexo","published":1,"date":"2018-03-10T16:05:26.000Z","updated":"2018-03-10T17:43:32.000Z","comments":1,"link":"","_id":"cjelnshck00053gffub27v4r5","content":"<p><a href=\"https://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo官网</a></p>\n<h3 id=\"hexo报错解决\"><a href=\"#hexo报错解决\" class=\"headerlink\" title=\"hexo报错解决\"></a>hexo报错解决</h3><a id=\"more\"></a>\n<ul>\n<li><p>hexo init  报错  </p>\n   <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm uninstall dtrace-provider</div></pre></td></tr></table></figure>\n</li>\n<li><p>hero server 报错</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install hexo --no-optional</div></pre></td></tr></table></figure>\n<p>  通常这个命令能解决，（我这解决不了 就找到报错的地方，看了下这个报错没啥影响就注释掉了，不然强迫症）</p>\n</li>\n</ul>\n<h3 id=\"github-pages\"><a href=\"#github-pages\" class=\"headerlink\" title=\"github pages\"></a>github pages</h3><h4 id=\"在github-新建仓库\"><a href=\"#在github-新建仓库\" class=\"headerlink\" title=\"在github 新建仓库\"></a>在github 新建仓库</h4><p>仓库命名： username.github.io, 此时就可以访问 username.github.io了</p>\n<h4 id=\"github-pages-和-hexo-关联\"><a href=\"#github-pages-和-hexo-关联\" class=\"headerlink\" title=\"github pages 和 hexo 关联\"></a>github pages 和 hexo 关联</h4><ul>\n<li>hexo -g 会生成一个静态网站（第一次会生成一个public目录），这个静态文件可以直接访问。</li>\n<li>需要将hexo生成的静态网站，提交(git commit)到github上。</li>\n</ul>\n<h4 id=\"通过hexo-命令将静态站点push到github\"><a href=\"#通过hexo-命令将静态站点push到github\" class=\"headerlink\" title=\"通过hexo 命令将静态站点push到github\"></a>通过hexo 命令将静态站点push到github</h4><ul>\n<li><p>安装插件hexo-deployer-git</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install hexo-deployer-git --save</div></pre></td></tr></table></figure>\n</li>\n<li><p>修改 hexo的 _config.yml</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">deploy:</div><div class=\"line\">  <span class=\"built_in\">type</span>: git</div><div class=\"line\">  repo: https://github.com/username/username.github.io.git</div><div class=\"line\">  branch: master</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"更换hexo主题\"><a href=\"#更换hexo主题\" class=\"headerlink\" title=\"更换hexo主题\"></a>更换hexo主题</h4><ul>\n<li><p>克隆主题到themes路径下</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</div></pre></td></tr></table></figure>\n<p>注意：主题文件夹放到themes下 文件夹命名和配置文件里保持一致</p>\n</li>\n<li><p>修改站点配置文件 _config.yml</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">theme: next</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"hexo添加分类页面\"><a href=\"#hexo添加分类页面\" class=\"headerlink\" title=\"hexo添加分类页面\"></a>hexo添加分类页面</h4><ul>\n<li><p>新建分类页</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo new page categories</div></pre></td></tr></table></figure>\n</li>\n<li><p>在 source/categories 目录的 index.md 中修改:</p>\n<pre><code>title: 分类\ndate: 2015-12-02 12:44:45\ntype: &apos;categories&apos;\n</code></pre></li>\n</ul>\n<h4 id=\"hexo-常用命令\"><a href=\"#hexo-常用命令\" class=\"headerlink\" title=\"hexo 常用命令\"></a>hexo 常用命令</h4><ul>\n<li><p>新建一篇博客</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo new filename</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>起本地服务</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo s</div></pre></td></tr></table></figure>\n</li>\n<li><p>生成静态站点</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo g</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>发布</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo d</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>清除本地缓存</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">\thexo clean</div><div class=\"line\">\t``` </div><div class=\"line\">\t</div><div class=\"line\"><span class=\"comment\">#### 使用技巧</span></div><div class=\"line\">* git deploy 面用户名和密码提交github </div><div class=\"line\">在github 添加ssh key 公钥后 通过ssh 的方式提交代码</div><div class=\"line\"></div><div class=\"line\">\t```bash</div><div class=\"line\">\tdeploy:</div><div class=\"line\">\t  <span class=\"built_in\">type</span>: git</div><div class=\"line\">\t  repo: git@github.com:xxx</div><div class=\"line\">\t  branch: master</div></pre></td></tr></table></figure>\n</li>\n</ul>\n","excerpt":"<p><a href=\"https://hexo.io/\">Hexo官网</a></p>\n<h3 id=\"hexo报错解决\"><a href=\"#hexo报错解决\" class=\"headerlink\" title=\"hexo报错解决\"></a>hexo报错解决</h3>","more":"<ul>\n<li><p>hexo init  报错  </p>\n   <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm uninstall dtrace-provider</div></pre></td></tr></table></figure>\n</li>\n<li><p>hero server 报错</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install hexo --no-optional</div></pre></td></tr></table></figure>\n<p>  通常这个命令能解决，（我这解决不了 就找到报错的地方，看了下这个报错没啥影响就注释掉了，不然强迫症）</p>\n</li>\n</ul>\n<h3 id=\"github-pages\"><a href=\"#github-pages\" class=\"headerlink\" title=\"github pages\"></a>github pages</h3><h4 id=\"在github-新建仓库\"><a href=\"#在github-新建仓库\" class=\"headerlink\" title=\"在github 新建仓库\"></a>在github 新建仓库</h4><p>仓库命名： username.github.io, 此时就可以访问 username.github.io了</p>\n<h4 id=\"github-pages-和-hexo-关联\"><a href=\"#github-pages-和-hexo-关联\" class=\"headerlink\" title=\"github pages 和 hexo 关联\"></a>github pages 和 hexo 关联</h4><ul>\n<li>hexo -g 会生成一个静态网站（第一次会生成一个public目录），这个静态文件可以直接访问。</li>\n<li>需要将hexo生成的静态网站，提交(git commit)到github上。</li>\n</ul>\n<h4 id=\"通过hexo-命令将静态站点push到github\"><a href=\"#通过hexo-命令将静态站点push到github\" class=\"headerlink\" title=\"通过hexo 命令将静态站点push到github\"></a>通过hexo 命令将静态站点push到github</h4><ul>\n<li><p>安装插件hexo-deployer-git</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install hexo-deployer-git --save</div></pre></td></tr></table></figure>\n</li>\n<li><p>修改 hexo的 _config.yml</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">deploy:</div><div class=\"line\">  <span class=\"built_in\">type</span>: git</div><div class=\"line\">  repo: https://github.com/username/username.github.io.git</div><div class=\"line\">  branch: master</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"更换hexo主题\"><a href=\"#更换hexo主题\" class=\"headerlink\" title=\"更换hexo主题\"></a>更换hexo主题</h4><ul>\n<li><p>克隆主题到themes路径下</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</div></pre></td></tr></table></figure>\n<p>注意：主题文件夹放到themes下 文件夹命名和配置文件里保持一致</p>\n</li>\n<li><p>修改站点配置文件 _config.yml</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">theme: next</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"hexo添加分类页面\"><a href=\"#hexo添加分类页面\" class=\"headerlink\" title=\"hexo添加分类页面\"></a>hexo添加分类页面</h4><ul>\n<li><p>新建分类页</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo new page categories</div></pre></td></tr></table></figure>\n</li>\n<li><p>在 source/categories 目录的 index.md 中修改:</p>\n<pre><code>title: 分类\ndate: 2015-12-02 12:44:45\ntype: &apos;categories&apos;\n</code></pre></li>\n</ul>\n<h4 id=\"hexo-常用命令\"><a href=\"#hexo-常用命令\" class=\"headerlink\" title=\"hexo 常用命令\"></a>hexo 常用命令</h4><ul>\n<li><p>新建一篇博客</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo new filename</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>起本地服务</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo s</div></pre></td></tr></table></figure>\n</li>\n<li><p>生成静态站点</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo g</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>发布</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo d</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>清除本地缓存</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">\thexo clean</div><div class=\"line\">\t``` </div><div class=\"line\">\t</div><div class=\"line\"><span class=\"comment\">#### 使用技巧</span></div><div class=\"line\">* git deploy 面用户名和密码提交github </div><div class=\"line\">在github 添加ssh key 公钥后 通过ssh 的方式提交代码</div><div class=\"line\"></div><div class=\"line\">\t```bash</div><div class=\"line\">\tdeploy:</div><div class=\"line\">\t  <span class=\"built_in\">type</span>: git</div><div class=\"line\">\t  repo: git@github.com:xxx</div><div class=\"line\">\t  branch: master</div></pre></td></tr></table></figure>\n</li>\n</ul>"},{"title":"javascript函数节流（throttle）和函数防抖（debounce）及其实现","date":"2017-05-07T15:37:39.000Z","_content":"\n\n\nthrottle(节流)和debounce(防抖)说来很相似：作用是防止一个函数内的某些代码在一定的时间间隔内高频率调用。当然两者也是有细微差别的，下面分别看下这两个概念。\n<!-- more -->\n#### 使用场景\n当遇到触发频率很高的事件时，其事件回调也会随之高频率的被调用，这样就可能会出现页面卡顿现象，为了解决这类问题，通常使用throttle(节流)或debounce(防抖)来控制事件回调主要逻辑代码被执行的频率。这些事件需要包括：\n\n* 鼠标事件：mousemove(拖曳)/mouseover(划过)/mouseWheel(滚屏) click(连续点击)\n* 键盘事件：keypress(基于ajax的用户名唯一性校验)/keyup(文本输入检验、自动完成)/keydown(游戏中的射击)\n* window的resize/scroll事件(DOM元素动态定位)\n\n接下来看看具体概念和区别。\n \n#### 概念及区别\n函数在一定的`时间间隔`内只能被调用一次：\n\n*  debounce \n\n > 若在这段时间间隔内又想要调用函数，则将`重新计算`时间间隔。\n\n*  throttle\n    > 若在这段时间间隔内又想调用该函数，则函数调用将会被提前阻止从而放弃这次调用。\n    \n 直到上一次调用函数后的时间间隔过后，下一次企图调用函数才能得逞。 \n> 注意：上面是说的是函数调用的频率，具体到业务里代码里可能不是具体某个函数而是函数内某些代码。\n\n#### 打个比方\n如果上面的区别还是不太明了，那我们举个电梯的栗子吧：\n假设电梯门在有人进入10s后会关闭，我们简称这一过程为--`关门指令`。每次有人键入电梯，电梯就`企图`创建一个`关门指令`。\n\n* deboucce \n    \n    > 你进入电梯，一个`关门指令`被电梯创建；如果10s内又有人进入电梯，则这个10s的间隔会重新计算-相当于销毁上一个关门指令，重新创建一个；直到最后一个10s的间隔内没有人再进入了，电梯门才会被关闭，即最后一个关门指令生效。\n    \n* throttle\n    \n    > 你进入电梯，一个`关门指令`被电梯创建；如果10s内又有人进入电梯，则这段间隔内企图`10s后再关门`这个指令会被丢弃，即10s内只有第一个关门指令会生效。10s后不管还有么有人向上电梯，电梯门都将关闭。--这种电梯简直是反人类，大概只会出现在我这个例子里。\n    \n   概念说了，比方也打了，接下来我们一步一步实现deboucce和throttle。\n  \n  > 再多说一句，其实你也不必非要严格区分这两个概念。你只要知道他俩都是用来避免连续高频触发一些代码的执行的。他俩的区别是debouce在指定的间隔内再次试图触发某些代码执行的时候 这个时间间隔会被重新计算，而throttle不会。然后能在具体的场景选择响应的方法就好了。\n\n#### 具体实现\n这一部分我们通过一个实际场景一步一步分析来实现。<br>\n假设的场景：页面中有一个按钮，这个按钮点击后会执行页面跳转的动作。此时我们不希望快速点击会触发多次这个动作。\n\n分析：\n\n* 因为页面跳转后通常我们是没有回调即收不到通知的，所以这里防止连续点击触发回调只能通过约定时间间隔来实现，这里我们用600ms作为这个时间间隔。\n* 点击按钮后600ms内的点击无效。\n* 这个事件间隔可以通过标志变量+setTimeout来实现；也可以通过前后点击的时间戳的差值来实现。这里我们先用第一种方式。\n\n```html\n        <div class=\"btn\">我是一个按钮</div>\n```\n\n下面是只考虑实现上述需求，没有任何封装性。  \n\n``` javascript\n        var btn  = document.querySelector('.btn');\n        //方案一：时间间隔:标志变量 + setTimeout\n        var canRun = true; //标志变量\n        var immediate = true;//第一次响应时是否需要执行响应的代码\n        btn.onclick = function(){\n            if(!canRun){\n                console.log('点击太频繁');\n                return;\n            }\n            //只要函数被执行了就把标志变量的状态置反，直到约定的时间间隔到了再置回。\n            canRun = false;\n           \n            function handler(){\n                console.log('click');\n                canRun = true;\n            }\n            \n            if(immediate){\n                handler();//第一次调用\n                console.log('首次立即调用');\n                immediate = false;\n            }else{\n                setTimeout(handler,600);\n            }\n        }\n```\n        \n* 标志变量canRun 初始值true;当click事件回调执行时先判断这个变量，如果为真则后面的代码会被执行。并且 标志变量canRun赋值为false;\n* 后边的代码包括 根据immediate标志位（初始值true）是否立即调用handler；immediate为假则开一个定时器600ms后调用handler，handler会把标志变量置位true;\n* 在上一次点击后的600ms内再次点击这时候canRun 为false，函数会直接返回，后边的代码不会被执行。\n\n功能很简单，上面就是实现了函数节流（throttle）的功能。加下来我们将throttle抽象一下封装成可供外部调用的throttle方法。\n\n#### throttle实现\n分析：我们要实现的throttle方法只负责 是否能执行某些代码的逻辑实现。时间间隔、要执行的函数、是否立即执行 这些都是使用方决定的，即这些作为throttle方法的参数传入。\n``` javascript\n        function throlle(handler,delay,immediate){\n            var canRun = true;\n            return function(){\n                if(!canRun){\n                   return;\n                }\n                canRun = false;\n                if(immediate){\n                   handler();\n                   immediate = false;\n                   setTimeout(function(){\n                   canRun = true;\n                }, delay);\n                }else{\n                    setTimeout(function(){\n                       handler();  //todo:参数传递\n                       canRun = true;\n                    }, delay);\n                }\n                \n            }\n        }\n```\n#### debounce实现\n分析：让我们回一下debounce和throttle的区别：debounce事件间隔会被重新计时，及在非空闲期内触发了回调,回调内会把定时器clear掉，重新创建一个定时器，事件间隔也即随之重新计算了。\n``` javascript\n        function debounce(handler,delay,immediate){\n            var canRun = true;\n            var timer = null;\n            return function(){\n                if(!canRun){\n                   clearTimeout(timer); //唯一的区别就在这里\n                }\n                canRun = false;\n                if(immediate){\n                   handler();\n                   immediate = false;\n                   setTimeout(function(){\n                   canRun = true;\n                }, delay);\n                }else{\n                    timer = setTimeout(function(){\n                       handler();  //todo:参数传递\n                       canRun = true;\n                    }, delay);\n                }\n            }\n        }\n```\n    \n以上也只是一个简单的实现，还有些可以优化的地方。\n除了用setTimeout来控制时间间隔，亦可以通过时间戳来实现：即比较前后两次出发的时间出之差是否大于阈值。","source":"_posts/javascript函数节流(throttle)和函数防抖(debounce)及其实现.md","raw":"---\ntitle: javascript函数节流（throttle）和函数防抖（debounce）及其实现\ndate: 2017-05-07 23:37:39\ncategories: \n- javascript \ntags: \n- 函数节流（throttle）\n- 函数防抖（debounce）\n---\n\n\n\nthrottle(节流)和debounce(防抖)说来很相似：作用是防止一个函数内的某些代码在一定的时间间隔内高频率调用。当然两者也是有细微差别的，下面分别看下这两个概念。\n<!-- more -->\n#### 使用场景\n当遇到触发频率很高的事件时，其事件回调也会随之高频率的被调用，这样就可能会出现页面卡顿现象，为了解决这类问题，通常使用throttle(节流)或debounce(防抖)来控制事件回调主要逻辑代码被执行的频率。这些事件需要包括：\n\n* 鼠标事件：mousemove(拖曳)/mouseover(划过)/mouseWheel(滚屏) click(连续点击)\n* 键盘事件：keypress(基于ajax的用户名唯一性校验)/keyup(文本输入检验、自动完成)/keydown(游戏中的射击)\n* window的resize/scroll事件(DOM元素动态定位)\n\n接下来看看具体概念和区别。\n \n#### 概念及区别\n函数在一定的`时间间隔`内只能被调用一次：\n\n*  debounce \n\n > 若在这段时间间隔内又想要调用函数，则将`重新计算`时间间隔。\n\n*  throttle\n    > 若在这段时间间隔内又想调用该函数，则函数调用将会被提前阻止从而放弃这次调用。\n    \n 直到上一次调用函数后的时间间隔过后，下一次企图调用函数才能得逞。 \n> 注意：上面是说的是函数调用的频率，具体到业务里代码里可能不是具体某个函数而是函数内某些代码。\n\n#### 打个比方\n如果上面的区别还是不太明了，那我们举个电梯的栗子吧：\n假设电梯门在有人进入10s后会关闭，我们简称这一过程为--`关门指令`。每次有人键入电梯，电梯就`企图`创建一个`关门指令`。\n\n* deboucce \n    \n    > 你进入电梯，一个`关门指令`被电梯创建；如果10s内又有人进入电梯，则这个10s的间隔会重新计算-相当于销毁上一个关门指令，重新创建一个；直到最后一个10s的间隔内没有人再进入了，电梯门才会被关闭，即最后一个关门指令生效。\n    \n* throttle\n    \n    > 你进入电梯，一个`关门指令`被电梯创建；如果10s内又有人进入电梯，则这段间隔内企图`10s后再关门`这个指令会被丢弃，即10s内只有第一个关门指令会生效。10s后不管还有么有人向上电梯，电梯门都将关闭。--这种电梯简直是反人类，大概只会出现在我这个例子里。\n    \n   概念说了，比方也打了，接下来我们一步一步实现deboucce和throttle。\n  \n  > 再多说一句，其实你也不必非要严格区分这两个概念。你只要知道他俩都是用来避免连续高频触发一些代码的执行的。他俩的区别是debouce在指定的间隔内再次试图触发某些代码执行的时候 这个时间间隔会被重新计算，而throttle不会。然后能在具体的场景选择响应的方法就好了。\n\n#### 具体实现\n这一部分我们通过一个实际场景一步一步分析来实现。<br>\n假设的场景：页面中有一个按钮，这个按钮点击后会执行页面跳转的动作。此时我们不希望快速点击会触发多次这个动作。\n\n分析：\n\n* 因为页面跳转后通常我们是没有回调即收不到通知的，所以这里防止连续点击触发回调只能通过约定时间间隔来实现，这里我们用600ms作为这个时间间隔。\n* 点击按钮后600ms内的点击无效。\n* 这个事件间隔可以通过标志变量+setTimeout来实现；也可以通过前后点击的时间戳的差值来实现。这里我们先用第一种方式。\n\n```html\n        <div class=\"btn\">我是一个按钮</div>\n```\n\n下面是只考虑实现上述需求，没有任何封装性。  \n\n``` javascript\n        var btn  = document.querySelector('.btn');\n        //方案一：时间间隔:标志变量 + setTimeout\n        var canRun = true; //标志变量\n        var immediate = true;//第一次响应时是否需要执行响应的代码\n        btn.onclick = function(){\n            if(!canRun){\n                console.log('点击太频繁');\n                return;\n            }\n            //只要函数被执行了就把标志变量的状态置反，直到约定的时间间隔到了再置回。\n            canRun = false;\n           \n            function handler(){\n                console.log('click');\n                canRun = true;\n            }\n            \n            if(immediate){\n                handler();//第一次调用\n                console.log('首次立即调用');\n                immediate = false;\n            }else{\n                setTimeout(handler,600);\n            }\n        }\n```\n        \n* 标志变量canRun 初始值true;当click事件回调执行时先判断这个变量，如果为真则后面的代码会被执行。并且 标志变量canRun赋值为false;\n* 后边的代码包括 根据immediate标志位（初始值true）是否立即调用handler；immediate为假则开一个定时器600ms后调用handler，handler会把标志变量置位true;\n* 在上一次点击后的600ms内再次点击这时候canRun 为false，函数会直接返回，后边的代码不会被执行。\n\n功能很简单，上面就是实现了函数节流（throttle）的功能。加下来我们将throttle抽象一下封装成可供外部调用的throttle方法。\n\n#### throttle实现\n分析：我们要实现的throttle方法只负责 是否能执行某些代码的逻辑实现。时间间隔、要执行的函数、是否立即执行 这些都是使用方决定的，即这些作为throttle方法的参数传入。\n``` javascript\n        function throlle(handler,delay,immediate){\n            var canRun = true;\n            return function(){\n                if(!canRun){\n                   return;\n                }\n                canRun = false;\n                if(immediate){\n                   handler();\n                   immediate = false;\n                   setTimeout(function(){\n                   canRun = true;\n                }, delay);\n                }else{\n                    setTimeout(function(){\n                       handler();  //todo:参数传递\n                       canRun = true;\n                    }, delay);\n                }\n                \n            }\n        }\n```\n#### debounce实现\n分析：让我们回一下debounce和throttle的区别：debounce事件间隔会被重新计时，及在非空闲期内触发了回调,回调内会把定时器clear掉，重新创建一个定时器，事件间隔也即随之重新计算了。\n``` javascript\n        function debounce(handler,delay,immediate){\n            var canRun = true;\n            var timer = null;\n            return function(){\n                if(!canRun){\n                   clearTimeout(timer); //唯一的区别就在这里\n                }\n                canRun = false;\n                if(immediate){\n                   handler();\n                   immediate = false;\n                   setTimeout(function(){\n                   canRun = true;\n                }, delay);\n                }else{\n                    timer = setTimeout(function(){\n                       handler();  //todo:参数传递\n                       canRun = true;\n                    }, delay);\n                }\n            }\n        }\n```\n    \n以上也只是一个简单的实现，还有些可以优化的地方。\n除了用setTimeout来控制时间间隔，亦可以通过时间戳来实现：即比较前后两次出发的时间出之差是否大于阈值。","slug":"javascript函数节流(throttle)和函数防抖(debounce)及其实现","published":1,"updated":"2018-03-10T16:05:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjelnshcn00063gfffcept66t","content":"<p>throttle(节流)和debounce(防抖)说来很相似：作用是防止一个函数内的某些代码在一定的时间间隔内高频率调用。当然两者也是有细微差别的，下面分别看下这两个概念。<br><a id=\"more\"></a></p>\n<h4 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h4><p>当遇到触发频率很高的事件时，其事件回调也会随之高频率的被调用，这样就可能会出现页面卡顿现象，为了解决这类问题，通常使用throttle(节流)或debounce(防抖)来控制事件回调主要逻辑代码被执行的频率。这些事件需要包括：</p>\n<ul>\n<li>鼠标事件：mousemove(拖曳)/mouseover(划过)/mouseWheel(滚屏) click(连续点击)</li>\n<li>键盘事件：keypress(基于ajax的用户名唯一性校验)/keyup(文本输入检验、自动完成)/keydown(游戏中的射击)</li>\n<li>window的resize/scroll事件(DOM元素动态定位)</li>\n</ul>\n<p>接下来看看具体概念和区别。</p>\n<h4 id=\"概念及区别\"><a href=\"#概念及区别\" class=\"headerlink\" title=\"概念及区别\"></a>概念及区别</h4><p>函数在一定的<code>时间间隔</code>内只能被调用一次：</p>\n<ul>\n<li><p>debounce </p>\n<blockquote>\n<p>若在这段时间间隔内又想要调用函数，则将<code>重新计算</code>时间间隔。</p>\n</blockquote>\n</li>\n<li><p>throttle</p>\n<blockquote>\n<p>若在这段时间间隔内又想调用该函数，则函数调用将会被提前阻止从而放弃这次调用。</p>\n</blockquote>\n<p>直到上一次调用函数后的时间间隔过后，下一次企图调用函数才能得逞。 </p>\n<blockquote>\n<p>注意：上面是说的是函数调用的频率，具体到业务里代码里可能不是具体某个函数而是函数内某些代码。</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"打个比方\"><a href=\"#打个比方\" class=\"headerlink\" title=\"打个比方\"></a>打个比方</h4><p>如果上面的区别还是不太明了，那我们举个电梯的栗子吧：<br>假设电梯门在有人进入10s后会关闭，我们简称这一过程为–<code>关门指令</code>。每次有人键入电梯，电梯就<code>企图</code>创建一个<code>关门指令</code>。</p>\n<ul>\n<li><p>deboucce </p>\n<blockquote>\n<p>你进入电梯，一个<code>关门指令</code>被电梯创建；如果10s内又有人进入电梯，则这个10s的间隔会重新计算-相当于销毁上一个关门指令，重新创建一个；直到最后一个10s的间隔内没有人再进入了，电梯门才会被关闭，即最后一个关门指令生效。</p>\n</blockquote>\n</li>\n<li><p>throttle</p>\n<blockquote>\n<p>你进入电梯，一个<code>关门指令</code>被电梯创建；如果10s内又有人进入电梯，则这段间隔内企图<code>10s后再关门</code>这个指令会被丢弃，即10s内只有第一个关门指令会生效。10s后不管还有么有人向上电梯，电梯门都将关闭。–这种电梯简直是反人类，大概只会出现在我这个例子里。</p>\n</blockquote>\n<p> 概念说了，比方也打了，接下来我们一步一步实现deboucce和throttle。</p>\n<blockquote>\n<p>再多说一句，其实你也不必非要严格区分这两个概念。你只要知道他俩都是用来避免连续高频触发一些代码的执行的。他俩的区别是debouce在指定的间隔内再次试图触发某些代码执行的时候 这个时间间隔会被重新计算，而throttle不会。然后能在具体的场景选择响应的方法就好了。</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"具体实现\"><a href=\"#具体实现\" class=\"headerlink\" title=\"具体实现\"></a>具体实现</h4><p>这一部分我们通过一个实际场景一步一步分析来实现。<br><br>假设的场景：页面中有一个按钮，这个按钮点击后会执行页面跳转的动作。此时我们不希望快速点击会触发多次这个动作。</p>\n<p>分析：</p>\n<ul>\n<li>因为页面跳转后通常我们是没有回调即收不到通知的，所以这里防止连续点击触发回调只能通过约定时间间隔来实现，这里我们用600ms作为这个时间间隔。</li>\n<li>点击按钮后600ms内的点击无效。</li>\n<li>这个事件间隔可以通过标志变量+setTimeout来实现；也可以通过前后点击的时间戳的差值来实现。这里我们先用第一种方式。</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"btn\"</span>&gt;</span>我是一个按钮<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>下面是只考虑实现上述需求，没有任何封装性。  </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> btn  = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'.btn'</span>);</div><div class=\"line\"><span class=\"comment\">//方案一：时间间隔:标志变量 + setTimeout</span></div><div class=\"line\"><span class=\"keyword\">var</span> canRun = <span class=\"literal\">true</span>; <span class=\"comment\">//标志变量</span></div><div class=\"line\"><span class=\"keyword\">var</span> immediate = <span class=\"literal\">true</span>;<span class=\"comment\">//第一次响应时是否需要执行响应的代码</span></div><div class=\"line\">btn.onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(!canRun)&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'点击太频繁'</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//只要函数被执行了就把标志变量的状态置反，直到约定的时间间隔到了再置回。</span></div><div class=\"line\">    canRun = <span class=\"literal\">false</span>;</div><div class=\"line\">   </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handler</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'click'</span>);</div><div class=\"line\">        canRun = <span class=\"literal\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">if</span>(immediate)&#123;</div><div class=\"line\">        handler();<span class=\"comment\">//第一次调用</span></div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'首次立即调用'</span>);</div><div class=\"line\">        immediate = <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">        setTimeout(handler,<span class=\"number\">600</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>标志变量canRun 初始值true;当click事件回调执行时先判断这个变量，如果为真则后面的代码会被执行。并且 标志变量canRun赋值为false;</li>\n<li>后边的代码包括 根据immediate标志位（初始值true）是否立即调用handler；immediate为假则开一个定时器600ms后调用handler，handler会把标志变量置位true;</li>\n<li>在上一次点击后的600ms内再次点击这时候canRun 为false，函数会直接返回，后边的代码不会被执行。</li>\n</ul>\n<p>功能很简单，上面就是实现了函数节流（throttle）的功能。加下来我们将throttle抽象一下封装成可供外部调用的throttle方法。</p>\n<h4 id=\"throttle实现\"><a href=\"#throttle实现\" class=\"headerlink\" title=\"throttle实现\"></a>throttle实现</h4><p>分析：我们要实现的throttle方法只负责 是否能执行某些代码的逻辑实现。时间间隔、要执行的函数、是否立即执行 这些都是使用方决定的，即这些作为throttle方法的参数传入。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">throlle</span>(<span class=\"params\">handler,delay,immediate</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> canRun = <span class=\"literal\">true</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(!canRun)&#123;</div><div class=\"line\">           <span class=\"keyword\">return</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        canRun = <span class=\"literal\">false</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span>(immediate)&#123;</div><div class=\"line\">           handler();</div><div class=\"line\">           immediate = <span class=\"literal\">false</span>;</div><div class=\"line\">           setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">           canRun = <span class=\"literal\">true</span>;</div><div class=\"line\">        &#125;, delay);</div><div class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">            setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">               handler();  <span class=\"comment\">//todo:参数传递</span></div><div class=\"line\">               canRun = <span class=\"literal\">true</span>;</div><div class=\"line\">            &#125;, delay);</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"debounce实现\"><a href=\"#debounce实现\" class=\"headerlink\" title=\"debounce实现\"></a>debounce实现</h4><p>分析：让我们回一下debounce和throttle的区别：debounce事件间隔会被重新计时，及在非空闲期内触发了回调,回调内会把定时器clear掉，重新创建一个定时器，事件间隔也即随之重新计算了。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">debounce</span>(<span class=\"params\">handler,delay,immediate</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> canRun = <span class=\"literal\">true</span>;</div><div class=\"line\">    <span class=\"keyword\">var</span> timer = <span class=\"literal\">null</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(!canRun)&#123;</div><div class=\"line\">           clearTimeout(timer); <span class=\"comment\">//唯一的区别就在这里</span></div><div class=\"line\">        &#125;</div><div class=\"line\">        canRun = <span class=\"literal\">false</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span>(immediate)&#123;</div><div class=\"line\">           handler();</div><div class=\"line\">           immediate = <span class=\"literal\">false</span>;</div><div class=\"line\">           setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">           canRun = <span class=\"literal\">true</span>;</div><div class=\"line\">        &#125;, delay);</div><div class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">            timer = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">               handler();  <span class=\"comment\">//todo:参数传递</span></div><div class=\"line\">               canRun = <span class=\"literal\">true</span>;</div><div class=\"line\">            &#125;, delay);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>以上也只是一个简单的实现，还有些可以优化的地方。<br>除了用setTimeout来控制时间间隔，亦可以通过时间戳来实现：即比较前后两次出发的时间出之差是否大于阈值。</p>\n","excerpt":"<p>throttle(节流)和debounce(防抖)说来很相似：作用是防止一个函数内的某些代码在一定的时间间隔内高频率调用。当然两者也是有细微差别的，下面分别看下这两个概念。<br>","more":"</p>\n<h4 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h4><p>当遇到触发频率很高的事件时，其事件回调也会随之高频率的被调用，这样就可能会出现页面卡顿现象，为了解决这类问题，通常使用throttle(节流)或debounce(防抖)来控制事件回调主要逻辑代码被执行的频率。这些事件需要包括：</p>\n<ul>\n<li>鼠标事件：mousemove(拖曳)/mouseover(划过)/mouseWheel(滚屏) click(连续点击)</li>\n<li>键盘事件：keypress(基于ajax的用户名唯一性校验)/keyup(文本输入检验、自动完成)/keydown(游戏中的射击)</li>\n<li>window的resize/scroll事件(DOM元素动态定位)</li>\n</ul>\n<p>接下来看看具体概念和区别。</p>\n<h4 id=\"概念及区别\"><a href=\"#概念及区别\" class=\"headerlink\" title=\"概念及区别\"></a>概念及区别</h4><p>函数在一定的<code>时间间隔</code>内只能被调用一次：</p>\n<ul>\n<li><p>debounce </p>\n<blockquote>\n<p>若在这段时间间隔内又想要调用函数，则将<code>重新计算</code>时间间隔。</p>\n</blockquote>\n</li>\n<li><p>throttle</p>\n<blockquote>\n<p>若在这段时间间隔内又想调用该函数，则函数调用将会被提前阻止从而放弃这次调用。</p>\n</blockquote>\n<p>直到上一次调用函数后的时间间隔过后，下一次企图调用函数才能得逞。 </p>\n<blockquote>\n<p>注意：上面是说的是函数调用的频率，具体到业务里代码里可能不是具体某个函数而是函数内某些代码。</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"打个比方\"><a href=\"#打个比方\" class=\"headerlink\" title=\"打个比方\"></a>打个比方</h4><p>如果上面的区别还是不太明了，那我们举个电梯的栗子吧：<br>假设电梯门在有人进入10s后会关闭，我们简称这一过程为–<code>关门指令</code>。每次有人键入电梯，电梯就<code>企图</code>创建一个<code>关门指令</code>。</p>\n<ul>\n<li><p>deboucce </p>\n<blockquote>\n<p>你进入电梯，一个<code>关门指令</code>被电梯创建；如果10s内又有人进入电梯，则这个10s的间隔会重新计算-相当于销毁上一个关门指令，重新创建一个；直到最后一个10s的间隔内没有人再进入了，电梯门才会被关闭，即最后一个关门指令生效。</p>\n</blockquote>\n</li>\n<li><p>throttle</p>\n<blockquote>\n<p>你进入电梯，一个<code>关门指令</code>被电梯创建；如果10s内又有人进入电梯，则这段间隔内企图<code>10s后再关门</code>这个指令会被丢弃，即10s内只有第一个关门指令会生效。10s后不管还有么有人向上电梯，电梯门都将关闭。–这种电梯简直是反人类，大概只会出现在我这个例子里。</p>\n</blockquote>\n<p> 概念说了，比方也打了，接下来我们一步一步实现deboucce和throttle。</p>\n<blockquote>\n<p>再多说一句，其实你也不必非要严格区分这两个概念。你只要知道他俩都是用来避免连续高频触发一些代码的执行的。他俩的区别是debouce在指定的间隔内再次试图触发某些代码执行的时候 这个时间间隔会被重新计算，而throttle不会。然后能在具体的场景选择响应的方法就好了。</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"具体实现\"><a href=\"#具体实现\" class=\"headerlink\" title=\"具体实现\"></a>具体实现</h4><p>这一部分我们通过一个实际场景一步一步分析来实现。<br><br>假设的场景：页面中有一个按钮，这个按钮点击后会执行页面跳转的动作。此时我们不希望快速点击会触发多次这个动作。</p>\n<p>分析：</p>\n<ul>\n<li>因为页面跳转后通常我们是没有回调即收不到通知的，所以这里防止连续点击触发回调只能通过约定时间间隔来实现，这里我们用600ms作为这个时间间隔。</li>\n<li>点击按钮后600ms内的点击无效。</li>\n<li>这个事件间隔可以通过标志变量+setTimeout来实现；也可以通过前后点击的时间戳的差值来实现。这里我们先用第一种方式。</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"btn\"</span>&gt;</span>我是一个按钮<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>下面是只考虑实现上述需求，没有任何封装性。  </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> btn  = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'.btn'</span>);</div><div class=\"line\"><span class=\"comment\">//方案一：时间间隔:标志变量 + setTimeout</span></div><div class=\"line\"><span class=\"keyword\">var</span> canRun = <span class=\"literal\">true</span>; <span class=\"comment\">//标志变量</span></div><div class=\"line\"><span class=\"keyword\">var</span> immediate = <span class=\"literal\">true</span>;<span class=\"comment\">//第一次响应时是否需要执行响应的代码</span></div><div class=\"line\">btn.onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(!canRun)&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'点击太频繁'</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//只要函数被执行了就把标志变量的状态置反，直到约定的时间间隔到了再置回。</span></div><div class=\"line\">    canRun = <span class=\"literal\">false</span>;</div><div class=\"line\">   </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handler</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'click'</span>);</div><div class=\"line\">        canRun = <span class=\"literal\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">if</span>(immediate)&#123;</div><div class=\"line\">        handler();<span class=\"comment\">//第一次调用</span></div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'首次立即调用'</span>);</div><div class=\"line\">        immediate = <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">        setTimeout(handler,<span class=\"number\">600</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>标志变量canRun 初始值true;当click事件回调执行时先判断这个变量，如果为真则后面的代码会被执行。并且 标志变量canRun赋值为false;</li>\n<li>后边的代码包括 根据immediate标志位（初始值true）是否立即调用handler；immediate为假则开一个定时器600ms后调用handler，handler会把标志变量置位true;</li>\n<li>在上一次点击后的600ms内再次点击这时候canRun 为false，函数会直接返回，后边的代码不会被执行。</li>\n</ul>\n<p>功能很简单，上面就是实现了函数节流（throttle）的功能。加下来我们将throttle抽象一下封装成可供外部调用的throttle方法。</p>\n<h4 id=\"throttle实现\"><a href=\"#throttle实现\" class=\"headerlink\" title=\"throttle实现\"></a>throttle实现</h4><p>分析：我们要实现的throttle方法只负责 是否能执行某些代码的逻辑实现。时间间隔、要执行的函数、是否立即执行 这些都是使用方决定的，即这些作为throttle方法的参数传入。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">throlle</span>(<span class=\"params\">handler,delay,immediate</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> canRun = <span class=\"literal\">true</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(!canRun)&#123;</div><div class=\"line\">           <span class=\"keyword\">return</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        canRun = <span class=\"literal\">false</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span>(immediate)&#123;</div><div class=\"line\">           handler();</div><div class=\"line\">           immediate = <span class=\"literal\">false</span>;</div><div class=\"line\">           setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">           canRun = <span class=\"literal\">true</span>;</div><div class=\"line\">        &#125;, delay);</div><div class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">            setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">               handler();  <span class=\"comment\">//todo:参数传递</span></div><div class=\"line\">               canRun = <span class=\"literal\">true</span>;</div><div class=\"line\">            &#125;, delay);</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"debounce实现\"><a href=\"#debounce实现\" class=\"headerlink\" title=\"debounce实现\"></a>debounce实现</h4><p>分析：让我们回一下debounce和throttle的区别：debounce事件间隔会被重新计时，及在非空闲期内触发了回调,回调内会把定时器clear掉，重新创建一个定时器，事件间隔也即随之重新计算了。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">debounce</span>(<span class=\"params\">handler,delay,immediate</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> canRun = <span class=\"literal\">true</span>;</div><div class=\"line\">    <span class=\"keyword\">var</span> timer = <span class=\"literal\">null</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(!canRun)&#123;</div><div class=\"line\">           clearTimeout(timer); <span class=\"comment\">//唯一的区别就在这里</span></div><div class=\"line\">        &#125;</div><div class=\"line\">        canRun = <span class=\"literal\">false</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span>(immediate)&#123;</div><div class=\"line\">           handler();</div><div class=\"line\">           immediate = <span class=\"literal\">false</span>;</div><div class=\"line\">           setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">           canRun = <span class=\"literal\">true</span>;</div><div class=\"line\">        &#125;, delay);</div><div class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">            timer = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">               handler();  <span class=\"comment\">//todo:参数传递</span></div><div class=\"line\">               canRun = <span class=\"literal\">true</span>;</div><div class=\"line\">            &#125;, delay);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>以上也只是一个简单的实现，还有些可以优化的地方。<br>除了用setTimeout来控制时间间隔，亦可以通过时间戳来实现：即比较前后两次出发的时间出之差是否大于阈值。</p>"},{"title":"《深度工作》笔记","date":"2017-10-08T14:54:47.000Z","_content":"\n\n“深度工作”是现代人的一种非常重要的能力。\n随着网络智能手机的普及，在给我们生活带来便利的同时也增加了使我们分心的因素。在纷杂碎片化严重的现代人生活中专注力就显得格外重要。\n与深度工作相对的是浮浅工作。\n\n<!-- more -->\n### 影响深度工作的因素\n\n* 开放式的工作空间：更容易受周边环境的打扰。-外因\n* \"邮件系统、钉钉\" 等频繁的打断。-外因\n* 度量黑洞：脑力工作不好度量，通过表面上的忙碌，拉长工作时间，不断加班。-外因\n* 最小阻力原则：心里倾向：当我们面前有两件以上事情要选择的时候，我们总是选择阻力最小更容易完成的事情，把难度的事情一直拖，很容易陷入“浮浅工作” 。 -内因\n* 社交网络的成瘾： 微信、微博等。 -内因\n\n### 四种深度工作模式\n* 禁欲者模式：与世隔绝，通常稀世天才们可以做到。\n* 双峰模式：将时间按照一定周期划分成深度工作和浮浅工作。在时间上集中处理浮浅工作，其他时间深度工作。注意：深度工作的单位至少是一天。\n* 节奏模式：每天有规律的进行深度工作，从几点到几点必须专心的干一件是。一天内至少有一次深度工作和浮浅工作的切换。 比如好多大佬早起工作。\n* 记着模式：随时可以进入深度工作，需要训练。\n\n\n### 深度工作的六个技巧\n* 刻意练习：明确的目的，针对需要练习的点不断练习，不断增加难度，逃离舒适区。练习中要及时获得反馈。\n* 批处理浮浅工作。\n* 获得意义感：认知重塑。当我们做的事情和我们的价值观相符合的时候就会有意义感。\n* 改变环境：比如去图书馆看书。\n* 适度休息：\n* 工具优化：工具分两类-娱乐消遣类工具和生产力类工具。列出自己用了哪些生产力工具。\n\n### 训练深度专注力：先肌肉一样训练\n\n* 定量化：番茄工作法，不断的锻炼。看自己最多可以连续专注工作多长时间，如看书。可以先定个目标：连续深度看书一小时。\n* 划分优先级：深度工作只给优先级高的工作，其他给浮浅工作。\n\n\n### 感想\n\n现在自己的工作就感觉到深度工作的时间太少了，总感觉一天忙忙碌碌，最后好像也没干什么重要的事情。\n原因就在于一天过多的浮浅工作，不断的被别人打断。\n\n以后\n* 每天制定个深度工作的时间段（2到3小时），争取这段时间内不要看钉钉等被打扰的东西。\n* 早起，早上9点到10点半这段时间可以用来学习\n* 连续专注看书目标 1小时--> 2小时。 不看手机。\n\n深度工作的能力是在现代社会中的一个很大的优势。\n\n\n","source":"_posts/《深度工作》笔记.md","raw":"---\ntitle: 《深度工作》笔记\ndate: 2017-10-08 22:54:47\ntags: 深度工作\ncategories:\n    - 读书笔记\n---\n\n\n“深度工作”是现代人的一种非常重要的能力。\n随着网络智能手机的普及，在给我们生活带来便利的同时也增加了使我们分心的因素。在纷杂碎片化严重的现代人生活中专注力就显得格外重要。\n与深度工作相对的是浮浅工作。\n\n<!-- more -->\n### 影响深度工作的因素\n\n* 开放式的工作空间：更容易受周边环境的打扰。-外因\n* \"邮件系统、钉钉\" 等频繁的打断。-外因\n* 度量黑洞：脑力工作不好度量，通过表面上的忙碌，拉长工作时间，不断加班。-外因\n* 最小阻力原则：心里倾向：当我们面前有两件以上事情要选择的时候，我们总是选择阻力最小更容易完成的事情，把难度的事情一直拖，很容易陷入“浮浅工作” 。 -内因\n* 社交网络的成瘾： 微信、微博等。 -内因\n\n### 四种深度工作模式\n* 禁欲者模式：与世隔绝，通常稀世天才们可以做到。\n* 双峰模式：将时间按照一定周期划分成深度工作和浮浅工作。在时间上集中处理浮浅工作，其他时间深度工作。注意：深度工作的单位至少是一天。\n* 节奏模式：每天有规律的进行深度工作，从几点到几点必须专心的干一件是。一天内至少有一次深度工作和浮浅工作的切换。 比如好多大佬早起工作。\n* 记着模式：随时可以进入深度工作，需要训练。\n\n\n### 深度工作的六个技巧\n* 刻意练习：明确的目的，针对需要练习的点不断练习，不断增加难度，逃离舒适区。练习中要及时获得反馈。\n* 批处理浮浅工作。\n* 获得意义感：认知重塑。当我们做的事情和我们的价值观相符合的时候就会有意义感。\n* 改变环境：比如去图书馆看书。\n* 适度休息：\n* 工具优化：工具分两类-娱乐消遣类工具和生产力类工具。列出自己用了哪些生产力工具。\n\n### 训练深度专注力：先肌肉一样训练\n\n* 定量化：番茄工作法，不断的锻炼。看自己最多可以连续专注工作多长时间，如看书。可以先定个目标：连续深度看书一小时。\n* 划分优先级：深度工作只给优先级高的工作，其他给浮浅工作。\n\n\n### 感想\n\n现在自己的工作就感觉到深度工作的时间太少了，总感觉一天忙忙碌碌，最后好像也没干什么重要的事情。\n原因就在于一天过多的浮浅工作，不断的被别人打断。\n\n以后\n* 每天制定个深度工作的时间段（2到3小时），争取这段时间内不要看钉钉等被打扰的东西。\n* 早起，早上9点到10点半这段时间可以用来学习\n* 连续专注看书目标 1小时--> 2小时。 不看手机。\n\n深度工作的能力是在现代社会中的一个很大的优势。\n\n\n","slug":"《深度工作》笔记","published":1,"updated":"2018-03-10T16:05:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjelnshco00073gffj7culcpj","content":"<p>“深度工作”是现代人的一种非常重要的能力。<br>随着网络智能手机的普及，在给我们生活带来便利的同时也增加了使我们分心的因素。在纷杂碎片化严重的现代人生活中专注力就显得格外重要。<br>与深度工作相对的是浮浅工作。</p>\n<a id=\"more\"></a>\n<h3 id=\"影响深度工作的因素\"><a href=\"#影响深度工作的因素\" class=\"headerlink\" title=\"影响深度工作的因素\"></a>影响深度工作的因素</h3><ul>\n<li>开放式的工作空间：更容易受周边环境的打扰。-外因</li>\n<li>“邮件系统、钉钉” 等频繁的打断。-外因</li>\n<li>度量黑洞：脑力工作不好度量，通过表面上的忙碌，拉长工作时间，不断加班。-外因</li>\n<li>最小阻力原则：心里倾向：当我们面前有两件以上事情要选择的时候，我们总是选择阻力最小更容易完成的事情，把难度的事情一直拖，很容易陷入“浮浅工作” 。 -内因</li>\n<li>社交网络的成瘾： 微信、微博等。 -内因</li>\n</ul>\n<h3 id=\"四种深度工作模式\"><a href=\"#四种深度工作模式\" class=\"headerlink\" title=\"四种深度工作模式\"></a>四种深度工作模式</h3><ul>\n<li>禁欲者模式：与世隔绝，通常稀世天才们可以做到。</li>\n<li>双峰模式：将时间按照一定周期划分成深度工作和浮浅工作。在时间上集中处理浮浅工作，其他时间深度工作。注意：深度工作的单位至少是一天。</li>\n<li>节奏模式：每天有规律的进行深度工作，从几点到几点必须专心的干一件是。一天内至少有一次深度工作和浮浅工作的切换。 比如好多大佬早起工作。</li>\n<li>记着模式：随时可以进入深度工作，需要训练。</li>\n</ul>\n<h3 id=\"深度工作的六个技巧\"><a href=\"#深度工作的六个技巧\" class=\"headerlink\" title=\"深度工作的六个技巧\"></a>深度工作的六个技巧</h3><ul>\n<li>刻意练习：明确的目的，针对需要练习的点不断练习，不断增加难度，逃离舒适区。练习中要及时获得反馈。</li>\n<li>批处理浮浅工作。</li>\n<li>获得意义感：认知重塑。当我们做的事情和我们的价值观相符合的时候就会有意义感。</li>\n<li>改变环境：比如去图书馆看书。</li>\n<li>适度休息：</li>\n<li>工具优化：工具分两类-娱乐消遣类工具和生产力类工具。列出自己用了哪些生产力工具。</li>\n</ul>\n<h3 id=\"训练深度专注力：先肌肉一样训练\"><a href=\"#训练深度专注力：先肌肉一样训练\" class=\"headerlink\" title=\"训练深度专注力：先肌肉一样训练\"></a>训练深度专注力：先肌肉一样训练</h3><ul>\n<li>定量化：番茄工作法，不断的锻炼。看自己最多可以连续专注工作多长时间，如看书。可以先定个目标：连续深度看书一小时。</li>\n<li>划分优先级：深度工作只给优先级高的工作，其他给浮浅工作。</li>\n</ul>\n<h3 id=\"感想\"><a href=\"#感想\" class=\"headerlink\" title=\"感想\"></a>感想</h3><p>现在自己的工作就感觉到深度工作的时间太少了，总感觉一天忙忙碌碌，最后好像也没干什么重要的事情。<br>原因就在于一天过多的浮浅工作，不断的被别人打断。</p>\n<p>以后</p>\n<ul>\n<li>每天制定个深度工作的时间段（2到3小时），争取这段时间内不要看钉钉等被打扰的东西。</li>\n<li>早起，早上9点到10点半这段时间可以用来学习</li>\n<li>连续专注看书目标 1小时–&gt; 2小时。 不看手机。</li>\n</ul>\n<p>深度工作的能力是在现代社会中的一个很大的优势。</p>\n","excerpt":"<p>“深度工作”是现代人的一种非常重要的能力。<br>随着网络智能手机的普及，在给我们生活带来便利的同时也增加了使我们分心的因素。在纷杂碎片化严重的现代人生活中专注力就显得格外重要。<br>与深度工作相对的是浮浅工作。</p>","more":"<h3 id=\"影响深度工作的因素\"><a href=\"#影响深度工作的因素\" class=\"headerlink\" title=\"影响深度工作的因素\"></a>影响深度工作的因素</h3><ul>\n<li>开放式的工作空间：更容易受周边环境的打扰。-外因</li>\n<li>“邮件系统、钉钉” 等频繁的打断。-外因</li>\n<li>度量黑洞：脑力工作不好度量，通过表面上的忙碌，拉长工作时间，不断加班。-外因</li>\n<li>最小阻力原则：心里倾向：当我们面前有两件以上事情要选择的时候，我们总是选择阻力最小更容易完成的事情，把难度的事情一直拖，很容易陷入“浮浅工作” 。 -内因</li>\n<li>社交网络的成瘾： 微信、微博等。 -内因</li>\n</ul>\n<h3 id=\"四种深度工作模式\"><a href=\"#四种深度工作模式\" class=\"headerlink\" title=\"四种深度工作模式\"></a>四种深度工作模式</h3><ul>\n<li>禁欲者模式：与世隔绝，通常稀世天才们可以做到。</li>\n<li>双峰模式：将时间按照一定周期划分成深度工作和浮浅工作。在时间上集中处理浮浅工作，其他时间深度工作。注意：深度工作的单位至少是一天。</li>\n<li>节奏模式：每天有规律的进行深度工作，从几点到几点必须专心的干一件是。一天内至少有一次深度工作和浮浅工作的切换。 比如好多大佬早起工作。</li>\n<li>记着模式：随时可以进入深度工作，需要训练。</li>\n</ul>\n<h3 id=\"深度工作的六个技巧\"><a href=\"#深度工作的六个技巧\" class=\"headerlink\" title=\"深度工作的六个技巧\"></a>深度工作的六个技巧</h3><ul>\n<li>刻意练习：明确的目的，针对需要练习的点不断练习，不断增加难度，逃离舒适区。练习中要及时获得反馈。</li>\n<li>批处理浮浅工作。</li>\n<li>获得意义感：认知重塑。当我们做的事情和我们的价值观相符合的时候就会有意义感。</li>\n<li>改变环境：比如去图书馆看书。</li>\n<li>适度休息：</li>\n<li>工具优化：工具分两类-娱乐消遣类工具和生产力类工具。列出自己用了哪些生产力工具。</li>\n</ul>\n<h3 id=\"训练深度专注力：先肌肉一样训练\"><a href=\"#训练深度专注力：先肌肉一样训练\" class=\"headerlink\" title=\"训练深度专注力：先肌肉一样训练\"></a>训练深度专注力：先肌肉一样训练</h3><ul>\n<li>定量化：番茄工作法，不断的锻炼。看自己最多可以连续专注工作多长时间，如看书。可以先定个目标：连续深度看书一小时。</li>\n<li>划分优先级：深度工作只给优先级高的工作，其他给浮浅工作。</li>\n</ul>\n<h3 id=\"感想\"><a href=\"#感想\" class=\"headerlink\" title=\"感想\"></a>感想</h3><p>现在自己的工作就感觉到深度工作的时间太少了，总感觉一天忙忙碌碌，最后好像也没干什么重要的事情。<br>原因就在于一天过多的浮浅工作，不断的被别人打断。</p>\n<p>以后</p>\n<ul>\n<li>每天制定个深度工作的时间段（2到3小时），争取这段时间内不要看钉钉等被打扰的东西。</li>\n<li>早起，早上9点到10点半这段时间可以用来学习</li>\n<li>连续专注看书目标 1小时–&gt; 2小时。 不看手机。</li>\n</ul>\n<p>深度工作的能力是在现代社会中的一个很大的优势。</p>"},{"title":"前端MVC","date":"2017-10-05T07:49:16.000Z","_content":"\n### 前言\n\n本文是个人对前端MVC的理解。当我去查MVC资料的时候发现，一千篇文章有一千种MVC，搞的我很纠结。于是研究总结为本文。如果要先一句话介绍什么是MVC，那么：\n\n> MVC是开发GUI（图形用户界面）程序的一种架构模式。\n\n<!-- more -->\n\n是的，我这里想要搞清的就是`前端MVC`（包括web前端，客户端开发），不涉及服务端MVC。  \n\n### 说说历史\nMVC模式最初是在1979年由 TrygveReenskaug在研究Smalltalk-80期间设计出来的。本文称之为经典MVC（以和现代的一千种MVC相区别）。\n\n这么多年过去了，如今的软件环境和当年已大不相同，所以我们今天所看到的MVC已不同往日。比如经典MVC中说\n> “view永远不应该知道用户输入，比如鼠标操作和按键。”  --经典MVC\n\n显然在今天的前端开发中是做不到的，用户输入必须通过监听view上的事件来获得。\n\n因为当年View的功能及其弱，比如鼠标的光标都需要程序自己绘制。经典MVC中，Controller要做的事情多数是派发用户输入给不同的View，并且在必要的时候从View中获取Editor来更改Model，而Web以及绝大多数现在的UI系统中，Controller的这部分职责已经被系统实现了。即现在的view 系统实现的更强大了，比如view自身能响应事件并带有一些事件数据。\n\n> 经典MVC中称\"controller是用户和系统之间的链接\"，也就不难理解解了。\n\n所以，如今 view.onclick = ... ，在当年就是 mouse.onclick = ...  \n\n\n知道了当年和现在软件环境的差异后，那么我们就重点关注那些些没变的东西就好了，也没要去纠结 Smalltalk-80 MVC最初的实现了。变的是环境，不变的是思想。\n\n> MVC强制将业务数据（Model）与用户界面（View）隔离，Controller管理业务逻辑和用户输入。\n\n\n### MVC\n接下来介绍 MVC的各个部件：\n\n#### Model \nModel 代表特定领域数据？？，不了解用户界面（view 和controller)；当一个model 发生变化时，他会通知他的观察者（view）；\n\n#### View\nView 描绘的是Model的当前状态。view 通过观察者模式观察 model以了解model何时更新。\n\n#### Controller\n在view-controller 对中作用是处理用户交互（如按键和点击等动作），为view 做决定。\n\n\n\n#### MVC的依赖关系\n\n![mvc依赖关系图](https://ws1.sinaimg.cn/large/006tKfTcgy1fk7cgu66arj30kk0cwq40.jpg)\n\nController和View 都依赖Model: view 的数据来源为model，controller 调用model的 数据处理方法。 controller和view互相依赖,在一些网上的资料Controller和View之间的依赖关系可能不一样，有些是单向依赖，有些是双向依赖，这个其实关系不大，后面会看到它们的依赖关系都是为了把处理用户行为触发的事件处理权交给Controller。\n\n#### MVC调用关系\n\n![MVC调用关系](https://ws4.sinaimg.cn/large/006tKfTcgy1fk7cx1rbn7j30j80kkgni.jpg)\n\n* 用户交互来源主要是view (或者输入url),view 捕获到操作后，将处理权委托给controller,controller对来自view 的数据预处理，决定调用那个model的那个接口（应用逻辑）；然后有model 执行相应的业务逻辑； model 更新后，通过观察者模式通知view ;view 接收到通知后向model请求最新数据（或者model主动传递）更新自己。\n\n#### MVC实例 \n    http://jsfiddle.net/uVBvq/\n\n\n``` html\n    <form action=\"\">\n        <span id=\"num\"></span><br />\n        <button type=\"button\" id=\"increase\">+</button>\n        <button type=\"button\" id=\"decrease\">-</button>\n    </form>\n    \n    <script>\n    var myapp = {};\n\n    myapp.Model = function () {\n        var val = 0;\n        this.add = function (v) {\n            if (val < 100) val += v;\n        };\n        this.sub = function (v) {\n            if (val > 0) val -= v;\n        };\n        this.getVal = function () {\n            return val;\n        };\n        \n        //model拥有 view 的引用？\n        var views = [];\n        this.register = function (view) {\n            views.push(view);\n        }\n        \n        //model 变化时通知model更新\n        this.notify = function () {\n            for (var i = 0; i < views.length; i++) {\n                views[i].render(this);\n            }\n        };\n    };\n    \n    //view 拥有controller的引用\n    myapp.View = function (controller) {\n        var $incBtn = $('#increase');\n        var $decBtn = $('#decrease');\n        var $num = $('#num');\n    \n        this.render = function (model) {\n            $num.text(model.getVal() + 'px');\n        };\n    \n        $incBtn.click(controller.increase);\n        $decBtn.click(controller.decrease);\n    };\n    \n     \n    myapp.Controller = function () {\n        var model = null;\n        var view  = null;\n    \n        this.init = function () {\n            //controller初始化 model 和view\n            model = new myapp.Model();\n            view  = new myapp.View(this);\n           \n           //view 向model 注册自己\n            model.register(view);\n            model.notify();\n        };\n        \n        //controller 负责更新model \n        this.increase = function () {\n            model.add(1);\n            model.notify();\n        };\n        this.decrease = function () {\n            model.sub(1);\n            model.notify();\n        };\n    };\n    \n    \n    //外界只接触到controller \n    $(function () {\n        var controller = new myapp.Controller();\n        controller.init();\n    });\n    </script>\n```\n### MVC优缺点 \n#### 优点\n* 耦合性降低：视图和模型分离，利于项目工程化（分工等）。\n* Model可复用性增强： 因为Model是独立于view的。\n\n#### 缺点  （[以下直接引用](https://github.com/livoras/blog/issues/11)）\n* Controller测试困难。因为视图同步操作是由View自己执行，而View只能在有UI的环境下运行。在没有UI环境下对Controller进行单元测试的时候，应用逻辑正确性是无法验证的：Model更新的时候，无法对View的更新操作进行断言。\n* View无法组件化。View是强依赖特定的Model的，如果需要把这个View抽出来作为一个另外一个应用程序可复用的组件就困难了。因为不同程序的的Domain Model是不一样的。 \n\n### MVC其他\n#### ios里的MVC（todo）\n\nkvo ...\n\n#### 服务端MVC \n服务端也有MVC，但是经典的MVC模式只是解决客户端图形界面应用程序的问题，而对服务端无效，服务端MVC的变种也有自己的一个名字 MVC Model2 这里不介绍了。\n\n### MVC衍生--MVP\n顺便把mvp说一下吧。MVP是MVC的衍生品。MVP有两种：\n \n * Passive View\n * Supervising Controller\n \n常见的是Passive View（被动视图），这里也只说这种。\n \n#### MVP依赖关系\n\n![MVP依赖关系](https://ws2.sinaimg.cn/large/006tKfTcgy1fk7e9b9vhjj30ii0b60tn.jpg)\n\nMVP打破了View原来对于Model的依赖，其余的依赖关系和MVC模式一致。\n\n#### MVP（Passive View）的调用关系\n\n![MVP（Passive View）的调用关系](https://ws4.sinaimg.cn/large/006tKfTcgy1fk7edqp1frj310u0t8jts.jpg)\n\nview和model 完全解耦后，model更新是如何同步view的呢？ 是通过presenter。\nmvc 中是model更新后通知view更新。mvp中是model更新后，通过观察者告知presenter而不是view了。presenter获取到Model变更的消息以后，通过View提供的接口更新界面。\n\n#### MVP（Passive View）的优缺点（[以下直接引用](https://github.com/livoras/blog/issues/11)）\n\n\n##### 优点：\n\n* 便于测试。Presenter对View是通过接口进行，在对Presenter进行不依赖UI环境的单元测试的时候。可以通过Mock一个View对象，这个对象只需要实现了View的接口即可。然后依赖注入到Presenter中，单元测试的时候就可以完整的测试Presenter应用逻辑的正确性。这里根据上面的例子给出了Presenter的单元测试样例。\n* View可以进行组件化。在MVP当中，View不依赖Model。这样就可以让View从特定的业务场景中脱离出来，可以说View可以做到对业务完全无知。它只需要提供一系列接口提供给上层操作。这样就可以做到高度可复用的View组件。\n\n##### 缺点：\n\n* Presenter中除了应用逻辑以外，还有大量的View->Model，Model->View的手动同步逻辑，造成Presenter比较笨重，维护起来会比较困难。\n\n//todo: 待实例验证优缺点 \n \n    \n### 资料\n* winter http://www.cnblogs.com/winter-cn/p/4285171.html\n* EFE http://efe.baidu.com/blog/mvc-deformation/\n* https://github.com/livoras/blog/issues/11\n* https://speakerdeck.com/jaceju/understanding-the-mvc-mvp-mvvm-in-javascript\n\n    \n","source":"_posts/前端MVC.md","raw":"---\ntitle: 前端MVC\ndate: 2017-10-05 15:49:16\ntags: \n - MVC\n - MVP\ncategories:\n  - 架构模式\n  - 设计模式\n\n---\n\n### 前言\n\n本文是个人对前端MVC的理解。当我去查MVC资料的时候发现，一千篇文章有一千种MVC，搞的我很纠结。于是研究总结为本文。如果要先一句话介绍什么是MVC，那么：\n\n> MVC是开发GUI（图形用户界面）程序的一种架构模式。\n\n<!-- more -->\n\n是的，我这里想要搞清的就是`前端MVC`（包括web前端，客户端开发），不涉及服务端MVC。  \n\n### 说说历史\nMVC模式最初是在1979年由 TrygveReenskaug在研究Smalltalk-80期间设计出来的。本文称之为经典MVC（以和现代的一千种MVC相区别）。\n\n这么多年过去了，如今的软件环境和当年已大不相同，所以我们今天所看到的MVC已不同往日。比如经典MVC中说\n> “view永远不应该知道用户输入，比如鼠标操作和按键。”  --经典MVC\n\n显然在今天的前端开发中是做不到的，用户输入必须通过监听view上的事件来获得。\n\n因为当年View的功能及其弱，比如鼠标的光标都需要程序自己绘制。经典MVC中，Controller要做的事情多数是派发用户输入给不同的View，并且在必要的时候从View中获取Editor来更改Model，而Web以及绝大多数现在的UI系统中，Controller的这部分职责已经被系统实现了。即现在的view 系统实现的更强大了，比如view自身能响应事件并带有一些事件数据。\n\n> 经典MVC中称\"controller是用户和系统之间的链接\"，也就不难理解解了。\n\n所以，如今 view.onclick = ... ，在当年就是 mouse.onclick = ...  \n\n\n知道了当年和现在软件环境的差异后，那么我们就重点关注那些些没变的东西就好了，也没要去纠结 Smalltalk-80 MVC最初的实现了。变的是环境，不变的是思想。\n\n> MVC强制将业务数据（Model）与用户界面（View）隔离，Controller管理业务逻辑和用户输入。\n\n\n### MVC\n接下来介绍 MVC的各个部件：\n\n#### Model \nModel 代表特定领域数据？？，不了解用户界面（view 和controller)；当一个model 发生变化时，他会通知他的观察者（view）；\n\n#### View\nView 描绘的是Model的当前状态。view 通过观察者模式观察 model以了解model何时更新。\n\n#### Controller\n在view-controller 对中作用是处理用户交互（如按键和点击等动作），为view 做决定。\n\n\n\n#### MVC的依赖关系\n\n![mvc依赖关系图](https://ws1.sinaimg.cn/large/006tKfTcgy1fk7cgu66arj30kk0cwq40.jpg)\n\nController和View 都依赖Model: view 的数据来源为model，controller 调用model的 数据处理方法。 controller和view互相依赖,在一些网上的资料Controller和View之间的依赖关系可能不一样，有些是单向依赖，有些是双向依赖，这个其实关系不大，后面会看到它们的依赖关系都是为了把处理用户行为触发的事件处理权交给Controller。\n\n#### MVC调用关系\n\n![MVC调用关系](https://ws4.sinaimg.cn/large/006tKfTcgy1fk7cx1rbn7j30j80kkgni.jpg)\n\n* 用户交互来源主要是view (或者输入url),view 捕获到操作后，将处理权委托给controller,controller对来自view 的数据预处理，决定调用那个model的那个接口（应用逻辑）；然后有model 执行相应的业务逻辑； model 更新后，通过观察者模式通知view ;view 接收到通知后向model请求最新数据（或者model主动传递）更新自己。\n\n#### MVC实例 \n    http://jsfiddle.net/uVBvq/\n\n\n``` html\n    <form action=\"\">\n        <span id=\"num\"></span><br />\n        <button type=\"button\" id=\"increase\">+</button>\n        <button type=\"button\" id=\"decrease\">-</button>\n    </form>\n    \n    <script>\n    var myapp = {};\n\n    myapp.Model = function () {\n        var val = 0;\n        this.add = function (v) {\n            if (val < 100) val += v;\n        };\n        this.sub = function (v) {\n            if (val > 0) val -= v;\n        };\n        this.getVal = function () {\n            return val;\n        };\n        \n        //model拥有 view 的引用？\n        var views = [];\n        this.register = function (view) {\n            views.push(view);\n        }\n        \n        //model 变化时通知model更新\n        this.notify = function () {\n            for (var i = 0; i < views.length; i++) {\n                views[i].render(this);\n            }\n        };\n    };\n    \n    //view 拥有controller的引用\n    myapp.View = function (controller) {\n        var $incBtn = $('#increase');\n        var $decBtn = $('#decrease');\n        var $num = $('#num');\n    \n        this.render = function (model) {\n            $num.text(model.getVal() + 'px');\n        };\n    \n        $incBtn.click(controller.increase);\n        $decBtn.click(controller.decrease);\n    };\n    \n     \n    myapp.Controller = function () {\n        var model = null;\n        var view  = null;\n    \n        this.init = function () {\n            //controller初始化 model 和view\n            model = new myapp.Model();\n            view  = new myapp.View(this);\n           \n           //view 向model 注册自己\n            model.register(view);\n            model.notify();\n        };\n        \n        //controller 负责更新model \n        this.increase = function () {\n            model.add(1);\n            model.notify();\n        };\n        this.decrease = function () {\n            model.sub(1);\n            model.notify();\n        };\n    };\n    \n    \n    //外界只接触到controller \n    $(function () {\n        var controller = new myapp.Controller();\n        controller.init();\n    });\n    </script>\n```\n### MVC优缺点 \n#### 优点\n* 耦合性降低：视图和模型分离，利于项目工程化（分工等）。\n* Model可复用性增强： 因为Model是独立于view的。\n\n#### 缺点  （[以下直接引用](https://github.com/livoras/blog/issues/11)）\n* Controller测试困难。因为视图同步操作是由View自己执行，而View只能在有UI的环境下运行。在没有UI环境下对Controller进行单元测试的时候，应用逻辑正确性是无法验证的：Model更新的时候，无法对View的更新操作进行断言。\n* View无法组件化。View是强依赖特定的Model的，如果需要把这个View抽出来作为一个另外一个应用程序可复用的组件就困难了。因为不同程序的的Domain Model是不一样的。 \n\n### MVC其他\n#### ios里的MVC（todo）\n\nkvo ...\n\n#### 服务端MVC \n服务端也有MVC，但是经典的MVC模式只是解决客户端图形界面应用程序的问题，而对服务端无效，服务端MVC的变种也有自己的一个名字 MVC Model2 这里不介绍了。\n\n### MVC衍生--MVP\n顺便把mvp说一下吧。MVP是MVC的衍生品。MVP有两种：\n \n * Passive View\n * Supervising Controller\n \n常见的是Passive View（被动视图），这里也只说这种。\n \n#### MVP依赖关系\n\n![MVP依赖关系](https://ws2.sinaimg.cn/large/006tKfTcgy1fk7e9b9vhjj30ii0b60tn.jpg)\n\nMVP打破了View原来对于Model的依赖，其余的依赖关系和MVC模式一致。\n\n#### MVP（Passive View）的调用关系\n\n![MVP（Passive View）的调用关系](https://ws4.sinaimg.cn/large/006tKfTcgy1fk7edqp1frj310u0t8jts.jpg)\n\nview和model 完全解耦后，model更新是如何同步view的呢？ 是通过presenter。\nmvc 中是model更新后通知view更新。mvp中是model更新后，通过观察者告知presenter而不是view了。presenter获取到Model变更的消息以后，通过View提供的接口更新界面。\n\n#### MVP（Passive View）的优缺点（[以下直接引用](https://github.com/livoras/blog/issues/11)）\n\n\n##### 优点：\n\n* 便于测试。Presenter对View是通过接口进行，在对Presenter进行不依赖UI环境的单元测试的时候。可以通过Mock一个View对象，这个对象只需要实现了View的接口即可。然后依赖注入到Presenter中，单元测试的时候就可以完整的测试Presenter应用逻辑的正确性。这里根据上面的例子给出了Presenter的单元测试样例。\n* View可以进行组件化。在MVP当中，View不依赖Model。这样就可以让View从特定的业务场景中脱离出来，可以说View可以做到对业务完全无知。它只需要提供一系列接口提供给上层操作。这样就可以做到高度可复用的View组件。\n\n##### 缺点：\n\n* Presenter中除了应用逻辑以外，还有大量的View->Model，Model->View的手动同步逻辑，造成Presenter比较笨重，维护起来会比较困难。\n\n//todo: 待实例验证优缺点 \n \n    \n### 资料\n* winter http://www.cnblogs.com/winter-cn/p/4285171.html\n* EFE http://efe.baidu.com/blog/mvc-deformation/\n* https://github.com/livoras/blog/issues/11\n* https://speakerdeck.com/jaceju/understanding-the-mvc-mvp-mvvm-in-javascript\n\n    \n","slug":"前端MVC","published":1,"updated":"2018-03-10T16:05:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjelnshcs000a3gffqx24ny4q","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>本文是个人对前端MVC的理解。当我去查MVC资料的时候发现，一千篇文章有一千种MVC，搞的我很纠结。于是研究总结为本文。如果要先一句话介绍什么是MVC，那么：</p>\n<blockquote>\n<p>MVC是开发GUI（图形用户界面）程序的一种架构模式。</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>是的，我这里想要搞清的就是<code>前端MVC</code>（包括web前端，客户端开发），不涉及服务端MVC。  </p>\n<h3 id=\"说说历史\"><a href=\"#说说历史\" class=\"headerlink\" title=\"说说历史\"></a>说说历史</h3><p>MVC模式最初是在1979年由 TrygveReenskaug在研究Smalltalk-80期间设计出来的。本文称之为经典MVC（以和现代的一千种MVC相区别）。</p>\n<p>这么多年过去了，如今的软件环境和当年已大不相同，所以我们今天所看到的MVC已不同往日。比如经典MVC中说</p>\n<blockquote>\n<p>“view永远不应该知道用户输入，比如鼠标操作和按键。”  –经典MVC</p>\n</blockquote>\n<p>显然在今天的前端开发中是做不到的，用户输入必须通过监听view上的事件来获得。</p>\n<p>因为当年View的功能及其弱，比如鼠标的光标都需要程序自己绘制。经典MVC中，Controller要做的事情多数是派发用户输入给不同的View，并且在必要的时候从View中获取Editor来更改Model，而Web以及绝大多数现在的UI系统中，Controller的这部分职责已经被系统实现了。即现在的view 系统实现的更强大了，比如view自身能响应事件并带有一些事件数据。</p>\n<blockquote>\n<p>经典MVC中称”controller是用户和系统之间的链接”，也就不难理解解了。</p>\n</blockquote>\n<p>所以，如今 view.onclick = … ，在当年就是 mouse.onclick = …  </p>\n<p>知道了当年和现在软件环境的差异后，那么我们就重点关注那些些没变的东西就好了，也没要去纠结 Smalltalk-80 MVC最初的实现了。变的是环境，不变的是思想。</p>\n<blockquote>\n<p>MVC强制将业务数据（Model）与用户界面（View）隔离，Controller管理业务逻辑和用户输入。</p>\n</blockquote>\n<h3 id=\"MVC\"><a href=\"#MVC\" class=\"headerlink\" title=\"MVC\"></a>MVC</h3><p>接下来介绍 MVC的各个部件：</p>\n<h4 id=\"Model\"><a href=\"#Model\" class=\"headerlink\" title=\"Model\"></a>Model</h4><p>Model 代表特定领域数据？？，不了解用户界面（view 和controller)；当一个model 发生变化时，他会通知他的观察者（view）；</p>\n<h4 id=\"View\"><a href=\"#View\" class=\"headerlink\" title=\"View\"></a>View</h4><p>View 描绘的是Model的当前状态。view 通过观察者模式观察 model以了解model何时更新。</p>\n<h4 id=\"Controller\"><a href=\"#Controller\" class=\"headerlink\" title=\"Controller\"></a>Controller</h4><p>在view-controller 对中作用是处理用户交互（如按键和点击等动作），为view 做决定。</p>\n<h4 id=\"MVC的依赖关系\"><a href=\"#MVC的依赖关系\" class=\"headerlink\" title=\"MVC的依赖关系\"></a>MVC的依赖关系</h4><p><img src=\"https://ws1.sinaimg.cn/large/006tKfTcgy1fk7cgu66arj30kk0cwq40.jpg\" alt=\"mvc依赖关系图\"></p>\n<p>Controller和View 都依赖Model: view 的数据来源为model，controller 调用model的 数据处理方法。 controller和view互相依赖,在一些网上的资料Controller和View之间的依赖关系可能不一样，有些是单向依赖，有些是双向依赖，这个其实关系不大，后面会看到它们的依赖关系都是为了把处理用户行为触发的事件处理权交给Controller。</p>\n<h4 id=\"MVC调用关系\"><a href=\"#MVC调用关系\" class=\"headerlink\" title=\"MVC调用关系\"></a>MVC调用关系</h4><p><img src=\"https://ws4.sinaimg.cn/large/006tKfTcgy1fk7cx1rbn7j30j80kkgni.jpg\" alt=\"MVC调用关系\"></p>\n<ul>\n<li>用户交互来源主要是view (或者输入url),view 捕获到操作后，将处理权委托给controller,controller对来自view 的数据预处理，决定调用那个model的那个接口（应用逻辑）；然后有model 执行相应的业务逻辑； model 更新后，通过观察者模式通知view ;view 接收到通知后向model请求最新数据（或者model主动传递）更新自己。</li>\n</ul>\n<h4 id=\"MVC实例\"><a href=\"#MVC实例\" class=\"headerlink\" title=\"MVC实例\"></a>MVC实例</h4><pre><code>http://jsfiddle.net/uVBvq/\n</code></pre><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">action</span>=<span class=\"string\">\"\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">id</span>=<span class=\"string\">\"num\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span> /&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span>=<span class=\"string\">\"button\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"increase\"</span>&gt;</span>+<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span>=<span class=\"string\">\"button\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"decrease\"</span>&gt;</span>-<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></div><div class=\"line\"><span class=\"keyword\">var</span> myapp = &#123;&#125;;</div><div class=\"line\"></div><div class=\"line\">myapp.Model = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> val = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">this</span>.add = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">v</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (val &lt; <span class=\"number\">100</span>) val += v;</div><div class=\"line\">    &#125;;</div><div class=\"line\">    <span class=\"keyword\">this</span>.sub = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">v</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (val &gt; <span class=\"number\">0</span>) val -= v;</div><div class=\"line\">    &#125;;</div><div class=\"line\">    <span class=\"keyword\">this</span>.getVal = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> val;</div><div class=\"line\">    &#125;;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//model拥有 view 的引用？</span></div><div class=\"line\">    <span class=\"keyword\">var</span> views = [];</div><div class=\"line\">    <span class=\"keyword\">this</span>.register = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">view</span>) </span>&#123;</div><div class=\"line\">        views.push(view);</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//model 变化时通知model更新</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.notify = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; views.length; i++) &#123;</div><div class=\"line\">            views[i].render(<span class=\"keyword\">this</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//view 拥有controller的引用</span></div><div class=\"line\">myapp.View = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">controller</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> $incBtn = $(<span class=\"string\">'#increase'</span>);</div><div class=\"line\">    <span class=\"keyword\">var</span> $decBtn = $(<span class=\"string\">'#decrease'</span>);</div><div class=\"line\">    <span class=\"keyword\">var</span> $num = $(<span class=\"string\">'#num'</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">this</span>.render = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">model</span>) </span>&#123;</div><div class=\"line\">        $num.text(model.getVal() + <span class=\"string\">'px'</span>);</div><div class=\"line\">    &#125;;</div><div class=\"line\"></div><div class=\"line\">    $incBtn.click(controller.increase);</div><div class=\"line\">    $decBtn.click(controller.decrease);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"> </div><div class=\"line\">myapp.Controller = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> model = <span class=\"literal\">null</span>;</div><div class=\"line\">    <span class=\"keyword\">var</span> view  = <span class=\"literal\">null</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">this</span>.init = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"comment\">//controller初始化 model 和view</span></div><div class=\"line\">        model = <span class=\"keyword\">new</span> myapp.Model();</div><div class=\"line\">        view  = <span class=\"keyword\">new</span> myapp.View(<span class=\"keyword\">this</span>);</div><div class=\"line\">       </div><div class=\"line\">       <span class=\"comment\">//view 向model 注册自己</span></div><div class=\"line\">        model.register(view);</div><div class=\"line\">        model.notify();</div><div class=\"line\">    &#125;;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//controller 负责更新model </span></div><div class=\"line\">    <span class=\"keyword\">this</span>.increase = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        model.add(<span class=\"number\">1</span>);</div><div class=\"line\">        model.notify();</div><div class=\"line\">    &#125;;</div><div class=\"line\">    <span class=\"keyword\">this</span>.decrease = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        model.sub(<span class=\"number\">1</span>);</div><div class=\"line\">        model.notify();</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//外界只接触到controller </span></div><div class=\"line\">$(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> controller = <span class=\"keyword\">new</span> myapp.Controller();</div><div class=\"line\">    controller.init();</div><div class=\"line\">&#125;);</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"MVC优缺点\"><a href=\"#MVC优缺点\" class=\"headerlink\" title=\"MVC优缺点\"></a>MVC优缺点</h3><h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h4><ul>\n<li>耦合性降低：视图和模型分离，利于项目工程化（分工等）。</li>\n<li>Model可复用性增强： 因为Model是独立于view的。</li>\n</ul>\n<h4 id=\"缺点-（以下直接引用）\"><a href=\"#缺点-（以下直接引用）\" class=\"headerlink\" title=\"缺点  （以下直接引用）\"></a>缺点  （<a href=\"https://github.com/livoras/blog/issues/11\" target=\"_blank\" rel=\"external\">以下直接引用</a>）</h4><ul>\n<li>Controller测试困难。因为视图同步操作是由View自己执行，而View只能在有UI的环境下运行。在没有UI环境下对Controller进行单元测试的时候，应用逻辑正确性是无法验证的：Model更新的时候，无法对View的更新操作进行断言。</li>\n<li>View无法组件化。View是强依赖特定的Model的，如果需要把这个View抽出来作为一个另外一个应用程序可复用的组件就困难了。因为不同程序的的Domain Model是不一样的。 </li>\n</ul>\n<h3 id=\"MVC其他\"><a href=\"#MVC其他\" class=\"headerlink\" title=\"MVC其他\"></a>MVC其他</h3><h4 id=\"ios里的MVC（todo）\"><a href=\"#ios里的MVC（todo）\" class=\"headerlink\" title=\"ios里的MVC（todo）\"></a>ios里的MVC（todo）</h4><p>kvo …</p>\n<h4 id=\"服务端MVC\"><a href=\"#服务端MVC\" class=\"headerlink\" title=\"服务端MVC\"></a>服务端MVC</h4><p>服务端也有MVC，但是经典的MVC模式只是解决客户端图形界面应用程序的问题，而对服务端无效，服务端MVC的变种也有自己的一个名字 MVC Model2 这里不介绍了。</p>\n<h3 id=\"MVC衍生–MVP\"><a href=\"#MVC衍生–MVP\" class=\"headerlink\" title=\"MVC衍生–MVP\"></a>MVC衍生–MVP</h3><p>顺便把mvp说一下吧。MVP是MVC的衍生品。MVP有两种：</p>\n<ul>\n<li>Passive View</li>\n<li>Supervising Controller</li>\n</ul>\n<p>常见的是Passive View（被动视图），这里也只说这种。</p>\n<h4 id=\"MVP依赖关系\"><a href=\"#MVP依赖关系\" class=\"headerlink\" title=\"MVP依赖关系\"></a>MVP依赖关系</h4><p><img src=\"https://ws2.sinaimg.cn/large/006tKfTcgy1fk7e9b9vhjj30ii0b60tn.jpg\" alt=\"MVP依赖关系\"></p>\n<p>MVP打破了View原来对于Model的依赖，其余的依赖关系和MVC模式一致。</p>\n<h4 id=\"MVP（Passive-View）的调用关系\"><a href=\"#MVP（Passive-View）的调用关系\" class=\"headerlink\" title=\"MVP（Passive View）的调用关系\"></a>MVP（Passive View）的调用关系</h4><p><img src=\"https://ws4.sinaimg.cn/large/006tKfTcgy1fk7edqp1frj310u0t8jts.jpg\" alt=\"MVP（Passive View）的调用关系\"></p>\n<p>view和model 完全解耦后，model更新是如何同步view的呢？ 是通过presenter。<br>mvc 中是model更新后通知view更新。mvp中是model更新后，通过观察者告知presenter而不是view了。presenter获取到Model变更的消息以后，通过View提供的接口更新界面。</p>\n<h4 id=\"MVP（Passive-View）的优缺点（以下直接引用）\"><a href=\"#MVP（Passive-View）的优缺点（以下直接引用）\" class=\"headerlink\" title=\"MVP（Passive View）的优缺点（以下直接引用）\"></a>MVP（Passive View）的优缺点（<a href=\"https://github.com/livoras/blog/issues/11\" target=\"_blank\" rel=\"external\">以下直接引用</a>）</h4><h5 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h5><ul>\n<li>便于测试。Presenter对View是通过接口进行，在对Presenter进行不依赖UI环境的单元测试的时候。可以通过Mock一个View对象，这个对象只需要实现了View的接口即可。然后依赖注入到Presenter中，单元测试的时候就可以完整的测试Presenter应用逻辑的正确性。这里根据上面的例子给出了Presenter的单元测试样例。</li>\n<li>View可以进行组件化。在MVP当中，View不依赖Model。这样就可以让View从特定的业务场景中脱离出来，可以说View可以做到对业务完全无知。它只需要提供一系列接口提供给上层操作。这样就可以做到高度可复用的View组件。</li>\n</ul>\n<h5 id=\"缺点：\"><a href=\"#缺点：\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h5><ul>\n<li>Presenter中除了应用逻辑以外，还有大量的View-&gt;Model，Model-&gt;View的手动同步逻辑，造成Presenter比较笨重，维护起来会比较困难。</li>\n</ul>\n<p>//todo: 待实例验证优缺点 </p>\n<h3 id=\"资料\"><a href=\"#资料\" class=\"headerlink\" title=\"资料\"></a>资料</h3><ul>\n<li>winter <a href=\"http://www.cnblogs.com/winter-cn/p/4285171.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/winter-cn/p/4285171.html</a></li>\n<li>EFE <a href=\"http://efe.baidu.com/blog/mvc-deformation/\" target=\"_blank\" rel=\"external\">http://efe.baidu.com/blog/mvc-deformation/</a></li>\n<li><a href=\"https://github.com/livoras/blog/issues/11\" target=\"_blank\" rel=\"external\">https://github.com/livoras/blog/issues/11</a></li>\n<li><a href=\"https://speakerdeck.com/jaceju/understanding-the-mvc-mvp-mvvm-in-javascript\" target=\"_blank\" rel=\"external\">https://speakerdeck.com/jaceju/understanding-the-mvc-mvp-mvvm-in-javascript</a></li>\n</ul>\n","excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>本文是个人对前端MVC的理解。当我去查MVC资料的时候发现，一千篇文章有一千种MVC，搞的我很纠结。于是研究总结为本文。如果要先一句话介绍什么是MVC，那么：</p>\n<blockquote>\n<p>MVC是开发GUI（图形用户界面）程序的一种架构模式。</p>\n</blockquote>","more":"<p>是的，我这里想要搞清的就是<code>前端MVC</code>（包括web前端，客户端开发），不涉及服务端MVC。  </p>\n<h3 id=\"说说历史\"><a href=\"#说说历史\" class=\"headerlink\" title=\"说说历史\"></a>说说历史</h3><p>MVC模式最初是在1979年由 TrygveReenskaug在研究Smalltalk-80期间设计出来的。本文称之为经典MVC（以和现代的一千种MVC相区别）。</p>\n<p>这么多年过去了，如今的软件环境和当年已大不相同，所以我们今天所看到的MVC已不同往日。比如经典MVC中说</p>\n<blockquote>\n<p>“view永远不应该知道用户输入，比如鼠标操作和按键。”  –经典MVC</p>\n</blockquote>\n<p>显然在今天的前端开发中是做不到的，用户输入必须通过监听view上的事件来获得。</p>\n<p>因为当年View的功能及其弱，比如鼠标的光标都需要程序自己绘制。经典MVC中，Controller要做的事情多数是派发用户输入给不同的View，并且在必要的时候从View中获取Editor来更改Model，而Web以及绝大多数现在的UI系统中，Controller的这部分职责已经被系统实现了。即现在的view 系统实现的更强大了，比如view自身能响应事件并带有一些事件数据。</p>\n<blockquote>\n<p>经典MVC中称”controller是用户和系统之间的链接”，也就不难理解解了。</p>\n</blockquote>\n<p>所以，如今 view.onclick = … ，在当年就是 mouse.onclick = …  </p>\n<p>知道了当年和现在软件环境的差异后，那么我们就重点关注那些些没变的东西就好了，也没要去纠结 Smalltalk-80 MVC最初的实现了。变的是环境，不变的是思想。</p>\n<blockquote>\n<p>MVC强制将业务数据（Model）与用户界面（View）隔离，Controller管理业务逻辑和用户输入。</p>\n</blockquote>\n<h3 id=\"MVC\"><a href=\"#MVC\" class=\"headerlink\" title=\"MVC\"></a>MVC</h3><p>接下来介绍 MVC的各个部件：</p>\n<h4 id=\"Model\"><a href=\"#Model\" class=\"headerlink\" title=\"Model\"></a>Model</h4><p>Model 代表特定领域数据？？，不了解用户界面（view 和controller)；当一个model 发生变化时，他会通知他的观察者（view）；</p>\n<h4 id=\"View\"><a href=\"#View\" class=\"headerlink\" title=\"View\"></a>View</h4><p>View 描绘的是Model的当前状态。view 通过观察者模式观察 model以了解model何时更新。</p>\n<h4 id=\"Controller\"><a href=\"#Controller\" class=\"headerlink\" title=\"Controller\"></a>Controller</h4><p>在view-controller 对中作用是处理用户交互（如按键和点击等动作），为view 做决定。</p>\n<h4 id=\"MVC的依赖关系\"><a href=\"#MVC的依赖关系\" class=\"headerlink\" title=\"MVC的依赖关系\"></a>MVC的依赖关系</h4><p><img src=\"https://ws1.sinaimg.cn/large/006tKfTcgy1fk7cgu66arj30kk0cwq40.jpg\" alt=\"mvc依赖关系图\"></p>\n<p>Controller和View 都依赖Model: view 的数据来源为model，controller 调用model的 数据处理方法。 controller和view互相依赖,在一些网上的资料Controller和View之间的依赖关系可能不一样，有些是单向依赖，有些是双向依赖，这个其实关系不大，后面会看到它们的依赖关系都是为了把处理用户行为触发的事件处理权交给Controller。</p>\n<h4 id=\"MVC调用关系\"><a href=\"#MVC调用关系\" class=\"headerlink\" title=\"MVC调用关系\"></a>MVC调用关系</h4><p><img src=\"https://ws4.sinaimg.cn/large/006tKfTcgy1fk7cx1rbn7j30j80kkgni.jpg\" alt=\"MVC调用关系\"></p>\n<ul>\n<li>用户交互来源主要是view (或者输入url),view 捕获到操作后，将处理权委托给controller,controller对来自view 的数据预处理，决定调用那个model的那个接口（应用逻辑）；然后有model 执行相应的业务逻辑； model 更新后，通过观察者模式通知view ;view 接收到通知后向model请求最新数据（或者model主动传递）更新自己。</li>\n</ul>\n<h4 id=\"MVC实例\"><a href=\"#MVC实例\" class=\"headerlink\" title=\"MVC实例\"></a>MVC实例</h4><pre><code>http://jsfiddle.net/uVBvq/\n</code></pre><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">action</span>=<span class=\"string\">\"\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">id</span>=<span class=\"string\">\"num\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span> /&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span>=<span class=\"string\">\"button\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"increase\"</span>&gt;</span>+<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span>=<span class=\"string\">\"button\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"decrease\"</span>&gt;</span>-<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></div><div class=\"line\"><span class=\"keyword\">var</span> myapp = &#123;&#125;;</div><div class=\"line\"></div><div class=\"line\">myapp.Model = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> val = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">this</span>.add = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">v</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (val &lt; <span class=\"number\">100</span>) val += v;</div><div class=\"line\">    &#125;;</div><div class=\"line\">    <span class=\"keyword\">this</span>.sub = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">v</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (val &gt; <span class=\"number\">0</span>) val -= v;</div><div class=\"line\">    &#125;;</div><div class=\"line\">    <span class=\"keyword\">this</span>.getVal = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> val;</div><div class=\"line\">    &#125;;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//model拥有 view 的引用？</span></div><div class=\"line\">    <span class=\"keyword\">var</span> views = [];</div><div class=\"line\">    <span class=\"keyword\">this</span>.register = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">view</span>) </span>&#123;</div><div class=\"line\">        views.push(view);</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//model 变化时通知model更新</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.notify = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; views.length; i++) &#123;</div><div class=\"line\">            views[i].render(<span class=\"keyword\">this</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//view 拥有controller的引用</span></div><div class=\"line\">myapp.View = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">controller</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> $incBtn = $(<span class=\"string\">'#increase'</span>);</div><div class=\"line\">    <span class=\"keyword\">var</span> $decBtn = $(<span class=\"string\">'#decrease'</span>);</div><div class=\"line\">    <span class=\"keyword\">var</span> $num = $(<span class=\"string\">'#num'</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">this</span>.render = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">model</span>) </span>&#123;</div><div class=\"line\">        $num.text(model.getVal() + <span class=\"string\">'px'</span>);</div><div class=\"line\">    &#125;;</div><div class=\"line\"></div><div class=\"line\">    $incBtn.click(controller.increase);</div><div class=\"line\">    $decBtn.click(controller.decrease);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"> </div><div class=\"line\">myapp.Controller = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> model = <span class=\"literal\">null</span>;</div><div class=\"line\">    <span class=\"keyword\">var</span> view  = <span class=\"literal\">null</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">this</span>.init = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"comment\">//controller初始化 model 和view</span></div><div class=\"line\">        model = <span class=\"keyword\">new</span> myapp.Model();</div><div class=\"line\">        view  = <span class=\"keyword\">new</span> myapp.View(<span class=\"keyword\">this</span>);</div><div class=\"line\">       </div><div class=\"line\">       <span class=\"comment\">//view 向model 注册自己</span></div><div class=\"line\">        model.register(view);</div><div class=\"line\">        model.notify();</div><div class=\"line\">    &#125;;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//controller 负责更新model </span></div><div class=\"line\">    <span class=\"keyword\">this</span>.increase = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        model.add(<span class=\"number\">1</span>);</div><div class=\"line\">        model.notify();</div><div class=\"line\">    &#125;;</div><div class=\"line\">    <span class=\"keyword\">this</span>.decrease = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        model.sub(<span class=\"number\">1</span>);</div><div class=\"line\">        model.notify();</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//外界只接触到controller </span></div><div class=\"line\">$(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> controller = <span class=\"keyword\">new</span> myapp.Controller();</div><div class=\"line\">    controller.init();</div><div class=\"line\">&#125;);</div><div class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"MVC优缺点\"><a href=\"#MVC优缺点\" class=\"headerlink\" title=\"MVC优缺点\"></a>MVC优缺点</h3><h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h4><ul>\n<li>耦合性降低：视图和模型分离，利于项目工程化（分工等）。</li>\n<li>Model可复用性增强： 因为Model是独立于view的。</li>\n</ul>\n<h4 id=\"缺点-（以下直接引用）\"><a href=\"#缺点-（以下直接引用）\" class=\"headerlink\" title=\"缺点  （以下直接引用）\"></a>缺点  （<a href=\"https://github.com/livoras/blog/issues/11\">以下直接引用</a>）</h4><ul>\n<li>Controller测试困难。因为视图同步操作是由View自己执行，而View只能在有UI的环境下运行。在没有UI环境下对Controller进行单元测试的时候，应用逻辑正确性是无法验证的：Model更新的时候，无法对View的更新操作进行断言。</li>\n<li>View无法组件化。View是强依赖特定的Model的，如果需要把这个View抽出来作为一个另外一个应用程序可复用的组件就困难了。因为不同程序的的Domain Model是不一样的。 </li>\n</ul>\n<h3 id=\"MVC其他\"><a href=\"#MVC其他\" class=\"headerlink\" title=\"MVC其他\"></a>MVC其他</h3><h4 id=\"ios里的MVC（todo）\"><a href=\"#ios里的MVC（todo）\" class=\"headerlink\" title=\"ios里的MVC（todo）\"></a>ios里的MVC（todo）</h4><p>kvo …</p>\n<h4 id=\"服务端MVC\"><a href=\"#服务端MVC\" class=\"headerlink\" title=\"服务端MVC\"></a>服务端MVC</h4><p>服务端也有MVC，但是经典的MVC模式只是解决客户端图形界面应用程序的问题，而对服务端无效，服务端MVC的变种也有自己的一个名字 MVC Model2 这里不介绍了。</p>\n<h3 id=\"MVC衍生–MVP\"><a href=\"#MVC衍生–MVP\" class=\"headerlink\" title=\"MVC衍生–MVP\"></a>MVC衍生–MVP</h3><p>顺便把mvp说一下吧。MVP是MVC的衍生品。MVP有两种：</p>\n<ul>\n<li>Passive View</li>\n<li>Supervising Controller</li>\n</ul>\n<p>常见的是Passive View（被动视图），这里也只说这种。</p>\n<h4 id=\"MVP依赖关系\"><a href=\"#MVP依赖关系\" class=\"headerlink\" title=\"MVP依赖关系\"></a>MVP依赖关系</h4><p><img src=\"https://ws2.sinaimg.cn/large/006tKfTcgy1fk7e9b9vhjj30ii0b60tn.jpg\" alt=\"MVP依赖关系\"></p>\n<p>MVP打破了View原来对于Model的依赖，其余的依赖关系和MVC模式一致。</p>\n<h4 id=\"MVP（Passive-View）的调用关系\"><a href=\"#MVP（Passive-View）的调用关系\" class=\"headerlink\" title=\"MVP（Passive View）的调用关系\"></a>MVP（Passive View）的调用关系</h4><p><img src=\"https://ws4.sinaimg.cn/large/006tKfTcgy1fk7edqp1frj310u0t8jts.jpg\" alt=\"MVP（Passive View）的调用关系\"></p>\n<p>view和model 完全解耦后，model更新是如何同步view的呢？ 是通过presenter。<br>mvc 中是model更新后通知view更新。mvp中是model更新后，通过观察者告知presenter而不是view了。presenter获取到Model变更的消息以后，通过View提供的接口更新界面。</p>\n<h4 id=\"MVP（Passive-View）的优缺点（以下直接引用）\"><a href=\"#MVP（Passive-View）的优缺点（以下直接引用）\" class=\"headerlink\" title=\"MVP（Passive View）的优缺点（以下直接引用）\"></a>MVP（Passive View）的优缺点（<a href=\"https://github.com/livoras/blog/issues/11\">以下直接引用</a>）</h4><h5 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h5><ul>\n<li>便于测试。Presenter对View是通过接口进行，在对Presenter进行不依赖UI环境的单元测试的时候。可以通过Mock一个View对象，这个对象只需要实现了View的接口即可。然后依赖注入到Presenter中，单元测试的时候就可以完整的测试Presenter应用逻辑的正确性。这里根据上面的例子给出了Presenter的单元测试样例。</li>\n<li>View可以进行组件化。在MVP当中，View不依赖Model。这样就可以让View从特定的业务场景中脱离出来，可以说View可以做到对业务完全无知。它只需要提供一系列接口提供给上层操作。这样就可以做到高度可复用的View组件。</li>\n</ul>\n<h5 id=\"缺点：\"><a href=\"#缺点：\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h5><ul>\n<li>Presenter中除了应用逻辑以外，还有大量的View-&gt;Model，Model-&gt;View的手动同步逻辑，造成Presenter比较笨重，维护起来会比较困难。</li>\n</ul>\n<p>//todo: 待实例验证优缺点 </p>\n<h3 id=\"资料\"><a href=\"#资料\" class=\"headerlink\" title=\"资料\"></a>资料</h3><ul>\n<li>winter <a href=\"http://www.cnblogs.com/winter-cn/p/4285171.html\">http://www.cnblogs.com/winter-cn/p/4285171.html</a></li>\n<li>EFE <a href=\"http://efe.baidu.com/blog/mvc-deformation/\">http://efe.baidu.com/blog/mvc-deformation/</a></li>\n<li><a href=\"https://github.com/livoras/blog/issues/11\">https://github.com/livoras/blog/issues/11</a></li>\n<li><a href=\"https://speakerdeck.com/jaceju/understanding-the-mvc-mvp-mvvm-in-javascript\">https://speakerdeck.com/jaceju/understanding-the-mvc-mvp-mvvm-in-javascript</a></li>\n</ul>"},{"title":"深入理解JSX","date":"2017-07-09T16:06:54.000Z","_content":"\n### JSX 是啥?\n\n>  JSX = JS + XML \n\nJSX提供了一种可以在JS里写XML的语法。\n\n### JSX的运行环境 \n> 没有环境可以直接直接执行JSX代码 \n\n<!-- more -->\n\n最终JSX代码在运行前都被转换成了JS。转换方式：\n \n  * 静态编译器编译（工具babel）\n  * 运行期通过jsxtransform.js 进行转换。（已被facebook废弃，性能问题）\n\n思考：浏览器或者js引擎为什么不直接支持jsx? -->继续看下边\n\n### JSX的由来\n\nJSX是伴随着facebook的javascript类库 react 的出现被发明的。jsx 的出现和虚拟DOM有直接关系的。\n##### 一句话介绍虚拟DOM：\n>在内存中创建的描述DOM节点的js对象。为了减少对实际DOM的操作从而提升性能。（这里可以先不管什么是虚拟DOM）\n\n##### 如何创建虚拟DOM：\n\n``` javascript \n    var child1 = React.createElement('li', null, 'First Text Content');\n    var child2 = React.createElement('li', null, 'Second Text Content');\n    var root = React.createElement('ul', { className: 'my-list' }, child1, child2); \n```\n\n==>   '虚拟Dom对象 ' ==>  \n\n``` html\n    <ul class=\"my-list\">\n      <li> 'First Text Content' </li>\n      <li> 'Second Text Content' </li>\n    </ul>\n```\n\n使用这样的机制，我们完全可以用JavaScript构建完整的界面DOM树，但是代码编写麻烦，可读性差（`IOS类似，ios是否可以借鉴jsx?`）。于是React发明了JSX，利用更友好的HTML语法来创建虚拟DOM：\n\n\n``` html\n      var root =(\n          <ul className=\"my-list\">\n            <li>First Text Content</li>\n            <li>Second Text Content</li>\n          </ul>\n    );\n```\n##### 一句话总结jsx存在的意义\n> 让我们更直观的愉快的写代码。\n\n前端界面的最基本功能在于展现数据，为此大多数框架都使用了模板引擎，就对应了自己的模板语法：如angular.js\n\n\n``` html\n    <div ng-if=\"person != null\">\n        Welcome back, <b>{{person.firstName}} {{person.lastName}}</b>!\n    </div>\n    <div ng-if=\"person == null\">\n        Please log in.\n    </div>\n```\njsx的优势之一就是不需要掌握一门模板语法。如果说掌握一种模板语言并不是很大的问题，那么其实由模板带来的架构复杂性则是让框架也变得复杂的重要原因：\nhttp://www.infoq.com/cn/articles/react-jsx-and-component\n\nReact直接放弃了模板而发明了JSX。\n\n### JSX的语法  \n这里不会对jsx语法详细介绍，只介绍一些注意点。[详情](https://facebook.github.io/react/docs/jsx-in-depth.html)\n\n#### 一、通过{}插入js表达式 \n\n``` html\n    var person = <Person name={window.isLoggedIn ? window.name : ''} />;\n```\n\n    这个功能就很强大了，你可以尽情的使用js的功能： \n\n#### 二、组件tag 大小写敏感\n这里还不是一般的敏感，大小写是有限制的。所有对应证实节点的tag 要小写开头，所有组件节点tag 要大写开头。大小写是告诉转换工具（babel）要如何转换。我们看个例子：\n\n\n``` html \n    React.render(<div>xxx</div>)\n    \n    React.render(<App/>)\n```\n\n 转换后==>\n\n\n``` javascript \n    React.render(React.createElement(\n      \"div\", //小写tag会编成字符串\n      null,\n      \"xxx\"\n    ));\n\n    React.render(React.createElement(App, null));//大写编成变量\n```\n一句话总结标签大小写注意点：  \n> 可以不用关心这些细节，这些都是给框架用的，只需要知道何时大写何时小写就好。\n    \n#### 三、绑定事件\n##### 绑定方式：\n\n``` html\n     <div onClick={this.handler.bind(this)}>Submit</div>\n```\n\n##### 无需手动解绑事件\n在JSX中你不需要关心什么时机去移除事件绑定，因为React会在对应的真实DOM节点移除时就自动解除了事件绑定。\n\n##### 事件代理\nReact并不会真正的绑定事件到每一个具体的元素上，而是采用事件代理的模式：在根节点document上为每种事件添加唯一的Listener，然后通过事件的target找到真实的触发元素。这样从触发元素到顶层节点之间的所有节点如果有绑定这个事件，React都会触发对应的事件处理函数。这就是所谓的React模拟事件系统。\n\n#### 四、在JSX中使用样式\n通常情况下我们应该把样式写到css文件里，当有时对于特定组件而言其样式比较简单且或固定，那么可将其直接写在jsx中。在jsx中通过style属性来定义，但和真实DOM不同的是，属性值不能是字符串而必须为对象。\n\n``` html\n    <div style={{color: '#ff0000', fontSize: '14px'}}>Hello World.</div> \n```\n这里有两层大括号，外面的大括号是JSX的语法，变的大括号是js对象。\n\n##### 属性名转驼峰\n在JSX中可以使用所有的的样式，基本上属性名的转换规范就是将其写成驼峰写法，如background-color --> backgroundColor。\n \n \n### JSX 与babel \n如何让babel将JSX传换成js时指定自定义方法名而不是React.createElement()。\n这个babel支持配置：.babelrc文件 [详情](https://babeljs.io/docs/plugins/transform-react-jsx/)\n\n``` json\n    {\n          \"plugins\": [\n            [\"transform-react-jsx\", {\n              \"pragma\": \"dom\" // default pragma is React.createElement\n            }]\n          ]\n    }\n```\n\n\n","source":"_posts/深入理解JSX.md","raw":"---\ntitle: 深入理解JSX\ndate: 2017-07-10 00:06:54\ncategories: \n- javascript \n- React\ntags: \n- JSX \n- React\n---\n\n### JSX 是啥?\n\n>  JSX = JS + XML \n\nJSX提供了一种可以在JS里写XML的语法。\n\n### JSX的运行环境 \n> 没有环境可以直接直接执行JSX代码 \n\n<!-- more -->\n\n最终JSX代码在运行前都被转换成了JS。转换方式：\n \n  * 静态编译器编译（工具babel）\n  * 运行期通过jsxtransform.js 进行转换。（已被facebook废弃，性能问题）\n\n思考：浏览器或者js引擎为什么不直接支持jsx? -->继续看下边\n\n### JSX的由来\n\nJSX是伴随着facebook的javascript类库 react 的出现被发明的。jsx 的出现和虚拟DOM有直接关系的。\n##### 一句话介绍虚拟DOM：\n>在内存中创建的描述DOM节点的js对象。为了减少对实际DOM的操作从而提升性能。（这里可以先不管什么是虚拟DOM）\n\n##### 如何创建虚拟DOM：\n\n``` javascript \n    var child1 = React.createElement('li', null, 'First Text Content');\n    var child2 = React.createElement('li', null, 'Second Text Content');\n    var root = React.createElement('ul', { className: 'my-list' }, child1, child2); \n```\n\n==>   '虚拟Dom对象 ' ==>  \n\n``` html\n    <ul class=\"my-list\">\n      <li> 'First Text Content' </li>\n      <li> 'Second Text Content' </li>\n    </ul>\n```\n\n使用这样的机制，我们完全可以用JavaScript构建完整的界面DOM树，但是代码编写麻烦，可读性差（`IOS类似，ios是否可以借鉴jsx?`）。于是React发明了JSX，利用更友好的HTML语法来创建虚拟DOM：\n\n\n``` html\n      var root =(\n          <ul className=\"my-list\">\n            <li>First Text Content</li>\n            <li>Second Text Content</li>\n          </ul>\n    );\n```\n##### 一句话总结jsx存在的意义\n> 让我们更直观的愉快的写代码。\n\n前端界面的最基本功能在于展现数据，为此大多数框架都使用了模板引擎，就对应了自己的模板语法：如angular.js\n\n\n``` html\n    <div ng-if=\"person != null\">\n        Welcome back, <b>{{person.firstName}} {{person.lastName}}</b>!\n    </div>\n    <div ng-if=\"person == null\">\n        Please log in.\n    </div>\n```\njsx的优势之一就是不需要掌握一门模板语法。如果说掌握一种模板语言并不是很大的问题，那么其实由模板带来的架构复杂性则是让框架也变得复杂的重要原因：\nhttp://www.infoq.com/cn/articles/react-jsx-and-component\n\nReact直接放弃了模板而发明了JSX。\n\n### JSX的语法  \n这里不会对jsx语法详细介绍，只介绍一些注意点。[详情](https://facebook.github.io/react/docs/jsx-in-depth.html)\n\n#### 一、通过{}插入js表达式 \n\n``` html\n    var person = <Person name={window.isLoggedIn ? window.name : ''} />;\n```\n\n    这个功能就很强大了，你可以尽情的使用js的功能： \n\n#### 二、组件tag 大小写敏感\n这里还不是一般的敏感，大小写是有限制的。所有对应证实节点的tag 要小写开头，所有组件节点tag 要大写开头。大小写是告诉转换工具（babel）要如何转换。我们看个例子：\n\n\n``` html \n    React.render(<div>xxx</div>)\n    \n    React.render(<App/>)\n```\n\n 转换后==>\n\n\n``` javascript \n    React.render(React.createElement(\n      \"div\", //小写tag会编成字符串\n      null,\n      \"xxx\"\n    ));\n\n    React.render(React.createElement(App, null));//大写编成变量\n```\n一句话总结标签大小写注意点：  \n> 可以不用关心这些细节，这些都是给框架用的，只需要知道何时大写何时小写就好。\n    \n#### 三、绑定事件\n##### 绑定方式：\n\n``` html\n     <div onClick={this.handler.bind(this)}>Submit</div>\n```\n\n##### 无需手动解绑事件\n在JSX中你不需要关心什么时机去移除事件绑定，因为React会在对应的真实DOM节点移除时就自动解除了事件绑定。\n\n##### 事件代理\nReact并不会真正的绑定事件到每一个具体的元素上，而是采用事件代理的模式：在根节点document上为每种事件添加唯一的Listener，然后通过事件的target找到真实的触发元素。这样从触发元素到顶层节点之间的所有节点如果有绑定这个事件，React都会触发对应的事件处理函数。这就是所谓的React模拟事件系统。\n\n#### 四、在JSX中使用样式\n通常情况下我们应该把样式写到css文件里，当有时对于特定组件而言其样式比较简单且或固定，那么可将其直接写在jsx中。在jsx中通过style属性来定义，但和真实DOM不同的是，属性值不能是字符串而必须为对象。\n\n``` html\n    <div style={{color: '#ff0000', fontSize: '14px'}}>Hello World.</div> \n```\n这里有两层大括号，外面的大括号是JSX的语法，变的大括号是js对象。\n\n##### 属性名转驼峰\n在JSX中可以使用所有的的样式，基本上属性名的转换规范就是将其写成驼峰写法，如background-color --> backgroundColor。\n \n \n### JSX 与babel \n如何让babel将JSX传换成js时指定自定义方法名而不是React.createElement()。\n这个babel支持配置：.babelrc文件 [详情](https://babeljs.io/docs/plugins/transform-react-jsx/)\n\n``` json\n    {\n          \"plugins\": [\n            [\"transform-react-jsx\", {\n              \"pragma\": \"dom\" // default pragma is React.createElement\n            }]\n          ]\n    }\n```\n\n\n","slug":"深入理解JSX","published":1,"updated":"2018-03-10T16:05:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjelnshcw000c3gffwmx3n5ng","content":"<h3 id=\"JSX-是啥\"><a href=\"#JSX-是啥\" class=\"headerlink\" title=\"JSX 是啥?\"></a>JSX 是啥?</h3><blockquote>\n<p> JSX = JS + XML </p>\n</blockquote>\n<p>JSX提供了一种可以在JS里写XML的语法。</p>\n<h3 id=\"JSX的运行环境\"><a href=\"#JSX的运行环境\" class=\"headerlink\" title=\"JSX的运行环境\"></a>JSX的运行环境</h3><blockquote>\n<p>没有环境可以直接直接执行JSX代码 </p>\n</blockquote>\n<a id=\"more\"></a>\n<p>最终JSX代码在运行前都被转换成了JS。转换方式：</p>\n<ul>\n<li>静态编译器编译（工具babel）</li>\n<li>运行期通过jsxtransform.js 进行转换。（已被facebook废弃，性能问题）</li>\n</ul>\n<p>思考：浏览器或者js引擎为什么不直接支持jsx? –&gt;继续看下边</p>\n<h3 id=\"JSX的由来\"><a href=\"#JSX的由来\" class=\"headerlink\" title=\"JSX的由来\"></a>JSX的由来</h3><p>JSX是伴随着facebook的javascript类库 react 的出现被发明的。jsx 的出现和虚拟DOM有直接关系的。</p>\n<h5 id=\"一句话介绍虚拟DOM：\"><a href=\"#一句话介绍虚拟DOM：\" class=\"headerlink\" title=\"一句话介绍虚拟DOM：\"></a>一句话介绍虚拟DOM：</h5><blockquote>\n<p>在内存中创建的描述DOM节点的js对象。为了减少对实际DOM的操作从而提升性能。（这里可以先不管什么是虚拟DOM）</p>\n</blockquote>\n<h5 id=\"如何创建虚拟DOM：\"><a href=\"#如何创建虚拟DOM：\" class=\"headerlink\" title=\"如何创建虚拟DOM：\"></a>如何创建虚拟DOM：</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> child1 = React.createElement(<span class=\"string\">'li'</span>, <span class=\"literal\">null</span>, <span class=\"string\">'First Text Content'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> child2 = React.createElement(<span class=\"string\">'li'</span>, <span class=\"literal\">null</span>, <span class=\"string\">'Second Text Content'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> root = React.createElement(<span class=\"string\">'ul'</span>, &#123; <span class=\"attr\">className</span>: <span class=\"string\">'my-list'</span> &#125;, child1, child2);</div></pre></td></tr></table></figure>\n<p>==&gt;   ‘虚拟Dom对象 ‘ ==&gt;  </p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">class</span>=<span class=\"string\">\"my-list\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span> 'First Text Content' <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span> 'Second Text Content' <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>使用这样的机制，我们完全可以用JavaScript构建完整的界面DOM树，但是代码编写麻烦，可读性差（<code>IOS类似，ios是否可以借鉴jsx?</code>）。于是React发明了JSX，利用更友好的HTML语法来创建虚拟DOM：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">  var root =(</div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">className</span>=<span class=\"string\">\"my-list\"</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>First Text Content<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>Second Text Content<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></div><div class=\"line\">);</div></pre></td></tr></table></figure>\n<h5 id=\"一句话总结jsx存在的意义\"><a href=\"#一句话总结jsx存在的意义\" class=\"headerlink\" title=\"一句话总结jsx存在的意义\"></a>一句话总结jsx存在的意义</h5><blockquote>\n<p>让我们更直观的愉快的写代码。</p>\n</blockquote>\n<p>前端界面的最基本功能在于展现数据，为此大多数框架都使用了模板引擎，就对应了自己的模板语法：如angular.js</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">ng-if</span>=<span class=\"string\">\"person != null\"</span>&gt;</span></div><div class=\"line\">    Welcome back, <span class=\"tag\">&lt;<span class=\"name\">b</span>&gt;</span>&#123;&#123;person.firstName&#125;&#125; &#123;&#123;person.lastName&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">b</span>&gt;</span>!</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">ng-if</span>=<span class=\"string\">\"person == null\"</span>&gt;</span></div><div class=\"line\">    Please log in.</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>jsx的优势之一就是不需要掌握一门模板语法。如果说掌握一种模板语言并不是很大的问题，那么其实由模板带来的架构复杂性则是让框架也变得复杂的重要原因：<br><a href=\"http://www.infoq.com/cn/articles/react-jsx-and-component\" target=\"_blank\" rel=\"external\">http://www.infoq.com/cn/articles/react-jsx-and-component</a></p>\n<p>React直接放弃了模板而发明了JSX。</p>\n<h3 id=\"JSX的语法\"><a href=\"#JSX的语法\" class=\"headerlink\" title=\"JSX的语法\"></a>JSX的语法</h3><p>这里不会对jsx语法详细介绍，只介绍一些注意点。<a href=\"https://facebook.github.io/react/docs/jsx-in-depth.html\" target=\"_blank\" rel=\"external\">详情</a></p>\n<h4 id=\"一、通过-插入js表达式\"><a href=\"#一、通过-插入js表达式\" class=\"headerlink\" title=\"一、通过{}插入js表达式\"></a>一、通过{}插入js表达式</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">var person = <span class=\"tag\">&lt;<span class=\"name\">Person</span> <span class=\"attr\">name</span>=<span class=\"string\">&#123;window.isLoggedIn</span> ? <span class=\"attr\">window.name</span> <span class=\"attr\">:</span> ''&#125; /&gt;</span>;</div></pre></td></tr></table></figure>\n<pre><code>这个功能就很强大了，你可以尽情的使用js的功能： \n</code></pre><h4 id=\"二、组件tag-大小写敏感\"><a href=\"#二、组件tag-大小写敏感\" class=\"headerlink\" title=\"二、组件tag 大小写敏感\"></a>二、组件tag 大小写敏感</h4><p>这里还不是一般的敏感，大小写是有限制的。所有对应证实节点的tag 要小写开头，所有组件节点tag 要大写开头。大小写是告诉转换工具（babel）要如何转换。我们看个例子：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">React.render(<span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>xxx<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>)</div><div class=\"line\"></div><div class=\"line\">React.render(<span class=\"tag\">&lt;<span class=\"name\">App</span>/&gt;</span>)</div></pre></td></tr></table></figure>\n<p> 转换后==&gt;</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">React.render(React.createElement(</div><div class=\"line\">  <span class=\"string\">\"div\"</span>, <span class=\"comment\">//小写tag会编成字符串</span></div><div class=\"line\">  <span class=\"literal\">null</span>,</div><div class=\"line\">  <span class=\"string\">\"xxx\"</span></div><div class=\"line\">));</div><div class=\"line\"></div><div class=\"line\">React.render(React.createElement(App, <span class=\"literal\">null</span>));<span class=\"comment\">//大写编成变量</span></div></pre></td></tr></table></figure>\n<p>一句话总结标签大小写注意点：  </p>\n<blockquote>\n<p>可以不用关心这些细节，这些都是给框架用的，只需要知道何时大写何时小写就好。</p>\n</blockquote>\n<h4 id=\"三、绑定事件\"><a href=\"#三、绑定事件\" class=\"headerlink\" title=\"三、绑定事件\"></a>三、绑定事件</h4><h5 id=\"绑定方式：\"><a href=\"#绑定方式：\" class=\"headerlink\" title=\"绑定方式：\"></a>绑定方式：</h5><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;this.handler.bind(this)&#125;</span>&gt;</span>Submit<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<h5 id=\"无需手动解绑事件\"><a href=\"#无需手动解绑事件\" class=\"headerlink\" title=\"无需手动解绑事件\"></a>无需手动解绑事件</h5><p>在JSX中你不需要关心什么时机去移除事件绑定，因为React会在对应的真实DOM节点移除时就自动解除了事件绑定。</p>\n<h5 id=\"事件代理\"><a href=\"#事件代理\" class=\"headerlink\" title=\"事件代理\"></a>事件代理</h5><p>React并不会真正的绑定事件到每一个具体的元素上，而是采用事件代理的模式：在根节点document上为每种事件添加唯一的Listener，然后通过事件的target找到真实的触发元素。这样从触发元素到顶层节点之间的所有节点如果有绑定这个事件，React都会触发对应的事件处理函数。这就是所谓的React模拟事件系统。</p>\n<h4 id=\"四、在JSX中使用样式\"><a href=\"#四、在JSX中使用样式\" class=\"headerlink\" title=\"四、在JSX中使用样式\"></a>四、在JSX中使用样式</h4><p>通常情况下我们应该把样式写到css文件里，当有时对于特定组件而言其样式比较简单且或固定，那么可将其直接写在jsx中。在jsx中通过style属性来定义，但和真实DOM不同的是，属性值不能是字符串而必须为对象。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;color:</span> '#<span class=\"attr\">ff0000</span>', <span class=\"attr\">fontSize:</span> '<span class=\"attr\">14px</span>'&#125;&#125;&gt;</span>Hello World.<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>这里有两层大括号，外面的大括号是JSX的语法，变的大括号是js对象。</p>\n<h5 id=\"属性名转驼峰\"><a href=\"#属性名转驼峰\" class=\"headerlink\" title=\"属性名转驼峰\"></a>属性名转驼峰</h5><p>在JSX中可以使用所有的的样式，基本上属性名的转换规范就是将其写成驼峰写法，如background-color –&gt; backgroundColor。</p>\n<h3 id=\"JSX-与babel\"><a href=\"#JSX-与babel\" class=\"headerlink\" title=\"JSX 与babel\"></a>JSX 与babel</h3><p>如何让babel将JSX传换成js时指定自定义方法名而不是React.createElement()。<br>这个babel支持配置：.babelrc文件 <a href=\"https://babeljs.io/docs/plugins/transform-react-jsx/\" target=\"_blank\" rel=\"external\">详情</a></p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">      <span class=\"attr\">\"plugins\"</span>: [</div><div class=\"line\">        [<span class=\"string\">\"transform-react-jsx\"</span>, &#123;</div><div class=\"line\">          <span class=\"attr\">\"pragma\"</span>: <span class=\"string\">\"dom\"</span> // default pragma is React.createElement</div><div class=\"line\">        &#125;]</div><div class=\"line\">      ]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","excerpt":"<h3 id=\"JSX-是啥\"><a href=\"#JSX-是啥\" class=\"headerlink\" title=\"JSX 是啥?\"></a>JSX 是啥?</h3><blockquote>\n<p> JSX = JS + XML </p>\n</blockquote>\n<p>JSX提供了一种可以在JS里写XML的语法。</p>\n<h3 id=\"JSX的运行环境\"><a href=\"#JSX的运行环境\" class=\"headerlink\" title=\"JSX的运行环境\"></a>JSX的运行环境</h3><blockquote>\n<p>没有环境可以直接直接执行JSX代码 </p>\n</blockquote>","more":"<p>最终JSX代码在运行前都被转换成了JS。转换方式：</p>\n<ul>\n<li>静态编译器编译（工具babel）</li>\n<li>运行期通过jsxtransform.js 进行转换。（已被facebook废弃，性能问题）</li>\n</ul>\n<p>思考：浏览器或者js引擎为什么不直接支持jsx? –&gt;继续看下边</p>\n<h3 id=\"JSX的由来\"><a href=\"#JSX的由来\" class=\"headerlink\" title=\"JSX的由来\"></a>JSX的由来</h3><p>JSX是伴随着facebook的javascript类库 react 的出现被发明的。jsx 的出现和虚拟DOM有直接关系的。</p>\n<h5 id=\"一句话介绍虚拟DOM：\"><a href=\"#一句话介绍虚拟DOM：\" class=\"headerlink\" title=\"一句话介绍虚拟DOM：\"></a>一句话介绍虚拟DOM：</h5><blockquote>\n<p>在内存中创建的描述DOM节点的js对象。为了减少对实际DOM的操作从而提升性能。（这里可以先不管什么是虚拟DOM）</p>\n</blockquote>\n<h5 id=\"如何创建虚拟DOM：\"><a href=\"#如何创建虚拟DOM：\" class=\"headerlink\" title=\"如何创建虚拟DOM：\"></a>如何创建虚拟DOM：</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> child1 = React.createElement(<span class=\"string\">'li'</span>, <span class=\"literal\">null</span>, <span class=\"string\">'First Text Content'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> child2 = React.createElement(<span class=\"string\">'li'</span>, <span class=\"literal\">null</span>, <span class=\"string\">'Second Text Content'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> root = React.createElement(<span class=\"string\">'ul'</span>, &#123; <span class=\"attr\">className</span>: <span class=\"string\">'my-list'</span> &#125;, child1, child2);</div></pre></td></tr></table></figure>\n<p>==&gt;   ‘虚拟Dom对象 ‘ ==&gt;  </p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">class</span>=<span class=\"string\">\"my-list\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span> 'First Text Content' <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span> 'Second Text Content' <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>使用这样的机制，我们完全可以用JavaScript构建完整的界面DOM树，但是代码编写麻烦，可读性差（<code>IOS类似，ios是否可以借鉴jsx?</code>）。于是React发明了JSX，利用更友好的HTML语法来创建虚拟DOM：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">  var root =(</div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">className</span>=<span class=\"string\">\"my-list\"</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>First Text Content<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>Second Text Content<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></div><div class=\"line\">);</div></pre></td></tr></table></figure>\n<h5 id=\"一句话总结jsx存在的意义\"><a href=\"#一句话总结jsx存在的意义\" class=\"headerlink\" title=\"一句话总结jsx存在的意义\"></a>一句话总结jsx存在的意义</h5><blockquote>\n<p>让我们更直观的愉快的写代码。</p>\n</blockquote>\n<p>前端界面的最基本功能在于展现数据，为此大多数框架都使用了模板引擎，就对应了自己的模板语法：如angular.js</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">ng-if</span>=<span class=\"string\">\"person != null\"</span>&gt;</span></div><div class=\"line\">    Welcome back, <span class=\"tag\">&lt;<span class=\"name\">b</span>&gt;</span>&#123;&#123;person.firstName&#125;&#125; &#123;&#123;person.lastName&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">b</span>&gt;</span>!</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">ng-if</span>=<span class=\"string\">\"person == null\"</span>&gt;</span></div><div class=\"line\">    Please log in.</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>jsx的优势之一就是不需要掌握一门模板语法。如果说掌握一种模板语言并不是很大的问题，那么其实由模板带来的架构复杂性则是让框架也变得复杂的重要原因：<br><a href=\"http://www.infoq.com/cn/articles/react-jsx-and-component\">http://www.infoq.com/cn/articles/react-jsx-and-component</a></p>\n<p>React直接放弃了模板而发明了JSX。</p>\n<h3 id=\"JSX的语法\"><a href=\"#JSX的语法\" class=\"headerlink\" title=\"JSX的语法\"></a>JSX的语法</h3><p>这里不会对jsx语法详细介绍，只介绍一些注意点。<a href=\"https://facebook.github.io/react/docs/jsx-in-depth.html\">详情</a></p>\n<h4 id=\"一、通过-插入js表达式\"><a href=\"#一、通过-插入js表达式\" class=\"headerlink\" title=\"一、通过{}插入js表达式\"></a>一、通过{}插入js表达式</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">var person = <span class=\"tag\">&lt;<span class=\"name\">Person</span> <span class=\"attr\">name</span>=<span class=\"string\">&#123;window.isLoggedIn</span> ? <span class=\"attr\">window.name</span> <span class=\"attr\">:</span> ''&#125; /&gt;</span>;</div></pre></td></tr></table></figure>\n<pre><code>这个功能就很强大了，你可以尽情的使用js的功能： \n</code></pre><h4 id=\"二、组件tag-大小写敏感\"><a href=\"#二、组件tag-大小写敏感\" class=\"headerlink\" title=\"二、组件tag 大小写敏感\"></a>二、组件tag 大小写敏感</h4><p>这里还不是一般的敏感，大小写是有限制的。所有对应证实节点的tag 要小写开头，所有组件节点tag 要大写开头。大小写是告诉转换工具（babel）要如何转换。我们看个例子：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">React.render(<span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>xxx<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>)</div><div class=\"line\"></div><div class=\"line\">React.render(<span class=\"tag\">&lt;<span class=\"name\">App</span>/&gt;</span>)</div></pre></td></tr></table></figure>\n<p> 转换后==&gt;</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">React.render(React.createElement(</div><div class=\"line\">  <span class=\"string\">\"div\"</span>, <span class=\"comment\">//小写tag会编成字符串</span></div><div class=\"line\">  <span class=\"literal\">null</span>,</div><div class=\"line\">  <span class=\"string\">\"xxx\"</span></div><div class=\"line\">));</div><div class=\"line\"></div><div class=\"line\">React.render(React.createElement(App, <span class=\"literal\">null</span>));<span class=\"comment\">//大写编成变量</span></div></pre></td></tr></table></figure>\n<p>一句话总结标签大小写注意点：  </p>\n<blockquote>\n<p>可以不用关心这些细节，这些都是给框架用的，只需要知道何时大写何时小写就好。</p>\n</blockquote>\n<h4 id=\"三、绑定事件\"><a href=\"#三、绑定事件\" class=\"headerlink\" title=\"三、绑定事件\"></a>三、绑定事件</h4><h5 id=\"绑定方式：\"><a href=\"#绑定方式：\" class=\"headerlink\" title=\"绑定方式：\"></a>绑定方式：</h5><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;this.handler.bind(this)&#125;</span>&gt;</span>Submit<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<h5 id=\"无需手动解绑事件\"><a href=\"#无需手动解绑事件\" class=\"headerlink\" title=\"无需手动解绑事件\"></a>无需手动解绑事件</h5><p>在JSX中你不需要关心什么时机去移除事件绑定，因为React会在对应的真实DOM节点移除时就自动解除了事件绑定。</p>\n<h5 id=\"事件代理\"><a href=\"#事件代理\" class=\"headerlink\" title=\"事件代理\"></a>事件代理</h5><p>React并不会真正的绑定事件到每一个具体的元素上，而是采用事件代理的模式：在根节点document上为每种事件添加唯一的Listener，然后通过事件的target找到真实的触发元素。这样从触发元素到顶层节点之间的所有节点如果有绑定这个事件，React都会触发对应的事件处理函数。这就是所谓的React模拟事件系统。</p>\n<h4 id=\"四、在JSX中使用样式\"><a href=\"#四、在JSX中使用样式\" class=\"headerlink\" title=\"四、在JSX中使用样式\"></a>四、在JSX中使用样式</h4><p>通常情况下我们应该把样式写到css文件里，当有时对于特定组件而言其样式比较简单且或固定，那么可将其直接写在jsx中。在jsx中通过style属性来定义，但和真实DOM不同的是，属性值不能是字符串而必须为对象。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;color:</span> '#<span class=\"attr\">ff0000</span>', <span class=\"attr\">fontSize:</span> '<span class=\"attr\">14px</span>'&#125;&#125;&gt;</span>Hello World.<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>这里有两层大括号，外面的大括号是JSX的语法，变的大括号是js对象。</p>\n<h5 id=\"属性名转驼峰\"><a href=\"#属性名转驼峰\" class=\"headerlink\" title=\"属性名转驼峰\"></a>属性名转驼峰</h5><p>在JSX中可以使用所有的的样式，基本上属性名的转换规范就是将其写成驼峰写法，如background-color –&gt; backgroundColor。</p>\n<h3 id=\"JSX-与babel\"><a href=\"#JSX-与babel\" class=\"headerlink\" title=\"JSX 与babel\"></a>JSX 与babel</h3><p>如何让babel将JSX传换成js时指定自定义方法名而不是React.createElement()。<br>这个babel支持配置：.babelrc文件 <a href=\"https://babeljs.io/docs/plugins/transform-react-jsx/\">详情</a></p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">      <span class=\"attr\">\"plugins\"</span>: [</div><div class=\"line\">        [<span class=\"string\">\"transform-react-jsx\"</span>, &#123;</div><div class=\"line\">          <span class=\"attr\">\"pragma\"</span>: <span class=\"string\">\"dom\"</span> // default pragma is React.createElement</div><div class=\"line\">        &#125;]</div><div class=\"line\">      ]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"理解Flux","date":"2017-09-16T13:16:08.000Z","_content":"\n### 什么是flux\nflux是一种架构模式，用来指导（或约束）我们的软件结构。其核心是“单向数据流模式”。同MVC架构是同样的存在。\n(举例 ：React 说自己是 MVC 里面 V 的部分，那么 Flux 就相当于添加 M 和 C 的部分)\n\n### 单向数据流\nFlux 的核心“单向数据流“的结构和流程：\n\n\n>   Action --> Dispatcher --> Store --> View\n\n<!-- more -->\n\n* 首先要有 action，通过定义一些 action creator方法 根据需要创建 Action。\n* View 层通过用户交互（比如 onClick）会触发 Action\n* Dispatcher 会分发 所触发的 Action 到所有注册的 Store 的回调函数。\n* Store 回调函数根据接收的 Action 更新自身数据之后会触发一个 change 事件通知 View 数据更改了\n* View 会监听这个 change 事件，拿到对应的新数据并 更新组件 UI(如调用 setState)\n\n\n### 基本概念\n\n* View： 视图层 （视图组件）\n* Action（动作）：视图层发出的消息 ：包括消息类型和消息的数据。\n* Dispatcher（派发器）：用来接收Actions、执行回调函数。\n* Store：包含应用状态和逻辑。\n\n#### Action （每个Store有一堆）\n\n每个Action都是一个对象，包含一个actionType属性（说明动作的类型）和一些其他属性（用来传递数据）。\n\n\n\n#### Dispatcher (全局一个)\nDispatcher 是中心枢纽，其`作用`是将 Action 派发到 Store，管理所有数据流向。Dispatcher `本质`上就是一个事件系统。\n你可以把它看作一个路由器，负责在 View 和 Store 之间，建立 Action 的正确传递路线。\n以Facebook 的 Dispatcher 库为例，Dispatcher有两个核心方法：\n\n*  dispatch：派发action到store 注册的回调。\n*  register： store 会调用该方法注册其回调，回调里对不同的action做处理。\n\nDispatcher 只用来派发 Action，不应该有其他逻辑。且Dispatcher 只能有一个，而且是全局的。\n各Store在dispatcher上注册自己的回调，这样dispatcher上就有一张回调注册表，与各Store建立联系。\n\n\n#### Store（多个） 响应action(事件)\nStores 包含应用的状态和逻辑，不同的 Store 管理应用中不同部分的状态。\nStore响应 Dispatched Actions （被分发的事件）。\n重点：应用中唯一知道如何更新数据的就是 Store。\nstore在dispatcher上注册的回调接受一个action参数，回调里面是一个switch语句，根据action的type分发给具体state更新方法，store更新完毕后，通过广播事件来告诉view某些状态变了，对应的view取新的状态更新自己。\n\n\n#### view （多个）\n\n接收用户操作触发action。 action通过dispatcher派发到store里处理更新数据状态，并发出改变的通知，view获取新的状态更新自己。\n\n\n\n### 有什么好处？\n\n这里引用尤雨溪知乎的一个回答：\n\n> 1. 视图组件变得很薄，只包含了渲染逻辑和触发 action 这两个职责，即所谓 \"dumb components\"。（`个人理解：数据层和view层分离`）\n> 2. 要理解一个 store 可能发生的状态变化，只需要看它所注册的 actions 回调就可以。（`个人理解：和1说的一回事，关注点分离后，是的结构更清晰，代码可读性和可维护性提高`）\n> 3. 任何状态的变化都必须通过 action 触发，而 action 又必须通过 dispatcher 走，所以整个应用的每一次状态变化都会从同一个地方流过。其实 Flux 和传统 MVC 最不一样的就在这里了。React 在宣传的时候一直强调的一点就是 “理解你的应用的状态变化是很困难的 (managing state changing over time is hard)”，Flux 的意义就在于强制让所有的状态变化都必须留下一笔记录，这样就可以利用这个来做各种 debug 工具、历史回滚等等。（`个人理解：使数据可预测`）\n\n\n\n### 参考资料\n具体实例可以参考阮老师的这边文章 ：[Flux 架构入门教程](http://www.ruanyifeng.com/blog/2016/01/flux.html)\n\n这篇总结的非常到位，但是前提是得你先大概理解了flux：[flux总结](http://www.ayqy.net/blog/flux/)\n\nfacebook 官方提供的 [dispatcher](https://github.com/facebook/flux/blob/master/src/Dispatcher.js)\n\n\n\n\n\n","source":"_posts/理解Flux.md","raw":"---\ntitle: 理解Flux\ndate: 2017-09-16 21:16:08\ntags:\n - flux\n - 数据流\ncategories: \n - 前端状态管理\n---\n\n### 什么是flux\nflux是一种架构模式，用来指导（或约束）我们的软件结构。其核心是“单向数据流模式”。同MVC架构是同样的存在。\n(举例 ：React 说自己是 MVC 里面 V 的部分，那么 Flux 就相当于添加 M 和 C 的部分)\n\n### 单向数据流\nFlux 的核心“单向数据流“的结构和流程：\n\n\n>   Action --> Dispatcher --> Store --> View\n\n<!-- more -->\n\n* 首先要有 action，通过定义一些 action creator方法 根据需要创建 Action。\n* View 层通过用户交互（比如 onClick）会触发 Action\n* Dispatcher 会分发 所触发的 Action 到所有注册的 Store 的回调函数。\n* Store 回调函数根据接收的 Action 更新自身数据之后会触发一个 change 事件通知 View 数据更改了\n* View 会监听这个 change 事件，拿到对应的新数据并 更新组件 UI(如调用 setState)\n\n\n### 基本概念\n\n* View： 视图层 （视图组件）\n* Action（动作）：视图层发出的消息 ：包括消息类型和消息的数据。\n* Dispatcher（派发器）：用来接收Actions、执行回调函数。\n* Store：包含应用状态和逻辑。\n\n#### Action （每个Store有一堆）\n\n每个Action都是一个对象，包含一个actionType属性（说明动作的类型）和一些其他属性（用来传递数据）。\n\n\n\n#### Dispatcher (全局一个)\nDispatcher 是中心枢纽，其`作用`是将 Action 派发到 Store，管理所有数据流向。Dispatcher `本质`上就是一个事件系统。\n你可以把它看作一个路由器，负责在 View 和 Store 之间，建立 Action 的正确传递路线。\n以Facebook 的 Dispatcher 库为例，Dispatcher有两个核心方法：\n\n*  dispatch：派发action到store 注册的回调。\n*  register： store 会调用该方法注册其回调，回调里对不同的action做处理。\n\nDispatcher 只用来派发 Action，不应该有其他逻辑。且Dispatcher 只能有一个，而且是全局的。\n各Store在dispatcher上注册自己的回调，这样dispatcher上就有一张回调注册表，与各Store建立联系。\n\n\n#### Store（多个） 响应action(事件)\nStores 包含应用的状态和逻辑，不同的 Store 管理应用中不同部分的状态。\nStore响应 Dispatched Actions （被分发的事件）。\n重点：应用中唯一知道如何更新数据的就是 Store。\nstore在dispatcher上注册的回调接受一个action参数，回调里面是一个switch语句，根据action的type分发给具体state更新方法，store更新完毕后，通过广播事件来告诉view某些状态变了，对应的view取新的状态更新自己。\n\n\n#### view （多个）\n\n接收用户操作触发action。 action通过dispatcher派发到store里处理更新数据状态，并发出改变的通知，view获取新的状态更新自己。\n\n\n\n### 有什么好处？\n\n这里引用尤雨溪知乎的一个回答：\n\n> 1. 视图组件变得很薄，只包含了渲染逻辑和触发 action 这两个职责，即所谓 \"dumb components\"。（`个人理解：数据层和view层分离`）\n> 2. 要理解一个 store 可能发生的状态变化，只需要看它所注册的 actions 回调就可以。（`个人理解：和1说的一回事，关注点分离后，是的结构更清晰，代码可读性和可维护性提高`）\n> 3. 任何状态的变化都必须通过 action 触发，而 action 又必须通过 dispatcher 走，所以整个应用的每一次状态变化都会从同一个地方流过。其实 Flux 和传统 MVC 最不一样的就在这里了。React 在宣传的时候一直强调的一点就是 “理解你的应用的状态变化是很困难的 (managing state changing over time is hard)”，Flux 的意义就在于强制让所有的状态变化都必须留下一笔记录，这样就可以利用这个来做各种 debug 工具、历史回滚等等。（`个人理解：使数据可预测`）\n\n\n\n### 参考资料\n具体实例可以参考阮老师的这边文章 ：[Flux 架构入门教程](http://www.ruanyifeng.com/blog/2016/01/flux.html)\n\n这篇总结的非常到位，但是前提是得你先大概理解了flux：[flux总结](http://www.ayqy.net/blog/flux/)\n\nfacebook 官方提供的 [dispatcher](https://github.com/facebook/flux/blob/master/src/Dispatcher.js)\n\n\n\n\n\n","slug":"理解Flux","published":1,"updated":"2018-03-10T16:05:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjelnshcz000g3gffhuk6txj6","content":"<h3 id=\"什么是flux\"><a href=\"#什么是flux\" class=\"headerlink\" title=\"什么是flux\"></a>什么是flux</h3><p>flux是一种架构模式，用来指导（或约束）我们的软件结构。其核心是“单向数据流模式”。同MVC架构是同样的存在。<br>(举例 ：React 说自己是 MVC 里面 V 的部分，那么 Flux 就相当于添加 M 和 C 的部分)</p>\n<h3 id=\"单向数据流\"><a href=\"#单向数据流\" class=\"headerlink\" title=\"单向数据流\"></a>单向数据流</h3><p>Flux 的核心“单向数据流“的结构和流程：</p>\n<blockquote>\n<p>  Action –&gt; Dispatcher –&gt; Store –&gt; View</p>\n</blockquote>\n<a id=\"more\"></a>\n<ul>\n<li>首先要有 action，通过定义一些 action creator方法 根据需要创建 Action。</li>\n<li>View 层通过用户交互（比如 onClick）会触发 Action</li>\n<li>Dispatcher 会分发 所触发的 Action 到所有注册的 Store 的回调函数。</li>\n<li>Store 回调函数根据接收的 Action 更新自身数据之后会触发一个 change 事件通知 View 数据更改了</li>\n<li>View 会监听这个 change 事件，拿到对应的新数据并 更新组件 UI(如调用 setState)</li>\n</ul>\n<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><ul>\n<li>View： 视图层 （视图组件）</li>\n<li>Action（动作）：视图层发出的消息 ：包括消息类型和消息的数据。</li>\n<li>Dispatcher（派发器）：用来接收Actions、执行回调函数。</li>\n<li>Store：包含应用状态和逻辑。</li>\n</ul>\n<h4 id=\"Action-（每个Store有一堆）\"><a href=\"#Action-（每个Store有一堆）\" class=\"headerlink\" title=\"Action （每个Store有一堆）\"></a>Action （每个Store有一堆）</h4><p>每个Action都是一个对象，包含一个actionType属性（说明动作的类型）和一些其他属性（用来传递数据）。</p>\n<h4 id=\"Dispatcher-全局一个\"><a href=\"#Dispatcher-全局一个\" class=\"headerlink\" title=\"Dispatcher (全局一个)\"></a>Dispatcher (全局一个)</h4><p>Dispatcher 是中心枢纽，其<code>作用</code>是将 Action 派发到 Store，管理所有数据流向。Dispatcher <code>本质</code>上就是一个事件系统。<br>你可以把它看作一个路由器，负责在 View 和 Store 之间，建立 Action 的正确传递路线。<br>以Facebook 的 Dispatcher 库为例，Dispatcher有两个核心方法：</p>\n<ul>\n<li>dispatch：派发action到store 注册的回调。</li>\n<li>register： store 会调用该方法注册其回调，回调里对不同的action做处理。</li>\n</ul>\n<p>Dispatcher 只用来派发 Action，不应该有其他逻辑。且Dispatcher 只能有一个，而且是全局的。<br>各Store在dispatcher上注册自己的回调，这样dispatcher上就有一张回调注册表，与各Store建立联系。</p>\n<h4 id=\"Store（多个）-响应action-事件\"><a href=\"#Store（多个）-响应action-事件\" class=\"headerlink\" title=\"Store（多个） 响应action(事件)\"></a>Store（多个） 响应action(事件)</h4><p>Stores 包含应用的状态和逻辑，不同的 Store 管理应用中不同部分的状态。<br>Store响应 Dispatched Actions （被分发的事件）。<br>重点：应用中唯一知道如何更新数据的就是 Store。<br>store在dispatcher上注册的回调接受一个action参数，回调里面是一个switch语句，根据action的type分发给具体state更新方法，store更新完毕后，通过广播事件来告诉view某些状态变了，对应的view取新的状态更新自己。</p>\n<h4 id=\"view-（多个）\"><a href=\"#view-（多个）\" class=\"headerlink\" title=\"view （多个）\"></a>view （多个）</h4><p>接收用户操作触发action。 action通过dispatcher派发到store里处理更新数据状态，并发出改变的通知，view获取新的状态更新自己。</p>\n<h3 id=\"有什么好处？\"><a href=\"#有什么好处？\" class=\"headerlink\" title=\"有什么好处？\"></a>有什么好处？</h3><p>这里引用尤雨溪知乎的一个回答：</p>\n<blockquote>\n<ol>\n<li>视图组件变得很薄，只包含了渲染逻辑和触发 action 这两个职责，即所谓 “dumb components”。（<code>个人理解：数据层和view层分离</code>）</li>\n<li>要理解一个 store 可能发生的状态变化，只需要看它所注册的 actions 回调就可以。（<code>个人理解：和1说的一回事，关注点分离后，是的结构更清晰，代码可读性和可维护性提高</code>）</li>\n<li>任何状态的变化都必须通过 action 触发，而 action 又必须通过 dispatcher 走，所以整个应用的每一次状态变化都会从同一个地方流过。其实 Flux 和传统 MVC 最不一样的就在这里了。React 在宣传的时候一直强调的一点就是 “理解你的应用的状态变化是很困难的 (managing state changing over time is hard)”，Flux 的意义就在于强制让所有的状态变化都必须留下一笔记录，这样就可以利用这个来做各种 debug 工具、历史回滚等等。（<code>个人理解：使数据可预测</code>）</li>\n</ol>\n</blockquote>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p>具体实例可以参考阮老师的这边文章 ：<a href=\"http://www.ruanyifeng.com/blog/2016/01/flux.html\" target=\"_blank\" rel=\"external\">Flux 架构入门教程</a></p>\n<p>这篇总结的非常到位，但是前提是得你先大概理解了flux：<a href=\"http://www.ayqy.net/blog/flux/\" target=\"_blank\" rel=\"external\">flux总结</a></p>\n<p>facebook 官方提供的 <a href=\"https://github.com/facebook/flux/blob/master/src/Dispatcher.js\" target=\"_blank\" rel=\"external\">dispatcher</a></p>\n","excerpt":"<h3 id=\"什么是flux\"><a href=\"#什么是flux\" class=\"headerlink\" title=\"什么是flux\"></a>什么是flux</h3><p>flux是一种架构模式，用来指导（或约束）我们的软件结构。其核心是“单向数据流模式”。同MVC架构是同样的存在。<br>(举例 ：React 说自己是 MVC 里面 V 的部分，那么 Flux 就相当于添加 M 和 C 的部分)</p>\n<h3 id=\"单向数据流\"><a href=\"#单向数据流\" class=\"headerlink\" title=\"单向数据流\"></a>单向数据流</h3><p>Flux 的核心“单向数据流“的结构和流程：</p>\n<blockquote>\n<p>  Action –&gt; Dispatcher –&gt; Store –&gt; View</p>\n</blockquote>","more":"<ul>\n<li>首先要有 action，通过定义一些 action creator方法 根据需要创建 Action。</li>\n<li>View 层通过用户交互（比如 onClick）会触发 Action</li>\n<li>Dispatcher 会分发 所触发的 Action 到所有注册的 Store 的回调函数。</li>\n<li>Store 回调函数根据接收的 Action 更新自身数据之后会触发一个 change 事件通知 View 数据更改了</li>\n<li>View 会监听这个 change 事件，拿到对应的新数据并 更新组件 UI(如调用 setState)</li>\n</ul>\n<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><ul>\n<li>View： 视图层 （视图组件）</li>\n<li>Action（动作）：视图层发出的消息 ：包括消息类型和消息的数据。</li>\n<li>Dispatcher（派发器）：用来接收Actions、执行回调函数。</li>\n<li>Store：包含应用状态和逻辑。</li>\n</ul>\n<h4 id=\"Action-（每个Store有一堆）\"><a href=\"#Action-（每个Store有一堆）\" class=\"headerlink\" title=\"Action （每个Store有一堆）\"></a>Action （每个Store有一堆）</h4><p>每个Action都是一个对象，包含一个actionType属性（说明动作的类型）和一些其他属性（用来传递数据）。</p>\n<h4 id=\"Dispatcher-全局一个\"><a href=\"#Dispatcher-全局一个\" class=\"headerlink\" title=\"Dispatcher (全局一个)\"></a>Dispatcher (全局一个)</h4><p>Dispatcher 是中心枢纽，其<code>作用</code>是将 Action 派发到 Store，管理所有数据流向。Dispatcher <code>本质</code>上就是一个事件系统。<br>你可以把它看作一个路由器，负责在 View 和 Store 之间，建立 Action 的正确传递路线。<br>以Facebook 的 Dispatcher 库为例，Dispatcher有两个核心方法：</p>\n<ul>\n<li>dispatch：派发action到store 注册的回调。</li>\n<li>register： store 会调用该方法注册其回调，回调里对不同的action做处理。</li>\n</ul>\n<p>Dispatcher 只用来派发 Action，不应该有其他逻辑。且Dispatcher 只能有一个，而且是全局的。<br>各Store在dispatcher上注册自己的回调，这样dispatcher上就有一张回调注册表，与各Store建立联系。</p>\n<h4 id=\"Store（多个）-响应action-事件\"><a href=\"#Store（多个）-响应action-事件\" class=\"headerlink\" title=\"Store（多个） 响应action(事件)\"></a>Store（多个） 响应action(事件)</h4><p>Stores 包含应用的状态和逻辑，不同的 Store 管理应用中不同部分的状态。<br>Store响应 Dispatched Actions （被分发的事件）。<br>重点：应用中唯一知道如何更新数据的就是 Store。<br>store在dispatcher上注册的回调接受一个action参数，回调里面是一个switch语句，根据action的type分发给具体state更新方法，store更新完毕后，通过广播事件来告诉view某些状态变了，对应的view取新的状态更新自己。</p>\n<h4 id=\"view-（多个）\"><a href=\"#view-（多个）\" class=\"headerlink\" title=\"view （多个）\"></a>view （多个）</h4><p>接收用户操作触发action。 action通过dispatcher派发到store里处理更新数据状态，并发出改变的通知，view获取新的状态更新自己。</p>\n<h3 id=\"有什么好处？\"><a href=\"#有什么好处？\" class=\"headerlink\" title=\"有什么好处？\"></a>有什么好处？</h3><p>这里引用尤雨溪知乎的一个回答：</p>\n<blockquote>\n<ol>\n<li>视图组件变得很薄，只包含了渲染逻辑和触发 action 这两个职责，即所谓 “dumb components”。（<code>个人理解：数据层和view层分离</code>）</li>\n<li>要理解一个 store 可能发生的状态变化，只需要看它所注册的 actions 回调就可以。（<code>个人理解：和1说的一回事，关注点分离后，是的结构更清晰，代码可读性和可维护性提高</code>）</li>\n<li>任何状态的变化都必须通过 action 触发，而 action 又必须通过 dispatcher 走，所以整个应用的每一次状态变化都会从同一个地方流过。其实 Flux 和传统 MVC 最不一样的就在这里了。React 在宣传的时候一直强调的一点就是 “理解你的应用的状态变化是很困难的 (managing state changing over time is hard)”，Flux 的意义就在于强制让所有的状态变化都必须留下一笔记录，这样就可以利用这个来做各种 debug 工具、历史回滚等等。（<code>个人理解：使数据可预测</code>）</li>\n</ol>\n</blockquote>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p>具体实例可以参考阮老师的这边文章 ：<a href=\"http://www.ruanyifeng.com/blog/2016/01/flux.html\">Flux 架构入门教程</a></p>\n<p>这篇总结的非常到位，但是前提是得你先大概理解了flux：<a href=\"http://www.ayqy.net/blog/flux/\">flux总结</a></p>\n<p>facebook 官方提供的 <a href=\"https://github.com/facebook/flux/blob/master/src/Dispatcher.js\">dispatcher</a></p>"},{"title":"理解redux","date":"2017-12-06T07:38:51.000Z","_content":"\n### redux简单介绍\n前面[理解了flux](),本篇来理解redux。\nredux的官方介绍 \n> Redux is a predictable state container for JavaScript apps.\n\n翻译一下：redux 是javascript 应用状态容器，他提供可预测化的状态管理。\n师出flux,作用和flux一样，作为应用的状态管理层。其核心思想也是单向数据流。\n\n我们先看一个redux 最简单的原生使用实例；然后再胡乱解读一通redux概念；最后通过源码来看下其实现原理。\n\n<!-- more -->\n\n### redux如何使用-代码示例 \n[Counter Vanilla](https://github.com/reactjs/redux/blob/master/examples/counter-vanilla/index.html) 这是redux 官方一个原生代码使用redux的实例，非常好懂。 例子是一个计数器，点击+号 完成加一操作，点击 -号，完成减一操作。\n\n\n``` html\n    <!DOCTYPE html>\n    <html>\n      <head>\n        <title>Redux basic example</title>\n        <script src=\"https://cdn.bootcss.com/redux/3.7.2/redux.js\"></script>\n      </head>\n      <body>\n        <div>\n          <p>\n            Clicked: <span id=\"value\">0</span> times\n            <button id=\"increment\">+</button>\n            <button id=\"decrement\">-</button>\n            <button id=\"incrementIfOdd\">Increment if odd</button>\n            <button id=\"incrementAsync\">Increment async</button>\n          </p>\n        </div>\n        <script>\n          //counter函数是一个reducer，现在只需要知道reducer就是操作应用数据的方法\n          function counter(state, action) {\n            if (typeof state === 'undefined') {\n              return 0\n            }\n            switch (action.type) {\n              case 'INCREMENT':\n                return state + 1\n              case 'DECREMENT':\n                return state - 1\n              default:\n                return state\n            }\n          }\n          //实例化一个 store ，store里可以持久化存储应用的数据 state\n          //并且对外暴露几个方法\n          //其中 getState()用来获取应用的数据\n          //其中 subscribe()用来添加订阅者，供数据发生变化时通知\n          //其中 dispatch(action) 触发一个动作用来改变数据 \n          var store = Redux.createStore(counter)\n          var valueEl = document.getElementById('value')\n          \n          \n          //render函数 将数据（state）呈现到view\n          function render() {\n            valueEl.innerHTML = store.getState().toString()\n          }\n          render()\n          \n          //将render 订阅store，数据变了的时候view重新渲染\n          store.subscribe(render)\n          \n          //通过dispatch触发一个操作 来修改数据\n          document.getElementById('increment')\n            .addEventListener('click', function () {\n              store.dispatch({ type: 'INCREMENT' })\n            })\n          document.getElementById('decrement')\n            .addEventListener('click', function () {\n              store.dispatch({ type: 'DECREMENT' })\n            })\n          document.getElementById('incrementIfOdd')\n            .addEventListener('click', function () {\n              if (store.getState() % 2 !== 0) {\n                store.dispatch({ type: 'INCREMENT' })\n              }\n            })\n          document.getElementById('incrementAsync')\n            .addEventListener('click', function () {\n              setTimeout(function () {\n                store.dispatch({ type: 'INCREMENT' })\n              }, 1000)\n            })\n        </script>\n      </body>\n    </html>\n\n```\n\n这个例子很简单。 \n\n* 数据存储在store；\n* view（render函数）订阅store,store变化的时候会通知view 进行刷新；\n* 通过store.dispatch 来修改数据\n\n我们的应用无非就是这么几部分：\n\n* 用户界面（呈现数据）；\n* 应用数据；\n* 操作数据和响应用户操作的方法。 \n\n这些即对应MVC架构的view、model、controller。\n在flux、redux里，也有这些角色，那他们和MVC架构有何不同呢？那就是 flux、redux强制单向数据流来使得数据可预测。 下面我们来看redux的概念和结构。\n\n### redux 结构\n\n上面这个例子中，状态变化的数据流向是下边这样的：\n>\n           dispatch\n     actions --> store | reducers  --> new state --> view \n      |                                               |\n      <-----------------------------------------------\n\n首先创通过createStore(counter)建了一个store。\n点击加号的过程：触发一个加一的action: store.dispatch({ type: 'INCREMENT' }),dispatch 会把这个action分发到reducer（这里是counter)里。reducer 接收当前的应用状态state,返回更改后的state。 到这里数据就完成了一次修改。 由于我们的view 事先订阅了store（store.subscribe(render)）,此时store 会通知view state 变了，view 刷新（调用render方法）。\n     \n#### action \n##### action概念\n\n和 flux里的概念一样，用来描述发生了什么。 \n是一个普通对象，包含一个type属性来描述这个动作， 和其他数据属性。\n比如 { type: 'INCREMENT', num: 1},描述一个增加的动作，增加值为1。\n    \n##### action 扩展\n\n* createAction\n\n    也和flux 里一样，是一个生成action的函数，输入action中变化的部分作为参数，输出一个action对象.因为同样的action 在应用中可能多次用到，通过createAction函数可以减少重复代码,提高代码复用。\n    \n* bindActionCreators \n\n    redux里还提供了bindActionCreators。action只是描述一个行为(好比一个事件event),他本身是不会产生任何影响的，想要触发一个action 让这个描述变成现实，是通过dispatch 方法来触发的（dispatch一个action 好比触发一个event）。而bindActionCreators 就是对dispatch 行为的一个封装，是的业务方触发一个action时可以像普通函数一样调用，而不感知dispatch 的存在。更具体的下面解读源码再说。\n\n\n#### reducer \nreducer 是纯函数。\n上面我们说了让一个action产生影响是通过dispatch(action)来触发的。 而这里的dispatch 只是触发而已，具体干活的就是reducer，dispatch内部调度reducer。\nreducer是一个函数，接收当前state和action 返回新的state。\n\nreducer 和 dispatch 共同充当了flux里的dispatcher（registerCallback,dispatch）角色。\n\n##### reducer扩展\n* combineReducers 方法\n实际应用中有不止一个reducer。redux里提供了一个combineReducers()方法来组织这些reducer。具体下边源码分析再说。\n\n\n#### store \n     \n上面我们知道了，我们使用action 来描述发生了什么，使用reducer来根据action更新state。\n\n而store 就是把action 和reducer结合起来的对象，并持有state。store负责：\n\n* 维持应用的state,并提供getState()方法获取state\n* 提供 dispatch(action) 方法更新 state；\n* 提供 subscribe(listener) / unsubscribe(listener) 来注册和解绑监听者。 \n\nRedux 应用只有一个单一的 store，当需要拆分数据处理逻辑时，你应该使用 reducer 组合 而不是创建多个 store。\n\n### redux 源码解读(基于redux3.7)\n\n#### 先看下代码结构 \nredux 对外暴露五个方法，分别对应五个同名js文件：\n``` javascript\n      createStore.js //保存应用状态 定义内部方法，输出对外暴露的方法\n      combineReducers.js //将多个reducer 合并成一个\n      bindActionCreators.js //把actionCreator 包了一层dispatch，使用时可以像普通函数一样调用actionCreator\n      applyMiddleware.js //组合串联middleware\n      compose.js //工具方法，将middleware中间件方法组合成一个调用链\n```\n#### createStore.js\n这是redux 最核心概念的实现部分。createStore方法的作用是创建一个store,并维持state。下面我们就通过源码看下store 是如何维持state的。\n\n\ncreateStore方法接受三个参数：reducer [, preloadedState, enhancer],\n返回一个store对象，包含4个方法：\n    \n* dispatch //触发action\n* subscribe// 添加监听者\n* getState //获取当前state\n* replaceReducer \n* observable\n\n以下源码为方便阅读，去掉了原注释，和异常抛错信息。注释信息为解读信息。\n\n``` javascript\n\n    import $$observable from 'symbol-observable'\n    import ActionTypes from './utils/actionTypes'\n    import isPlainObject from './utils/isPlainObject'\n    /**\n     * [createStore description]    通过createStore方法创建一个store,store来维护和持有应用的state\n     * @param  {Function} reducer   函数 接收当前state和action为参数返回新的state\n     * @param  {any} preloadedState 默认的初始化state，如果你的reducer是通过combineReducers生成的一个顶层reducer,\n     *                              那初始state的key值和combineReducers的key是一一对应的\n     * @param  {Function} enhancer  store增强器 通常添加中间件\n     * @return {Store}              store，允许你读取state,dispatch actions以及注册订阅者\n     */\n    export default function createStore(reducer, preloadedState, enhancer) {\n      //允许使用方灵活传参：可以不传默认state 直接传 enhancer参数\n      if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {\n        enhancer = preloadedState\n        preloadedState = undefined\n      }\n    \n      if (typeof enhancer !== 'undefined') {\n        if (typeof enhancer !== 'function') {\n          throw new Error('Expected the enhancer to be a function.')\n        }\n        //这行代码到 applyMiddleWare时说明\n        return enhancer(createStore)(reducer, preloadedState)\n      }\n    \n      if (typeof reducer !== 'function') {\n        throw new Error('Expected the reducer to be a function.')\n      }\n      \n      //这里是一些函数内的变量，由于闭包特性，这些变量在调用createStore函数后不会被销毁（因为导出的对象方法里面有这些变量的引用）。\n      //这里指的注意的一点是有两个listeners队列：currentListeners 和 nextListeners；这一点有点厉害了，下面介绍\n      let currentReducer = reducer \n      let currentState = preloadedState\n      let currentListeners = []\n      let nextListeners = currentListeners\n      let isDispatching = false\n      \n      //nextListeners是currentListeners的拷贝，我们修改（subscribe）都是对nextListeners的修改\n      //在flush listeners 之前 nextListeners 同步 currentListeners\n      //这么做可以保证 每次dispatch listener 过程中 subscribe/unsubscribe listerens不会影响当前dispatch 队列，改变值发生在nextListeners，下一次dispatch时生效。 \n      //TODO：我只知道这里这么做有点屌，具体这么做有啥用，我还得研究下\n      \n      function ensureCanMutateNextListeners() {\n      //nextListeners === currentListener 说明listeners已经被flush; \n      //nextListeners !== currentListener 说明subscribe(listener)后 还未被dispatch\n        if (nextListeners === currentListeners) {\n          nextListeners = currentListeners.slice()\n        }\n      }\n        /**\n         * 读取state \n         * @returns {any} 返回应用的当前state树\n         */\n      function getState() {\n        if (isDispatching) {\n          throw new Error('')\n        }\n    \n        return currentState\n      }\n    \n      function subscribe(listener) {\n        if (typeof listener !== 'function') {\n          throw new Error('Expected listener to be a function.')\n        }\n    \n        if (isDispatching) {\n          throw new Error('')\n        }\n    \n        let isSubscribed = true\n    \n        ensureCanMutateNextListeners()\n        nextListeners.push(listener)\n    \n        return function unsubscribe() {\n          if (!isSubscribed) {\n            return\n          }\n    \n          if (isDispatching) {\n            throw new Error('')\n          }\n    \n          isSubscribed = false\n    \n          ensureCanMutateNextListeners()\n          const index = nextListeners.indexOf(listener)\n          nextListeners.splice(index, 1)\n        }\n      }\n    \n      //唯一改变store里数据（state）的方式就是调用store.dispatch\n      //dispatch 做了两件事情：1调用 reducer 更改数据 2 flush 所有listeners\n      //这里和flux有点不同, flux里 观察数据的变化，以及数据变化后的通知，这些需要你自己去实现 这一环节的观察者模式。\n      //redux自身实现了这一环节的观察者模式，提供了 store.subscribe方法添加listeners，dispatch的时候会 flush这些listeners \n     \n      function dispatch(action) {\n        if (!isPlainObject(action)) {\n          throw new Error('')\n        }\n    \n        if (typeof action.type === 'undefined') {\n          throw new Error('')\n        }\n        \n         // reducer内部不允许再次调用dispatch，否则抛出异常 防止死循环？\n        if (isDispatching) {\n          throw new Error('Reducers may not dispatch actions.')\n        }\n    \n        try {\n          isDispatching = true\n          currentState = currentReducer(currentState, action)\n        } finally {\n          isDispatching = false\n        }\n        \n        //触发所有的状态监听回调函数\n        const listeners = currentListeners = nextListeners\n        for (let i = 0; i < listeners.length; i++) {\n          const listener = listeners[i]\n          listener()\n        }\n    \n        return action\n      }\n      \n      // 顾名思义，就是替换当前store在用的reducer\n      // 有什么用呢？你想动态加载某些reducer时,加载后用该方法替换reducer; 如果你想为redux实现热更新机制，也需要该方法\n      function replaceReducer(nextReducer) {\n        if (typeof nextReducer !== 'function') {\n          throw new Error('Expected the nextReducer to be a function.')\n        }\n    \n        currentReducer = nextReducer\n        dispatch({ type: ActionTypes.REPLACE })\n      }\n      \n      //\n      function observable() {\n        const outerSubscribe = subscribe\n        return {\n          subscribe(observer) {\n            if (typeof observer !== 'object') {\n              throw new TypeError('Expected the observer to be an object.')\n            }\n    \n            function observeState() {\n              if (observer.next) {\n                observer.next(getState())\n              }\n            }\n    \n            observeState()\n            const unsubscribe = outerSubscribe(observeState)\n            return { unsubscribe }\n          },\n    \n          [$$observable]() {\n            return this\n          }\n        }\n      }\n    \n      dispatch({ type: ActionTypes.INIT })\n    \n      return {\n        dispatch,\n        subscribe,\n        getState,\n        replaceReducer,\n        [$$observable]: observable\n      }\n    }\n```\n\n这里最值得关注的就是currentListeners 和nextListeners这两个listener队列及ensureCanMutateNextListeners方法。每次修改的是nextListeners。每次flush listeners时 将nextListeners和currentListeners同步。\n\n#### bindActionCreators.js\n\n``` javascript  \n    //bindActionCreators 用法\n    bindActionCreators({ //第一个参数也可以是一个 actionCreator函数\n        addCreator, //属性值是actionCreator函数\n        anotherCreator,\n        ...\n    },dispatch)\n    \n    //bindActionCreator\n    function bindActionCreator(actionCreator, dispatch) {\n      return function() { \n        return dispatch(actionCreator.apply(this, arguments)) \n      }\n    }\n    \n    //bindActionCreators返回值\n    => boundActionCreators = {\n        addCreator: bindActionCreator(addCreator, dispatch),\n        anotherCreator: bindActionCreator(anotherCreator, dispatch),\n        \n    }\n    or \n    => \n    \n    bindActionCreator(actionCreators, dispatch) => function (...arg) {\n        return dispatch(actionCreator(...arg))) \n    }\n    \n    //actionCreator\n    actionCreator() => action (对象)，用的时候dispatch(actionCreator())\n```\nbindActionCreators 主要是把actionCreator 包了一层dispatch，使用时可以像普通函数一样调用actionCreator。使得对redux 无感知。\n\n#### applyMiddleWare\n\n\n``` javascript \n\n    import compose from './compose'\n    \n    export default function applyMiddleware(...middlewares) {\n      return (createStore) => (...args) => {\n        const store = createStore(...args)\n        let dispatch = store.dispatch\n        let chain = []\n    \n        const middlewareAPI = {\n          getState: store.getState,\n          dispatch: (...args) => dispatch(...args)\n        }\n        chain = middlewares.map(middleware => middleware(middlewareAPI))\n        dispatch = compose(...chain)(store.dispatch)\n    \n        return {\n          ...store,\n          dispatch\n        }\n      }\n    }\n\n```\n\n\n#### compose.js\n\n``` javascript \n\n    export default function compose(...funcs) {\n      if (funcs.length === 0) {\n        return arg => arg\n      }\n    \n      if (funcs.length === 1) {\n        return funcs[0]\n      }\n    \n      return funcs.reduce((a, b) => (...args) => a(b(...args)))\n    }\n\n```\n\n\n### 参考资料\n* [github](https://github.com/reactjs/redux)\n* [中文文档](http://cn.redux.js.org/index.html)\n* [源码解读](http://www.jianshu.com/p/7ae531a8b299?from=timeline)\n* [极简教程](https://github.com/react-guide/redux-tutorial-cn#redux-tutorial)\n* [极简代码示例]()\n\n\n","source":"_posts/理解redux.md","raw":"---\ntitle: 理解redux\ndate: 2017-12-06 15:38:51\ntags:\n    - redux\n    - 数据流\ncategories:\n    - 前端状态管理\n---\n\n### redux简单介绍\n前面[理解了flux](),本篇来理解redux。\nredux的官方介绍 \n> Redux is a predictable state container for JavaScript apps.\n\n翻译一下：redux 是javascript 应用状态容器，他提供可预测化的状态管理。\n师出flux,作用和flux一样，作为应用的状态管理层。其核心思想也是单向数据流。\n\n我们先看一个redux 最简单的原生使用实例；然后再胡乱解读一通redux概念；最后通过源码来看下其实现原理。\n\n<!-- more -->\n\n### redux如何使用-代码示例 \n[Counter Vanilla](https://github.com/reactjs/redux/blob/master/examples/counter-vanilla/index.html) 这是redux 官方一个原生代码使用redux的实例，非常好懂。 例子是一个计数器，点击+号 完成加一操作，点击 -号，完成减一操作。\n\n\n``` html\n    <!DOCTYPE html>\n    <html>\n      <head>\n        <title>Redux basic example</title>\n        <script src=\"https://cdn.bootcss.com/redux/3.7.2/redux.js\"></script>\n      </head>\n      <body>\n        <div>\n          <p>\n            Clicked: <span id=\"value\">0</span> times\n            <button id=\"increment\">+</button>\n            <button id=\"decrement\">-</button>\n            <button id=\"incrementIfOdd\">Increment if odd</button>\n            <button id=\"incrementAsync\">Increment async</button>\n          </p>\n        </div>\n        <script>\n          //counter函数是一个reducer，现在只需要知道reducer就是操作应用数据的方法\n          function counter(state, action) {\n            if (typeof state === 'undefined') {\n              return 0\n            }\n            switch (action.type) {\n              case 'INCREMENT':\n                return state + 1\n              case 'DECREMENT':\n                return state - 1\n              default:\n                return state\n            }\n          }\n          //实例化一个 store ，store里可以持久化存储应用的数据 state\n          //并且对外暴露几个方法\n          //其中 getState()用来获取应用的数据\n          //其中 subscribe()用来添加订阅者，供数据发生变化时通知\n          //其中 dispatch(action) 触发一个动作用来改变数据 \n          var store = Redux.createStore(counter)\n          var valueEl = document.getElementById('value')\n          \n          \n          //render函数 将数据（state）呈现到view\n          function render() {\n            valueEl.innerHTML = store.getState().toString()\n          }\n          render()\n          \n          //将render 订阅store，数据变了的时候view重新渲染\n          store.subscribe(render)\n          \n          //通过dispatch触发一个操作 来修改数据\n          document.getElementById('increment')\n            .addEventListener('click', function () {\n              store.dispatch({ type: 'INCREMENT' })\n            })\n          document.getElementById('decrement')\n            .addEventListener('click', function () {\n              store.dispatch({ type: 'DECREMENT' })\n            })\n          document.getElementById('incrementIfOdd')\n            .addEventListener('click', function () {\n              if (store.getState() % 2 !== 0) {\n                store.dispatch({ type: 'INCREMENT' })\n              }\n            })\n          document.getElementById('incrementAsync')\n            .addEventListener('click', function () {\n              setTimeout(function () {\n                store.dispatch({ type: 'INCREMENT' })\n              }, 1000)\n            })\n        </script>\n      </body>\n    </html>\n\n```\n\n这个例子很简单。 \n\n* 数据存储在store；\n* view（render函数）订阅store,store变化的时候会通知view 进行刷新；\n* 通过store.dispatch 来修改数据\n\n我们的应用无非就是这么几部分：\n\n* 用户界面（呈现数据）；\n* 应用数据；\n* 操作数据和响应用户操作的方法。 \n\n这些即对应MVC架构的view、model、controller。\n在flux、redux里，也有这些角色，那他们和MVC架构有何不同呢？那就是 flux、redux强制单向数据流来使得数据可预测。 下面我们来看redux的概念和结构。\n\n### redux 结构\n\n上面这个例子中，状态变化的数据流向是下边这样的：\n>\n           dispatch\n     actions --> store | reducers  --> new state --> view \n      |                                               |\n      <-----------------------------------------------\n\n首先创通过createStore(counter)建了一个store。\n点击加号的过程：触发一个加一的action: store.dispatch({ type: 'INCREMENT' }),dispatch 会把这个action分发到reducer（这里是counter)里。reducer 接收当前的应用状态state,返回更改后的state。 到这里数据就完成了一次修改。 由于我们的view 事先订阅了store（store.subscribe(render)）,此时store 会通知view state 变了，view 刷新（调用render方法）。\n     \n#### action \n##### action概念\n\n和 flux里的概念一样，用来描述发生了什么。 \n是一个普通对象，包含一个type属性来描述这个动作， 和其他数据属性。\n比如 { type: 'INCREMENT', num: 1},描述一个增加的动作，增加值为1。\n    \n##### action 扩展\n\n* createAction\n\n    也和flux 里一样，是一个生成action的函数，输入action中变化的部分作为参数，输出一个action对象.因为同样的action 在应用中可能多次用到，通过createAction函数可以减少重复代码,提高代码复用。\n    \n* bindActionCreators \n\n    redux里还提供了bindActionCreators。action只是描述一个行为(好比一个事件event),他本身是不会产生任何影响的，想要触发一个action 让这个描述变成现实，是通过dispatch 方法来触发的（dispatch一个action 好比触发一个event）。而bindActionCreators 就是对dispatch 行为的一个封装，是的业务方触发一个action时可以像普通函数一样调用，而不感知dispatch 的存在。更具体的下面解读源码再说。\n\n\n#### reducer \nreducer 是纯函数。\n上面我们说了让一个action产生影响是通过dispatch(action)来触发的。 而这里的dispatch 只是触发而已，具体干活的就是reducer，dispatch内部调度reducer。\nreducer是一个函数，接收当前state和action 返回新的state。\n\nreducer 和 dispatch 共同充当了flux里的dispatcher（registerCallback,dispatch）角色。\n\n##### reducer扩展\n* combineReducers 方法\n实际应用中有不止一个reducer。redux里提供了一个combineReducers()方法来组织这些reducer。具体下边源码分析再说。\n\n\n#### store \n     \n上面我们知道了，我们使用action 来描述发生了什么，使用reducer来根据action更新state。\n\n而store 就是把action 和reducer结合起来的对象，并持有state。store负责：\n\n* 维持应用的state,并提供getState()方法获取state\n* 提供 dispatch(action) 方法更新 state；\n* 提供 subscribe(listener) / unsubscribe(listener) 来注册和解绑监听者。 \n\nRedux 应用只有一个单一的 store，当需要拆分数据处理逻辑时，你应该使用 reducer 组合 而不是创建多个 store。\n\n### redux 源码解读(基于redux3.7)\n\n#### 先看下代码结构 \nredux 对外暴露五个方法，分别对应五个同名js文件：\n``` javascript\n      createStore.js //保存应用状态 定义内部方法，输出对外暴露的方法\n      combineReducers.js //将多个reducer 合并成一个\n      bindActionCreators.js //把actionCreator 包了一层dispatch，使用时可以像普通函数一样调用actionCreator\n      applyMiddleware.js //组合串联middleware\n      compose.js //工具方法，将middleware中间件方法组合成一个调用链\n```\n#### createStore.js\n这是redux 最核心概念的实现部分。createStore方法的作用是创建一个store,并维持state。下面我们就通过源码看下store 是如何维持state的。\n\n\ncreateStore方法接受三个参数：reducer [, preloadedState, enhancer],\n返回一个store对象，包含4个方法：\n    \n* dispatch //触发action\n* subscribe// 添加监听者\n* getState //获取当前state\n* replaceReducer \n* observable\n\n以下源码为方便阅读，去掉了原注释，和异常抛错信息。注释信息为解读信息。\n\n``` javascript\n\n    import $$observable from 'symbol-observable'\n    import ActionTypes from './utils/actionTypes'\n    import isPlainObject from './utils/isPlainObject'\n    /**\n     * [createStore description]    通过createStore方法创建一个store,store来维护和持有应用的state\n     * @param  {Function} reducer   函数 接收当前state和action为参数返回新的state\n     * @param  {any} preloadedState 默认的初始化state，如果你的reducer是通过combineReducers生成的一个顶层reducer,\n     *                              那初始state的key值和combineReducers的key是一一对应的\n     * @param  {Function} enhancer  store增强器 通常添加中间件\n     * @return {Store}              store，允许你读取state,dispatch actions以及注册订阅者\n     */\n    export default function createStore(reducer, preloadedState, enhancer) {\n      //允许使用方灵活传参：可以不传默认state 直接传 enhancer参数\n      if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {\n        enhancer = preloadedState\n        preloadedState = undefined\n      }\n    \n      if (typeof enhancer !== 'undefined') {\n        if (typeof enhancer !== 'function') {\n          throw new Error('Expected the enhancer to be a function.')\n        }\n        //这行代码到 applyMiddleWare时说明\n        return enhancer(createStore)(reducer, preloadedState)\n      }\n    \n      if (typeof reducer !== 'function') {\n        throw new Error('Expected the reducer to be a function.')\n      }\n      \n      //这里是一些函数内的变量，由于闭包特性，这些变量在调用createStore函数后不会被销毁（因为导出的对象方法里面有这些变量的引用）。\n      //这里指的注意的一点是有两个listeners队列：currentListeners 和 nextListeners；这一点有点厉害了，下面介绍\n      let currentReducer = reducer \n      let currentState = preloadedState\n      let currentListeners = []\n      let nextListeners = currentListeners\n      let isDispatching = false\n      \n      //nextListeners是currentListeners的拷贝，我们修改（subscribe）都是对nextListeners的修改\n      //在flush listeners 之前 nextListeners 同步 currentListeners\n      //这么做可以保证 每次dispatch listener 过程中 subscribe/unsubscribe listerens不会影响当前dispatch 队列，改变值发生在nextListeners，下一次dispatch时生效。 \n      //TODO：我只知道这里这么做有点屌，具体这么做有啥用，我还得研究下\n      \n      function ensureCanMutateNextListeners() {\n      //nextListeners === currentListener 说明listeners已经被flush; \n      //nextListeners !== currentListener 说明subscribe(listener)后 还未被dispatch\n        if (nextListeners === currentListeners) {\n          nextListeners = currentListeners.slice()\n        }\n      }\n        /**\n         * 读取state \n         * @returns {any} 返回应用的当前state树\n         */\n      function getState() {\n        if (isDispatching) {\n          throw new Error('')\n        }\n    \n        return currentState\n      }\n    \n      function subscribe(listener) {\n        if (typeof listener !== 'function') {\n          throw new Error('Expected listener to be a function.')\n        }\n    \n        if (isDispatching) {\n          throw new Error('')\n        }\n    \n        let isSubscribed = true\n    \n        ensureCanMutateNextListeners()\n        nextListeners.push(listener)\n    \n        return function unsubscribe() {\n          if (!isSubscribed) {\n            return\n          }\n    \n          if (isDispatching) {\n            throw new Error('')\n          }\n    \n          isSubscribed = false\n    \n          ensureCanMutateNextListeners()\n          const index = nextListeners.indexOf(listener)\n          nextListeners.splice(index, 1)\n        }\n      }\n    \n      //唯一改变store里数据（state）的方式就是调用store.dispatch\n      //dispatch 做了两件事情：1调用 reducer 更改数据 2 flush 所有listeners\n      //这里和flux有点不同, flux里 观察数据的变化，以及数据变化后的通知，这些需要你自己去实现 这一环节的观察者模式。\n      //redux自身实现了这一环节的观察者模式，提供了 store.subscribe方法添加listeners，dispatch的时候会 flush这些listeners \n     \n      function dispatch(action) {\n        if (!isPlainObject(action)) {\n          throw new Error('')\n        }\n    \n        if (typeof action.type === 'undefined') {\n          throw new Error('')\n        }\n        \n         // reducer内部不允许再次调用dispatch，否则抛出异常 防止死循环？\n        if (isDispatching) {\n          throw new Error('Reducers may not dispatch actions.')\n        }\n    \n        try {\n          isDispatching = true\n          currentState = currentReducer(currentState, action)\n        } finally {\n          isDispatching = false\n        }\n        \n        //触发所有的状态监听回调函数\n        const listeners = currentListeners = nextListeners\n        for (let i = 0; i < listeners.length; i++) {\n          const listener = listeners[i]\n          listener()\n        }\n    \n        return action\n      }\n      \n      // 顾名思义，就是替换当前store在用的reducer\n      // 有什么用呢？你想动态加载某些reducer时,加载后用该方法替换reducer; 如果你想为redux实现热更新机制，也需要该方法\n      function replaceReducer(nextReducer) {\n        if (typeof nextReducer !== 'function') {\n          throw new Error('Expected the nextReducer to be a function.')\n        }\n    \n        currentReducer = nextReducer\n        dispatch({ type: ActionTypes.REPLACE })\n      }\n      \n      //\n      function observable() {\n        const outerSubscribe = subscribe\n        return {\n          subscribe(observer) {\n            if (typeof observer !== 'object') {\n              throw new TypeError('Expected the observer to be an object.')\n            }\n    \n            function observeState() {\n              if (observer.next) {\n                observer.next(getState())\n              }\n            }\n    \n            observeState()\n            const unsubscribe = outerSubscribe(observeState)\n            return { unsubscribe }\n          },\n    \n          [$$observable]() {\n            return this\n          }\n        }\n      }\n    \n      dispatch({ type: ActionTypes.INIT })\n    \n      return {\n        dispatch,\n        subscribe,\n        getState,\n        replaceReducer,\n        [$$observable]: observable\n      }\n    }\n```\n\n这里最值得关注的就是currentListeners 和nextListeners这两个listener队列及ensureCanMutateNextListeners方法。每次修改的是nextListeners。每次flush listeners时 将nextListeners和currentListeners同步。\n\n#### bindActionCreators.js\n\n``` javascript  \n    //bindActionCreators 用法\n    bindActionCreators({ //第一个参数也可以是一个 actionCreator函数\n        addCreator, //属性值是actionCreator函数\n        anotherCreator,\n        ...\n    },dispatch)\n    \n    //bindActionCreator\n    function bindActionCreator(actionCreator, dispatch) {\n      return function() { \n        return dispatch(actionCreator.apply(this, arguments)) \n      }\n    }\n    \n    //bindActionCreators返回值\n    => boundActionCreators = {\n        addCreator: bindActionCreator(addCreator, dispatch),\n        anotherCreator: bindActionCreator(anotherCreator, dispatch),\n        \n    }\n    or \n    => \n    \n    bindActionCreator(actionCreators, dispatch) => function (...arg) {\n        return dispatch(actionCreator(...arg))) \n    }\n    \n    //actionCreator\n    actionCreator() => action (对象)，用的时候dispatch(actionCreator())\n```\nbindActionCreators 主要是把actionCreator 包了一层dispatch，使用时可以像普通函数一样调用actionCreator。使得对redux 无感知。\n\n#### applyMiddleWare\n\n\n``` javascript \n\n    import compose from './compose'\n    \n    export default function applyMiddleware(...middlewares) {\n      return (createStore) => (...args) => {\n        const store = createStore(...args)\n        let dispatch = store.dispatch\n        let chain = []\n    \n        const middlewareAPI = {\n          getState: store.getState,\n          dispatch: (...args) => dispatch(...args)\n        }\n        chain = middlewares.map(middleware => middleware(middlewareAPI))\n        dispatch = compose(...chain)(store.dispatch)\n    \n        return {\n          ...store,\n          dispatch\n        }\n      }\n    }\n\n```\n\n\n#### compose.js\n\n``` javascript \n\n    export default function compose(...funcs) {\n      if (funcs.length === 0) {\n        return arg => arg\n      }\n    \n      if (funcs.length === 1) {\n        return funcs[0]\n      }\n    \n      return funcs.reduce((a, b) => (...args) => a(b(...args)))\n    }\n\n```\n\n\n### 参考资料\n* [github](https://github.com/reactjs/redux)\n* [中文文档](http://cn.redux.js.org/index.html)\n* [源码解读](http://www.jianshu.com/p/7ae531a8b299?from=timeline)\n* [极简教程](https://github.com/react-guide/redux-tutorial-cn#redux-tutorial)\n* [极简代码示例]()\n\n\n","slug":"理解redux","published":1,"updated":"2018-03-10T16:05:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjelnshd0000i3gffkdb7p2y2","content":"<h3 id=\"redux简单介绍\"><a href=\"#redux简单介绍\" class=\"headerlink\" title=\"redux简单介绍\"></a>redux简单介绍</h3><p>前面<a href=\"\">理解了flux</a>,本篇来理解redux。<br>redux的官方介绍 </p>\n<blockquote>\n<p>Redux is a predictable state container for JavaScript apps.</p>\n</blockquote>\n<p>翻译一下：redux 是javascript 应用状态容器，他提供可预测化的状态管理。<br>师出flux,作用和flux一样，作为应用的状态管理层。其核心思想也是单向数据流。</p>\n<p>我们先看一个redux 最简单的原生使用实例；然后再胡乱解读一通redux概念；最后通过源码来看下其实现原理。</p>\n<a id=\"more\"></a>\n<h3 id=\"redux如何使用-代码示例\"><a href=\"#redux如何使用-代码示例\" class=\"headerlink\" title=\"redux如何使用-代码示例\"></a>redux如何使用-代码示例</h3><p><a href=\"https://github.com/reactjs/redux/blob/master/examples/counter-vanilla/index.html\" target=\"_blank\" rel=\"external\">Counter Vanilla</a> 这是redux 官方一个原生代码使用redux的实例，非常好懂。 例子是一个计数器，点击+号 完成加一操作，点击 -号，完成减一操作。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Redux basic example<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://cdn.bootcss.com/redux/3.7.2/redux.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">        Clicked: <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">id</span>=<span class=\"string\">\"value\"</span>&gt;</span>0<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span> times</div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">id</span>=<span class=\"string\">\"increment\"</span>&gt;</span>+<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">id</span>=<span class=\"string\">\"decrement\"</span>&gt;</span>-<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">id</span>=<span class=\"string\">\"incrementIfOdd\"</span>&gt;</span>Increment if odd<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">id</span>=<span class=\"string\">\"incrementAsync\"</span>&gt;</span>Increment async<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></div><div class=\"line\">      <span class=\"comment\">//counter函数是一个reducer，现在只需要知道reducer就是操作应用数据的方法</span></div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">counter</span>(<span class=\"params\">state, action</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> state === <span class=\"string\">'undefined'</span>) &#123;</div><div class=\"line\">          <span class=\"keyword\">return</span> <span class=\"number\">0</span></div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">switch</span> (action.type) &#123;</div><div class=\"line\">          <span class=\"keyword\">case</span> <span class=\"string\">'INCREMENT'</span>:</div><div class=\"line\">            <span class=\"keyword\">return</span> state + <span class=\"number\">1</span></div><div class=\"line\">          <span class=\"keyword\">case</span> <span class=\"string\">'DECREMENT'</span>:</div><div class=\"line\">            <span class=\"keyword\">return</span> state - <span class=\"number\">1</span></div><div class=\"line\">          <span class=\"keyword\">default</span>:</div><div class=\"line\">            <span class=\"keyword\">return</span> state</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"comment\">//实例化一个 store ，store里可以持久化存储应用的数据 state</span></div><div class=\"line\">      <span class=\"comment\">//并且对外暴露几个方法</span></div><div class=\"line\">      <span class=\"comment\">//其中 getState()用来获取应用的数据</span></div><div class=\"line\">      <span class=\"comment\">//其中 subscribe()用来添加订阅者，供数据发生变化时通知</span></div><div class=\"line\">      <span class=\"comment\">//其中 dispatch(action) 触发一个动作用来改变数据 </span></div><div class=\"line\">      <span class=\"keyword\">var</span> store = Redux.createStore(counter)</div><div class=\"line\">      <span class=\"keyword\">var</span> valueEl = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'value'</span>)</div><div class=\"line\">      </div><div class=\"line\">      </div><div class=\"line\">      <span class=\"comment\">//render函数 将数据（state）呈现到view</span></div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">render</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        valueEl.innerHTML = store.getState().toString()</div><div class=\"line\">      &#125;</div><div class=\"line\">      render()</div><div class=\"line\">      </div><div class=\"line\">      <span class=\"comment\">//将render 订阅store，数据变了的时候view重新渲染</span></div><div class=\"line\">      store.subscribe(render)</div><div class=\"line\">      </div><div class=\"line\">      <span class=\"comment\">//通过dispatch触发一个操作 来修改数据</span></div><div class=\"line\">      <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'increment'</span>)</div><div class=\"line\">        .addEventListener(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">          store.dispatch(&#123; <span class=\"attr\">type</span>: <span class=\"string\">'INCREMENT'</span> &#125;)</div><div class=\"line\">        &#125;)</div><div class=\"line\">      <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'decrement'</span>)</div><div class=\"line\">        .addEventListener(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">          store.dispatch(&#123; <span class=\"attr\">type</span>: <span class=\"string\">'DECREMENT'</span> &#125;)</div><div class=\"line\">        &#125;)</div><div class=\"line\">      <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'incrementIfOdd'</span>)</div><div class=\"line\">        .addEventListener(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">          <span class=\"keyword\">if</span> (store.getState() % <span class=\"number\">2</span> !== <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            store.dispatch(&#123; <span class=\"attr\">type</span>: <span class=\"string\">'INCREMENT'</span> &#125;)</div><div class=\"line\">          &#125;</div><div class=\"line\">        &#125;)</div><div class=\"line\">      <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'incrementAsync'</span>)</div><div class=\"line\">        .addEventListener(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">          setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            store.dispatch(&#123; <span class=\"attr\">type</span>: <span class=\"string\">'INCREMENT'</span> &#125;)</div><div class=\"line\">          &#125;, <span class=\"number\">1000</span>)</div><div class=\"line\">        &#125;)</div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>这个例子很简单。 </p>\n<ul>\n<li>数据存储在store；</li>\n<li>view（render函数）订阅store,store变化的时候会通知view 进行刷新；</li>\n<li>通过store.dispatch 来修改数据</li>\n</ul>\n<p>我们的应用无非就是这么几部分：</p>\n<ul>\n<li>用户界面（呈现数据）；</li>\n<li>应用数据；</li>\n<li>操作数据和响应用户操作的方法。 </li>\n</ul>\n<p>这些即对应MVC架构的view、model、controller。<br>在flux、redux里，也有这些角色，那他们和MVC架构有何不同呢？那就是 flux、redux强制单向数据流来使得数据可预测。 下面我们来看redux的概念和结构。</p>\n<h3 id=\"redux-结构\"><a href=\"#redux-结构\" class=\"headerlink\" title=\"redux 结构\"></a>redux 结构</h3><p>上面这个例子中，状态变化的数据流向是下边这样的：<br>&gt;<br>           dispatch<br>     actions –&gt; store | reducers  –&gt; new state –&gt; view<br>      |                                               |<br>      &lt;———————————————–</p>\n<p>首先创通过createStore(counter)建了一个store。<br>点击加号的过程：触发一个加一的action: store.dispatch({ type: ‘INCREMENT’ }),dispatch 会把这个action分发到reducer（这里是counter)里。reducer 接收当前的应用状态state,返回更改后的state。 到这里数据就完成了一次修改。 由于我们的view 事先订阅了store（store.subscribe(render)）,此时store 会通知view state 变了，view 刷新（调用render方法）。</p>\n<h4 id=\"action\"><a href=\"#action\" class=\"headerlink\" title=\"action\"></a>action</h4><h5 id=\"action概念\"><a href=\"#action概念\" class=\"headerlink\" title=\"action概念\"></a>action概念</h5><p>和 flux里的概念一样，用来描述发生了什么。<br>是一个普通对象，包含一个type属性来描述这个动作， 和其他数据属性。<br>比如 { type: ‘INCREMENT’, num: 1},描述一个增加的动作，增加值为1。</p>\n<h5 id=\"action-扩展\"><a href=\"#action-扩展\" class=\"headerlink\" title=\"action 扩展\"></a>action 扩展</h5><ul>\n<li><p>createAction</p>\n<p>  也和flux 里一样，是一个生成action的函数，输入action中变化的部分作为参数，输出一个action对象.因为同样的action 在应用中可能多次用到，通过createAction函数可以减少重复代码,提高代码复用。</p>\n</li>\n<li><p>bindActionCreators </p>\n<p>  redux里还提供了bindActionCreators。action只是描述一个行为(好比一个事件event),他本身是不会产生任何影响的，想要触发一个action 让这个描述变成现实，是通过dispatch 方法来触发的（dispatch一个action 好比触发一个event）。而bindActionCreators 就是对dispatch 行为的一个封装，是的业务方触发一个action时可以像普通函数一样调用，而不感知dispatch 的存在。更具体的下面解读源码再说。</p>\n</li>\n</ul>\n<h4 id=\"reducer\"><a href=\"#reducer\" class=\"headerlink\" title=\"reducer\"></a>reducer</h4><p>reducer 是纯函数。<br>上面我们说了让一个action产生影响是通过dispatch(action)来触发的。 而这里的dispatch 只是触发而已，具体干活的就是reducer，dispatch内部调度reducer。<br>reducer是一个函数，接收当前state和action 返回新的state。</p>\n<p>reducer 和 dispatch 共同充当了flux里的dispatcher（registerCallback,dispatch）角色。</p>\n<h5 id=\"reducer扩展\"><a href=\"#reducer扩展\" class=\"headerlink\" title=\"reducer扩展\"></a>reducer扩展</h5><ul>\n<li>combineReducers 方法<br>实际应用中有不止一个reducer。redux里提供了一个combineReducers()方法来组织这些reducer。具体下边源码分析再说。</li>\n</ul>\n<h4 id=\"store\"><a href=\"#store\" class=\"headerlink\" title=\"store\"></a>store</h4><p>上面我们知道了，我们使用action 来描述发生了什么，使用reducer来根据action更新state。</p>\n<p>而store 就是把action 和reducer结合起来的对象，并持有state。store负责：</p>\n<ul>\n<li>维持应用的state,并提供getState()方法获取state</li>\n<li>提供 dispatch(action) 方法更新 state；</li>\n<li>提供 subscribe(listener) / unsubscribe(listener) 来注册和解绑监听者。 </li>\n</ul>\n<p>Redux 应用只有一个单一的 store，当需要拆分数据处理逻辑时，你应该使用 reducer 组合 而不是创建多个 store。</p>\n<h3 id=\"redux-源码解读-基于redux3-7\"><a href=\"#redux-源码解读-基于redux3-7\" class=\"headerlink\" title=\"redux 源码解读(基于redux3.7)\"></a>redux 源码解读(基于redux3.7)</h3><h4 id=\"先看下代码结构\"><a href=\"#先看下代码结构\" class=\"headerlink\" title=\"先看下代码结构\"></a>先看下代码结构</h4><p>redux 对外暴露五个方法，分别对应五个同名js文件：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">createStore.js <span class=\"comment\">//保存应用状态 定义内部方法，输出对外暴露的方法</span></div><div class=\"line\">combineReducers.js <span class=\"comment\">//将多个reducer 合并成一个</span></div><div class=\"line\">bindActionCreators.js <span class=\"comment\">//把actionCreator 包了一层dispatch，使用时可以像普通函数一样调用actionCreator</span></div><div class=\"line\">applyMiddleware.js <span class=\"comment\">//组合串联middleware</span></div><div class=\"line\">compose.js <span class=\"comment\">//工具方法，将middleware中间件方法组合成一个调用链</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"createStore-js\"><a href=\"#createStore-js\" class=\"headerlink\" title=\"createStore.js\"></a>createStore.js</h4><p>这是redux 最核心概念的实现部分。createStore方法的作用是创建一个store,并维持state。下面我们就通过源码看下store 是如何维持state的。</p>\n<p>createStore方法接受三个参数：reducer [, preloadedState, enhancer],<br>返回一个store对象，包含4个方法：</p>\n<ul>\n<li>dispatch //触发action</li>\n<li>subscribe// 添加监听者</li>\n<li>getState //获取当前state</li>\n<li>replaceReducer </li>\n<li>observable</li>\n</ul>\n<p>以下源码为方便阅读，去掉了原注释，和异常抛错信息。注释信息为解读信息。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> $$observable <span class=\"keyword\">from</span> <span class=\"string\">'symbol-observable'</span></div><div class=\"line\"><span class=\"keyword\">import</span> ActionTypes <span class=\"keyword\">from</span> <span class=\"string\">'./utils/actionTypes'</span></div><div class=\"line\"><span class=\"keyword\">import</span> isPlainObject <span class=\"keyword\">from</span> <span class=\"string\">'./utils/isPlainObject'</span></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * [createStore description]    通过createStore方法创建一个store,store来维护和持有应用的state</div><div class=\"line\"> * @param  &#123;Function&#125; reducer   函数 接收当前state和action为参数返回新的state</div><div class=\"line\"> * @param  &#123;any&#125; preloadedState 默认的初始化state，如果你的reducer是通过combineReducers生成的一个顶层reducer,</div><div class=\"line\"> *                              那初始state的key值和combineReducers的key是一一对应的</div><div class=\"line\"> * @param  &#123;Function&#125; enhancer  store增强器 通常添加中间件</div><div class=\"line\"> * @return &#123;Store&#125;              store，允许你读取state,dispatch actions以及注册订阅者</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createStore</span>(<span class=\"params\">reducer, preloadedState, enhancer</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">//允许使用方灵活传参：可以不传默认state 直接传 enhancer参数</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> preloadedState === <span class=\"string\">'function'</span> &amp;&amp; <span class=\"keyword\">typeof</span> enhancer === <span class=\"string\">'undefined'</span>) &#123;</div><div class=\"line\">    enhancer = preloadedState</div><div class=\"line\">    preloadedState = <span class=\"literal\">undefined</span></div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> enhancer !== <span class=\"string\">'undefined'</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> enhancer !== <span class=\"string\">'function'</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Expected the enhancer to be a function.'</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//这行代码到 applyMiddleWare时说明</span></div><div class=\"line\">    <span class=\"keyword\">return</span> enhancer(createStore)(reducer, preloadedState)</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> reducer !== <span class=\"string\">'function'</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Expected the reducer to be a function.'</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">//这里是一些函数内的变量，由于闭包特性，这些变量在调用createStore函数后不会被销毁（因为导出的对象方法里面有这些变量的引用）。</span></div><div class=\"line\">  <span class=\"comment\">//这里指的注意的一点是有两个listeners队列：currentListeners 和 nextListeners；这一点有点厉害了，下面介绍</span></div><div class=\"line\">  <span class=\"keyword\">let</span> currentReducer = reducer </div><div class=\"line\">  <span class=\"keyword\">let</span> currentState = preloadedState</div><div class=\"line\">  <span class=\"keyword\">let</span> currentListeners = []</div><div class=\"line\">  <span class=\"keyword\">let</span> nextListeners = currentListeners</div><div class=\"line\">  <span class=\"keyword\">let</span> isDispatching = <span class=\"literal\">false</span></div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">//nextListeners是currentListeners的拷贝，我们修改（subscribe）都是对nextListeners的修改</span></div><div class=\"line\">  <span class=\"comment\">//在flush listeners 之前 nextListeners 同步 currentListeners</span></div><div class=\"line\">  <span class=\"comment\">//这么做可以保证 每次dispatch listener 过程中 subscribe/unsubscribe listerens不会影响当前dispatch 队列，改变值发生在nextListeners，下一次dispatch时生效。 </span></div><div class=\"line\">  <span class=\"comment\">//TODO：我只知道这里这么做有点屌，具体这么做有啥用，我还得研究下</span></div><div class=\"line\">  </div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ensureCanMutateNextListeners</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">//nextListeners === currentListener 说明listeners已经被flush; </span></div><div class=\"line\">  <span class=\"comment\">//nextListeners !== currentListener 说明subscribe(listener)后 还未被dispatch</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (nextListeners === currentListeners) &#123;</div><div class=\"line\">      nextListeners = currentListeners.slice()</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\">     * 读取state </div><div class=\"line\">     * @returns &#123;any&#125; 返回应用的当前state树</div><div class=\"line\">     */</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getState</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (isDispatching) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">''</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> currentState</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">subscribe</span>(<span class=\"params\">listener</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> listener !== <span class=\"string\">'function'</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Expected listener to be a function.'</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (isDispatching) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">''</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">let</span> isSubscribed = <span class=\"literal\">true</span></div><div class=\"line\"></div><div class=\"line\">    ensureCanMutateNextListeners()</div><div class=\"line\">    nextListeners.push(listener)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">unsubscribe</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (!isSubscribed) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span></div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">if</span> (isDispatching) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">''</span>)</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      isSubscribed = <span class=\"literal\">false</span></div><div class=\"line\"></div><div class=\"line\">      ensureCanMutateNextListeners()</div><div class=\"line\">      <span class=\"keyword\">const</span> index = nextListeners.indexOf(listener)</div><div class=\"line\">      nextListeners.splice(index, <span class=\"number\">1</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">//唯一改变store里数据（state）的方式就是调用store.dispatch</span></div><div class=\"line\">  <span class=\"comment\">//dispatch 做了两件事情：1调用 reducer 更改数据 2 flush 所有listeners</span></div><div class=\"line\">  <span class=\"comment\">//这里和flux有点不同, flux里 观察数据的变化，以及数据变化后的通知，这些需要你自己去实现 这一环节的观察者模式。</span></div><div class=\"line\">  <span class=\"comment\">//redux自身实现了这一环节的观察者模式，提供了 store.subscribe方法添加listeners，dispatch的时候会 flush这些listeners </span></div><div class=\"line\"> </div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dispatch</span>(<span class=\"params\">action</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!isPlainObject(action)) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">''</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> action.type === <span class=\"string\">'undefined'</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">''</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">     <span class=\"comment\">// reducer内部不允许再次调用dispatch，否则抛出异常 防止死循环？</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (isDispatching) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Reducers may not dispatch actions.'</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">      isDispatching = <span class=\"literal\">true</span></div><div class=\"line\">      currentState = currentReducer(currentState, action)</div><div class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">      isDispatching = <span class=\"literal\">false</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//触发所有的状态监听回调函数</span></div><div class=\"line\">    <span class=\"keyword\">const</span> listeners = currentListeners = nextListeners</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; listeners.length; i++) &#123;</div><div class=\"line\">      <span class=\"keyword\">const</span> listener = listeners[i]</div><div class=\"line\">      listener()</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> action</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 顾名思义，就是替换当前store在用的reducer</span></div><div class=\"line\">  <span class=\"comment\">// 有什么用呢？你想动态加载某些reducer时,加载后用该方法替换reducer; 如果你想为redux实现热更新机制，也需要该方法</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">replaceReducer</span>(<span class=\"params\">nextReducer</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> nextReducer !== <span class=\"string\">'function'</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Expected the nextReducer to be a function.'</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    currentReducer = nextReducer</div><div class=\"line\">    dispatch(&#123; <span class=\"attr\">type</span>: ActionTypes.REPLACE &#125;)</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">//</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">observable</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> outerSubscribe = subscribe</div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">      subscribe(observer) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> observer !== <span class=\"string\">'object'</span>) &#123;</div><div class=\"line\">          <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">'Expected the observer to be an object.'</span>)</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">observeState</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">          <span class=\"keyword\">if</span> (observer.next) &#123;</div><div class=\"line\">            observer.next(getState())</div><div class=\"line\">          &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        observeState()</div><div class=\"line\">        <span class=\"keyword\">const</span> unsubscribe = outerSubscribe(observeState)</div><div class=\"line\">        <span class=\"keyword\">return</span> &#123; unsubscribe &#125;</div><div class=\"line\">      &#125;,</div><div class=\"line\"></div><div class=\"line\">      [$$observable]() &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  dispatch(&#123; <span class=\"attr\">type</span>: ActionTypes.INIT &#125;)</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">    dispatch,</div><div class=\"line\">    subscribe,</div><div class=\"line\">    getState,</div><div class=\"line\">    replaceReducer,</div><div class=\"line\">    [$$observable]: observable</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里最值得关注的就是currentListeners 和nextListeners这两个listener队列及ensureCanMutateNextListeners方法。每次修改的是nextListeners。每次flush listeners时 将nextListeners和currentListeners同步。</p>\n<h4 id=\"bindActionCreators-js\"><a href=\"#bindActionCreators-js\" class=\"headerlink\" title=\"bindActionCreators.js\"></a>bindActionCreators.js</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//bindActionCreators 用法</span></div><div class=\"line\">bindActionCreators(&#123; <span class=\"comment\">//第一个参数也可以是一个 actionCreator函数</span></div><div class=\"line\">    addCreator, <span class=\"comment\">//属性值是actionCreator函数</span></div><div class=\"line\">    anotherCreator,</div><div class=\"line\">    ...</div><div class=\"line\">&#125;,dispatch)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//bindActionCreator</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bindActionCreator</span>(<span class=\"params\">actionCreator, dispatch</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; </div><div class=\"line\">    <span class=\"keyword\">return</span> dispatch(actionCreator.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>)) </div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//bindActionCreators返回值</span></div><div class=\"line\">=&gt; boundActionCreators = &#123;</div><div class=\"line\">    <span class=\"attr\">addCreator</span>: bindActionCreator(addCreator, dispatch),</div><div class=\"line\">    <span class=\"attr\">anotherCreator</span>: bindActionCreator(anotherCreator, dispatch),</div><div class=\"line\">    </div><div class=\"line\">&#125;</div><div class=\"line\">or </div><div class=\"line\">=&gt; </div><div class=\"line\"></div><div class=\"line\">bindActionCreator(actionCreators, dispatch) =&gt; <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">...arg</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> dispatch(actionCreator(...arg))) </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//actionCreator</span></div><div class=\"line\">actionCreator() =&gt; action (对象)，用的时候dispatch(actionCreator())</div></pre></td></tr></table></figure>\n<p>bindActionCreators 主要是把actionCreator 包了一层dispatch，使用时可以像普通函数一样调用actionCreator。使得对redux 无感知。</p>\n<h4 id=\"applyMiddleWare\"><a href=\"#applyMiddleWare\" class=\"headerlink\" title=\"applyMiddleWare\"></a>applyMiddleWare</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> compose <span class=\"keyword\">from</span> <span class=\"string\">'./compose'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">applyMiddleware</span>(<span class=\"params\">...middlewares</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">createStore</span>) =&gt;</span> (...args) =&gt; &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> store = createStore(...args)</div><div class=\"line\">    <span class=\"keyword\">let</span> dispatch = store.dispatch</div><div class=\"line\">    <span class=\"keyword\">let</span> chain = []</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">const</span> middlewareAPI = &#123;</div><div class=\"line\">      <span class=\"attr\">getState</span>: store.getState,</div><div class=\"line\">      <span class=\"attr\">dispatch</span>: <span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> dispatch(...args)</div><div class=\"line\">    &#125;</div><div class=\"line\">    chain = middlewares.map(<span class=\"function\"><span class=\"params\">middleware</span> =&gt;</span> middleware(middlewareAPI))</div><div class=\"line\">    dispatch = compose(...chain)(store.dispatch)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">      ...store,</div><div class=\"line\">      dispatch</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"compose-js\"><a href=\"#compose-js\" class=\"headerlink\" title=\"compose.js\"></a>compose.js</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">compose</span>(<span class=\"params\">...funcs</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (funcs.length === <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">arg</span> =&gt;</span> arg</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span> (funcs.length === <span class=\"number\">1</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> funcs[<span class=\"number\">0</span>]</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> funcs.reduce(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> (...args) =&gt; a(b(...args)))</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><ul>\n<li><a href=\"https://github.com/reactjs/redux\" target=\"_blank\" rel=\"external\">github</a></li>\n<li><a href=\"http://cn.redux.js.org/index.html\" target=\"_blank\" rel=\"external\">中文文档</a></li>\n<li><a href=\"http://www.jianshu.com/p/7ae531a8b299?from=timeline\" target=\"_blank\" rel=\"external\">源码解读</a></li>\n<li><a href=\"https://github.com/react-guide/redux-tutorial-cn#redux-tutorial\" target=\"_blank\" rel=\"external\">极简教程</a></li>\n<li><a href=\"\">极简代码示例</a></li>\n</ul>\n","excerpt":"<h3 id=\"redux简单介绍\"><a href=\"#redux简单介绍\" class=\"headerlink\" title=\"redux简单介绍\"></a>redux简单介绍</h3><p>前面<a href=\"\">理解了flux</a>,本篇来理解redux。<br>redux的官方介绍 </p>\n<blockquote>\n<p>Redux is a predictable state container for JavaScript apps.</p>\n</blockquote>\n<p>翻译一下：redux 是javascript 应用状态容器，他提供可预测化的状态管理。<br>师出flux,作用和flux一样，作为应用的状态管理层。其核心思想也是单向数据流。</p>\n<p>我们先看一个redux 最简单的原生使用实例；然后再胡乱解读一通redux概念；最后通过源码来看下其实现原理。</p>","more":"<h3 id=\"redux如何使用-代码示例\"><a href=\"#redux如何使用-代码示例\" class=\"headerlink\" title=\"redux如何使用-代码示例\"></a>redux如何使用-代码示例</h3><p><a href=\"https://github.com/reactjs/redux/blob/master/examples/counter-vanilla/index.html\">Counter Vanilla</a> 这是redux 官方一个原生代码使用redux的实例，非常好懂。 例子是一个计数器，点击+号 完成加一操作，点击 -号，完成减一操作。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Redux basic example<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://cdn.bootcss.com/redux/3.7.2/redux.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">        Clicked: <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">id</span>=<span class=\"string\">\"value\"</span>&gt;</span>0<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span> times</div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">id</span>=<span class=\"string\">\"increment\"</span>&gt;</span>+<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">id</span>=<span class=\"string\">\"decrement\"</span>&gt;</span>-<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">id</span>=<span class=\"string\">\"incrementIfOdd\"</span>&gt;</span>Increment if odd<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">id</span>=<span class=\"string\">\"incrementAsync\"</span>&gt;</span>Increment async<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></div><div class=\"line\">      <span class=\"comment\">//counter函数是一个reducer，现在只需要知道reducer就是操作应用数据的方法</span></div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">counter</span>(<span class=\"params\">state, action</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> state === <span class=\"string\">'undefined'</span>) &#123;</div><div class=\"line\">          <span class=\"keyword\">return</span> <span class=\"number\">0</span></div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">switch</span> (action.type) &#123;</div><div class=\"line\">          <span class=\"keyword\">case</span> <span class=\"string\">'INCREMENT'</span>:</div><div class=\"line\">            <span class=\"keyword\">return</span> state + <span class=\"number\">1</span></div><div class=\"line\">          <span class=\"keyword\">case</span> <span class=\"string\">'DECREMENT'</span>:</div><div class=\"line\">            <span class=\"keyword\">return</span> state - <span class=\"number\">1</span></div><div class=\"line\">          <span class=\"keyword\">default</span>:</div><div class=\"line\">            <span class=\"keyword\">return</span> state</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"comment\">//实例化一个 store ，store里可以持久化存储应用的数据 state</span></div><div class=\"line\">      <span class=\"comment\">//并且对外暴露几个方法</span></div><div class=\"line\">      <span class=\"comment\">//其中 getState()用来获取应用的数据</span></div><div class=\"line\">      <span class=\"comment\">//其中 subscribe()用来添加订阅者，供数据发生变化时通知</span></div><div class=\"line\">      <span class=\"comment\">//其中 dispatch(action) 触发一个动作用来改变数据 </span></div><div class=\"line\">      <span class=\"keyword\">var</span> store = Redux.createStore(counter)</div><div class=\"line\">      <span class=\"keyword\">var</span> valueEl = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'value'</span>)</div><div class=\"line\">      </div><div class=\"line\">      </div><div class=\"line\">      <span class=\"comment\">//render函数 将数据（state）呈现到view</span></div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">render</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        valueEl.innerHTML = store.getState().toString()</div><div class=\"line\">      &#125;</div><div class=\"line\">      render()</div><div class=\"line\">      </div><div class=\"line\">      <span class=\"comment\">//将render 订阅store，数据变了的时候view重新渲染</span></div><div class=\"line\">      store.subscribe(render)</div><div class=\"line\">      </div><div class=\"line\">      <span class=\"comment\">//通过dispatch触发一个操作 来修改数据</span></div><div class=\"line\">      <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'increment'</span>)</div><div class=\"line\">        .addEventListener(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">          store.dispatch(&#123; <span class=\"attr\">type</span>: <span class=\"string\">'INCREMENT'</span> &#125;)</div><div class=\"line\">        &#125;)</div><div class=\"line\">      <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'decrement'</span>)</div><div class=\"line\">        .addEventListener(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">          store.dispatch(&#123; <span class=\"attr\">type</span>: <span class=\"string\">'DECREMENT'</span> &#125;)</div><div class=\"line\">        &#125;)</div><div class=\"line\">      <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'incrementIfOdd'</span>)</div><div class=\"line\">        .addEventListener(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">          <span class=\"keyword\">if</span> (store.getState() % <span class=\"number\">2</span> !== <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            store.dispatch(&#123; <span class=\"attr\">type</span>: <span class=\"string\">'INCREMENT'</span> &#125;)</div><div class=\"line\">          &#125;</div><div class=\"line\">        &#125;)</div><div class=\"line\">      <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'incrementAsync'</span>)</div><div class=\"line\">        .addEventListener(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">          setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            store.dispatch(&#123; <span class=\"attr\">type</span>: <span class=\"string\">'INCREMENT'</span> &#125;)</div><div class=\"line\">          &#125;, <span class=\"number\">1000</span>)</div><div class=\"line\">        &#125;)</div><div class=\"line\">    </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>这个例子很简单。 </p>\n<ul>\n<li>数据存储在store；</li>\n<li>view（render函数）订阅store,store变化的时候会通知view 进行刷新；</li>\n<li>通过store.dispatch 来修改数据</li>\n</ul>\n<p>我们的应用无非就是这么几部分：</p>\n<ul>\n<li>用户界面（呈现数据）；</li>\n<li>应用数据；</li>\n<li>操作数据和响应用户操作的方法。 </li>\n</ul>\n<p>这些即对应MVC架构的view、model、controller。<br>在flux、redux里，也有这些角色，那他们和MVC架构有何不同呢？那就是 flux、redux强制单向数据流来使得数据可预测。 下面我们来看redux的概念和结构。</p>\n<h3 id=\"redux-结构\"><a href=\"#redux-结构\" class=\"headerlink\" title=\"redux 结构\"></a>redux 结构</h3><p>上面这个例子中，状态变化的数据流向是下边这样的：<br>&gt;<br>           dispatch<br>     actions –&gt; store | reducers  –&gt; new state –&gt; view<br>      |                                               |<br>      &lt;———————————————–</p>\n<p>首先创通过createStore(counter)建了一个store。<br>点击加号的过程：触发一个加一的action: store.dispatch({ type: ‘INCREMENT’ }),dispatch 会把这个action分发到reducer（这里是counter)里。reducer 接收当前的应用状态state,返回更改后的state。 到这里数据就完成了一次修改。 由于我们的view 事先订阅了store（store.subscribe(render)）,此时store 会通知view state 变了，view 刷新（调用render方法）。</p>\n<h4 id=\"action\"><a href=\"#action\" class=\"headerlink\" title=\"action\"></a>action</h4><h5 id=\"action概念\"><a href=\"#action概念\" class=\"headerlink\" title=\"action概念\"></a>action概念</h5><p>和 flux里的概念一样，用来描述发生了什么。<br>是一个普通对象，包含一个type属性来描述这个动作， 和其他数据属性。<br>比如 { type: ‘INCREMENT’, num: 1},描述一个增加的动作，增加值为1。</p>\n<h5 id=\"action-扩展\"><a href=\"#action-扩展\" class=\"headerlink\" title=\"action 扩展\"></a>action 扩展</h5><ul>\n<li><p>createAction</p>\n<p>  也和flux 里一样，是一个生成action的函数，输入action中变化的部分作为参数，输出一个action对象.因为同样的action 在应用中可能多次用到，通过createAction函数可以减少重复代码,提高代码复用。</p>\n</li>\n<li><p>bindActionCreators </p>\n<p>  redux里还提供了bindActionCreators。action只是描述一个行为(好比一个事件event),他本身是不会产生任何影响的，想要触发一个action 让这个描述变成现实，是通过dispatch 方法来触发的（dispatch一个action 好比触发一个event）。而bindActionCreators 就是对dispatch 行为的一个封装，是的业务方触发一个action时可以像普通函数一样调用，而不感知dispatch 的存在。更具体的下面解读源码再说。</p>\n</li>\n</ul>\n<h4 id=\"reducer\"><a href=\"#reducer\" class=\"headerlink\" title=\"reducer\"></a>reducer</h4><p>reducer 是纯函数。<br>上面我们说了让一个action产生影响是通过dispatch(action)来触发的。 而这里的dispatch 只是触发而已，具体干活的就是reducer，dispatch内部调度reducer。<br>reducer是一个函数，接收当前state和action 返回新的state。</p>\n<p>reducer 和 dispatch 共同充当了flux里的dispatcher（registerCallback,dispatch）角色。</p>\n<h5 id=\"reducer扩展\"><a href=\"#reducer扩展\" class=\"headerlink\" title=\"reducer扩展\"></a>reducer扩展</h5><ul>\n<li>combineReducers 方法<br>实际应用中有不止一个reducer。redux里提供了一个combineReducers()方法来组织这些reducer。具体下边源码分析再说。</li>\n</ul>\n<h4 id=\"store\"><a href=\"#store\" class=\"headerlink\" title=\"store\"></a>store</h4><p>上面我们知道了，我们使用action 来描述发生了什么，使用reducer来根据action更新state。</p>\n<p>而store 就是把action 和reducer结合起来的对象，并持有state。store负责：</p>\n<ul>\n<li>维持应用的state,并提供getState()方法获取state</li>\n<li>提供 dispatch(action) 方法更新 state；</li>\n<li>提供 subscribe(listener) / unsubscribe(listener) 来注册和解绑监听者。 </li>\n</ul>\n<p>Redux 应用只有一个单一的 store，当需要拆分数据处理逻辑时，你应该使用 reducer 组合 而不是创建多个 store。</p>\n<h3 id=\"redux-源码解读-基于redux3-7\"><a href=\"#redux-源码解读-基于redux3-7\" class=\"headerlink\" title=\"redux 源码解读(基于redux3.7)\"></a>redux 源码解读(基于redux3.7)</h3><h4 id=\"先看下代码结构\"><a href=\"#先看下代码结构\" class=\"headerlink\" title=\"先看下代码结构\"></a>先看下代码结构</h4><p>redux 对外暴露五个方法，分别对应五个同名js文件：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">createStore.js <span class=\"comment\">//保存应用状态 定义内部方法，输出对外暴露的方法</span></div><div class=\"line\">combineReducers.js <span class=\"comment\">//将多个reducer 合并成一个</span></div><div class=\"line\">bindActionCreators.js <span class=\"comment\">//把actionCreator 包了一层dispatch，使用时可以像普通函数一样调用actionCreator</span></div><div class=\"line\">applyMiddleware.js <span class=\"comment\">//组合串联middleware</span></div><div class=\"line\">compose.js <span class=\"comment\">//工具方法，将middleware中间件方法组合成一个调用链</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"createStore-js\"><a href=\"#createStore-js\" class=\"headerlink\" title=\"createStore.js\"></a>createStore.js</h4><p>这是redux 最核心概念的实现部分。createStore方法的作用是创建一个store,并维持state。下面我们就通过源码看下store 是如何维持state的。</p>\n<p>createStore方法接受三个参数：reducer [, preloadedState, enhancer],<br>返回一个store对象，包含4个方法：</p>\n<ul>\n<li>dispatch //触发action</li>\n<li>subscribe// 添加监听者</li>\n<li>getState //获取当前state</li>\n<li>replaceReducer </li>\n<li>observable</li>\n</ul>\n<p>以下源码为方便阅读，去掉了原注释，和异常抛错信息。注释信息为解读信息。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> $$observable <span class=\"keyword\">from</span> <span class=\"string\">'symbol-observable'</span></div><div class=\"line\"><span class=\"keyword\">import</span> ActionTypes <span class=\"keyword\">from</span> <span class=\"string\">'./utils/actionTypes'</span></div><div class=\"line\"><span class=\"keyword\">import</span> isPlainObject <span class=\"keyword\">from</span> <span class=\"string\">'./utils/isPlainObject'</span></div><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * [createStore description]    通过createStore方法创建一个store,store来维护和持有应用的state</div><div class=\"line\"> * @param  &#123;Function&#125; reducer   函数 接收当前state和action为参数返回新的state</div><div class=\"line\"> * @param  &#123;any&#125; preloadedState 默认的初始化state，如果你的reducer是通过combineReducers生成的一个顶层reducer,</div><div class=\"line\"> *                              那初始state的key值和combineReducers的key是一一对应的</div><div class=\"line\"> * @param  &#123;Function&#125; enhancer  store增强器 通常添加中间件</div><div class=\"line\"> * @return &#123;Store&#125;              store，允许你读取state,dispatch actions以及注册订阅者</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createStore</span>(<span class=\"params\">reducer, preloadedState, enhancer</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">//允许使用方灵活传参：可以不传默认state 直接传 enhancer参数</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> preloadedState === <span class=\"string\">'function'</span> &amp;&amp; <span class=\"keyword\">typeof</span> enhancer === <span class=\"string\">'undefined'</span>) &#123;</div><div class=\"line\">    enhancer = preloadedState</div><div class=\"line\">    preloadedState = <span class=\"literal\">undefined</span></div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> enhancer !== <span class=\"string\">'undefined'</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> enhancer !== <span class=\"string\">'function'</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Expected the enhancer to be a function.'</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//这行代码到 applyMiddleWare时说明</span></div><div class=\"line\">    <span class=\"keyword\">return</span> enhancer(createStore)(reducer, preloadedState)</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> reducer !== <span class=\"string\">'function'</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Expected the reducer to be a function.'</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">//这里是一些函数内的变量，由于闭包特性，这些变量在调用createStore函数后不会被销毁（因为导出的对象方法里面有这些变量的引用）。</span></div><div class=\"line\">  <span class=\"comment\">//这里指的注意的一点是有两个listeners队列：currentListeners 和 nextListeners；这一点有点厉害了，下面介绍</span></div><div class=\"line\">  <span class=\"keyword\">let</span> currentReducer = reducer </div><div class=\"line\">  <span class=\"keyword\">let</span> currentState = preloadedState</div><div class=\"line\">  <span class=\"keyword\">let</span> currentListeners = []</div><div class=\"line\">  <span class=\"keyword\">let</span> nextListeners = currentListeners</div><div class=\"line\">  <span class=\"keyword\">let</span> isDispatching = <span class=\"literal\">false</span></div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">//nextListeners是currentListeners的拷贝，我们修改（subscribe）都是对nextListeners的修改</span></div><div class=\"line\">  <span class=\"comment\">//在flush listeners 之前 nextListeners 同步 currentListeners</span></div><div class=\"line\">  <span class=\"comment\">//这么做可以保证 每次dispatch listener 过程中 subscribe/unsubscribe listerens不会影响当前dispatch 队列，改变值发生在nextListeners，下一次dispatch时生效。 </span></div><div class=\"line\">  <span class=\"comment\">//TODO：我只知道这里这么做有点屌，具体这么做有啥用，我还得研究下</span></div><div class=\"line\">  </div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ensureCanMutateNextListeners</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">//nextListeners === currentListener 说明listeners已经被flush; </span></div><div class=\"line\">  <span class=\"comment\">//nextListeners !== currentListener 说明subscribe(listener)后 还未被dispatch</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (nextListeners === currentListeners) &#123;</div><div class=\"line\">      nextListeners = currentListeners.slice()</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">    <span class=\"comment\">/**</div><div class=\"line\">     * 读取state </div><div class=\"line\">     * @returns &#123;any&#125; 返回应用的当前state树</div><div class=\"line\">     */</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getState</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (isDispatching) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">''</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> currentState</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">subscribe</span>(<span class=\"params\">listener</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> listener !== <span class=\"string\">'function'</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Expected listener to be a function.'</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (isDispatching) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">''</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">let</span> isSubscribed = <span class=\"literal\">true</span></div><div class=\"line\"></div><div class=\"line\">    ensureCanMutateNextListeners()</div><div class=\"line\">    nextListeners.push(listener)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">unsubscribe</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (!isSubscribed) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span></div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">if</span> (isDispatching) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">''</span>)</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      isSubscribed = <span class=\"literal\">false</span></div><div class=\"line\"></div><div class=\"line\">      ensureCanMutateNextListeners()</div><div class=\"line\">      <span class=\"keyword\">const</span> index = nextListeners.indexOf(listener)</div><div class=\"line\">      nextListeners.splice(index, <span class=\"number\">1</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">//唯一改变store里数据（state）的方式就是调用store.dispatch</span></div><div class=\"line\">  <span class=\"comment\">//dispatch 做了两件事情：1调用 reducer 更改数据 2 flush 所有listeners</span></div><div class=\"line\">  <span class=\"comment\">//这里和flux有点不同, flux里 观察数据的变化，以及数据变化后的通知，这些需要你自己去实现 这一环节的观察者模式。</span></div><div class=\"line\">  <span class=\"comment\">//redux自身实现了这一环节的观察者模式，提供了 store.subscribe方法添加listeners，dispatch的时候会 flush这些listeners </span></div><div class=\"line\"> </div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dispatch</span>(<span class=\"params\">action</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!isPlainObject(action)) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">''</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> action.type === <span class=\"string\">'undefined'</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">''</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">     <span class=\"comment\">// reducer内部不允许再次调用dispatch，否则抛出异常 防止死循环？</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (isDispatching) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Reducers may not dispatch actions.'</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">      isDispatching = <span class=\"literal\">true</span></div><div class=\"line\">      currentState = currentReducer(currentState, action)</div><div class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">      isDispatching = <span class=\"literal\">false</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//触发所有的状态监听回调函数</span></div><div class=\"line\">    <span class=\"keyword\">const</span> listeners = currentListeners = nextListeners</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; listeners.length; i++) &#123;</div><div class=\"line\">      <span class=\"keyword\">const</span> listener = listeners[i]</div><div class=\"line\">      listener()</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> action</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 顾名思义，就是替换当前store在用的reducer</span></div><div class=\"line\">  <span class=\"comment\">// 有什么用呢？你想动态加载某些reducer时,加载后用该方法替换reducer; 如果你想为redux实现热更新机制，也需要该方法</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">replaceReducer</span>(<span class=\"params\">nextReducer</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> nextReducer !== <span class=\"string\">'function'</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Expected the nextReducer to be a function.'</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    currentReducer = nextReducer</div><div class=\"line\">    dispatch(&#123; <span class=\"attr\">type</span>: ActionTypes.REPLACE &#125;)</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">//</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">observable</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> outerSubscribe = subscribe</div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">      subscribe(observer) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> observer !== <span class=\"string\">'object'</span>) &#123;</div><div class=\"line\">          <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">'Expected the observer to be an object.'</span>)</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">observeState</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">          <span class=\"keyword\">if</span> (observer.next) &#123;</div><div class=\"line\">            observer.next(getState())</div><div class=\"line\">          &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        observeState()</div><div class=\"line\">        <span class=\"keyword\">const</span> unsubscribe = outerSubscribe(observeState)</div><div class=\"line\">        <span class=\"keyword\">return</span> &#123; unsubscribe &#125;</div><div class=\"line\">      &#125;,</div><div class=\"line\"></div><div class=\"line\">      [$$observable]() &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  dispatch(&#123; <span class=\"attr\">type</span>: ActionTypes.INIT &#125;)</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">    dispatch,</div><div class=\"line\">    subscribe,</div><div class=\"line\">    getState,</div><div class=\"line\">    replaceReducer,</div><div class=\"line\">    [$$observable]: observable</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里最值得关注的就是currentListeners 和nextListeners这两个listener队列及ensureCanMutateNextListeners方法。每次修改的是nextListeners。每次flush listeners时 将nextListeners和currentListeners同步。</p>\n<h4 id=\"bindActionCreators-js\"><a href=\"#bindActionCreators-js\" class=\"headerlink\" title=\"bindActionCreators.js\"></a>bindActionCreators.js</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//bindActionCreators 用法</span></div><div class=\"line\">bindActionCreators(&#123; <span class=\"comment\">//第一个参数也可以是一个 actionCreator函数</span></div><div class=\"line\">    addCreator, <span class=\"comment\">//属性值是actionCreator函数</span></div><div class=\"line\">    anotherCreator,</div><div class=\"line\">    ...</div><div class=\"line\">&#125;,dispatch)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//bindActionCreator</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bindActionCreator</span>(<span class=\"params\">actionCreator, dispatch</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; </div><div class=\"line\">    <span class=\"keyword\">return</span> dispatch(actionCreator.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>)) </div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//bindActionCreators返回值</span></div><div class=\"line\">=&gt; boundActionCreators = &#123;</div><div class=\"line\">    <span class=\"attr\">addCreator</span>: bindActionCreator(addCreator, dispatch),</div><div class=\"line\">    <span class=\"attr\">anotherCreator</span>: bindActionCreator(anotherCreator, dispatch),</div><div class=\"line\">    </div><div class=\"line\">&#125;</div><div class=\"line\">or </div><div class=\"line\">=&gt; </div><div class=\"line\"></div><div class=\"line\">bindActionCreator(actionCreators, dispatch) =&gt; <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">...arg</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> dispatch(actionCreator(...arg))) </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//actionCreator</span></div><div class=\"line\">actionCreator() =&gt; action (对象)，用的时候dispatch(actionCreator())</div></pre></td></tr></table></figure>\n<p>bindActionCreators 主要是把actionCreator 包了一层dispatch，使用时可以像普通函数一样调用actionCreator。使得对redux 无感知。</p>\n<h4 id=\"applyMiddleWare\"><a href=\"#applyMiddleWare\" class=\"headerlink\" title=\"applyMiddleWare\"></a>applyMiddleWare</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> compose <span class=\"keyword\">from</span> <span class=\"string\">'./compose'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">applyMiddleware</span>(<span class=\"params\">...middlewares</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">createStore</span>) =&gt;</span> (...args) =&gt; &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> store = createStore(...args)</div><div class=\"line\">    <span class=\"keyword\">let</span> dispatch = store.dispatch</div><div class=\"line\">    <span class=\"keyword\">let</span> chain = []</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">const</span> middlewareAPI = &#123;</div><div class=\"line\">      <span class=\"attr\">getState</span>: store.getState,</div><div class=\"line\">      <span class=\"attr\">dispatch</span>: <span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> dispatch(...args)</div><div class=\"line\">    &#125;</div><div class=\"line\">    chain = middlewares.map(<span class=\"function\"><span class=\"params\">middleware</span> =&gt;</span> middleware(middlewareAPI))</div><div class=\"line\">    dispatch = compose(...chain)(store.dispatch)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">      ...store,</div><div class=\"line\">      dispatch</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"compose-js\"><a href=\"#compose-js\" class=\"headerlink\" title=\"compose.js\"></a>compose.js</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">compose</span>(<span class=\"params\">...funcs</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (funcs.length === <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">arg</span> =&gt;</span> arg</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span> (funcs.length === <span class=\"number\">1</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> funcs[<span class=\"number\">0</span>]</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> funcs.reduce(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> (...args) =&gt; a(b(...args)))</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><ul>\n<li><a href=\"https://github.com/reactjs/redux\">github</a></li>\n<li><a href=\"http://cn.redux.js.org/index.html\">中文文档</a></li>\n<li><a href=\"http://www.jianshu.com/p/7ae531a8b299?from=timeline\">源码解读</a></li>\n<li><a href=\"https://github.com/react-guide/redux-tutorial-cn#redux-tutorial\">极简教程</a></li>\n<li><a href=\"\">极简代码示例</a></li>\n</ul>"},{"title":"设计模式之工厂模式","date":"2017-08-27T09:13:22.000Z","_content":"\n\n## 设计模式-创建型之工厂模式\n\n\n创建型设计模式共六种：\n\n* 简单工厂模式\n* 工厂方法模式\n* 抽象工厂模式\n* 建造者模式\n* 原型模式\n* 单例模式\n\n本篇讲三个工厂模式： 简单工厂、工厂方法、抽象工厂。\n\n<!-- more -->\n\n创建型设计模式是用来创建对象的，在面向对象的编程中最常用的一种创建对象方式是用new操作符产生一个对象实例。\n创建型模式对类的实例化过程进行了抽象，能够将对象的创建与对象的使用过程分离。\n### 简单工厂模式\n\n#### 模式定义\n\n简单工厂模式：又称静态工厂模式。在该模式中可以通过参数的不同返回不同的实例。简单工厂模式专门定义一个类来负责创建其他类的实例。被创建的实例通常都具有共同的分类。\n\n#### 模式的结构\n\n* Factory-工厂角色： 负责实现创建所有实例的内部逻辑。\n* Product-抽象产品角色： 创建的所有对象的父类，负责描述所有实例所共有的公共接口。\n* ConcreteProduct-具体产品角色：创建的目标，所有创建的对象都充当这个角色的某个具体类的实例。\n\n当然，实际应用中可能没有这么严格的三个角色。但 `Factory`和 `ConcreteProduct `是必须的。 <br>\n\n简单工厂的核心定义是：有一个工厂方法（也可以是工厂类）根据接收的参数 实例化具体的类，并且返回这个类的实例。\n\n#### 实例分析\n\n这里用一个生产宝马汽车的例子。现在有两个型号的宝马车：BMW320和BMW523。\n假设此时没有宝马工厂。用户需要这个这两个型号的车的时候需要 自己去制造生产。代码如下：\n\n没有工厂的时候：\n\n``` java\n    public class BMW320 {\n        public BMW320 {\n            System.out.println('生产320型号的宝马车');\n        }\n    }\n\n    public class BMW523 {\n        public BMW523 {\n            System.out.println('生产320型号的宝马车');\n        }\n    }\n    \n    public class Customer {\n        public static void main(String[] args) {\n            BMW320 bmw320 = new BMW320();\n            BMW523 bmw523 = new BMW523();\n        }\n    }\n```\n    \n这样客户也造出了汽车，似乎也没啥毛病。问题在于：客户需要知道怎么去创建一款车（具体new 哪个类） 这样客户和车是耦合在一起的。但车型有很多的时候，客户就需要知道每一个型号的车对应哪个类。为了解耦，我们引入简单那工厂模式  ：创建一个工厂，将创建具体那个型号的宝马车的操作细节放到工厂里，客户直接使用工厂的创建产品的方法，传入具体的型号就好了。\n\n  有了简单工厂：\n \n  产品类\n``` java\n    abstract class BMW  {\n    \n    }\n    \n    public class BMW320 extends BMW { \n        public BMW320() {  \n        System.out.println(\"制造-->BMW320\");  \n    }\n\n    public class BMW523 extends BMW {  \n        public BMW523(){  \n            System.out.println(\"制造-->BMW523\");  \n        }  \n    }\n```\n\n工厂类 \n\n``` java\n   public class BMWFactory {\n       public BMW createBMW (int type) {\n           switch (type) {\n           \n            case:  320 \n                return new BMW320();\n                \n            case: 523\n                return new BMW523();\n                \n            default:\n                break;  \n                    \n           }\n           return null;\n       }\n   }\n```\n\n客户类\n    \n``` java\n    public class Customer {\n        public static void main(Sting[] args) {\n            BMWFactory  factory = new BMWFactory();\n            BMW bmw320 = factory.createBMW(320);\n            BMW bmw523 = factory.createBMW(523); \n        }   \n    }\n```\n可以看到 具体实例化某一个class 的操作放到了工厂类里，客户只需要调用工厂方法并传参就OK了。\n\n\n#### 模式分析\n\n##### 简单工厂的优点：\n\n* 客户端更方便了：无需记忆众多复杂的类名，只需要知道具体产品类所对应的参数。\n* 责任分割： 创建产品的逻辑都放在工厂，客户端仅仅是消费产品，从而免去了直接创建产品对象的责任。\n\n\n##### 简单工厂的缺点： \n\n* 违背开闭原则的 对修改关闭。当需要新增加一类产品的时候，除了增加创建该类产品的代码外还需要修改工厂类。\n\n##### 简单工厂适用场景\n\n* 工厂类负责创建的对象比较少：由于创建的对象少，不会造成工厂法法中的业务逻辑泰国复杂。\n\n\n### 工厂方法\n\n上面我们知道了，当产品种类多了后，工厂就会很庞大，且新增一类产品就要改工厂类。此时工厂方法模式就上场了。\n\n#### 模式定义\n\n\n在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将`产品类的实例化操作延迟到工厂子类`中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。\n\n\n#### 模式的结构\n\n* Factory-抽象工厂类：\n    * 声明了工厂方法(Factory Method)，用于返回一个产品。抽象工厂是工厂方法模式的核心，所有创建对象的工厂类都必须实现该接口。\n* ConcreteFactory-具体工厂类：\n    * 它实现了抽象产品接口，一类工厂生产一类产品。\n* Product-抽象产品类：\n    *  定义产品的接口。可以是抽象类或接口。\n* ConcreteProduct-具体产品类：\n    * 实现抽象产品类的接口，产品和工厂一一对相应。\n\n    \n#### 实例分析\n\n还是接着上边简单工厂造宝马车的例子。\n\n\n产品类，和简单工厂里一样 \n``` java\n    abstract class BMW {  \n        public BMW(){  \n              \n        }  \n    }  \n    public class BMW320 extends BMW {  \n        public BMW320() {  \n            System.out.println(\"制造-->BMW320\");  \n        }  \n    }  \n    public class BMW523 extends BMW{  \n        public BMW523(){  \n            System.out.println(\"制造-->BMW523\");  \n        }  \n    }  \n```        \n\n工厂类： 抽象工厂类定义工厂类接口，工厂类创建具体的一类产品。\n\n``` java\n    interface FactoryBMW {  \n        BMW createBMW();  \n    }  \n      \n    public class FactoryBMW320 implements FactoryBMW{  \n      \n        @Override  \n        public BMW320 createBMW() {  \n      \n            return new BMW320();  \n        }  \n      \n    }  \n    public class FactoryBMW523 implements FactoryBMW {  \n        @Override  \n        public BMW523 createBMW() {  \n      \n            return new BMW523();  \n        }  \n    }       \n```\n    \n客户类：客户生产某类产品 直接实例化具体的工厂。\n\n``` java\n    public class Customer {  \n        public static void main(String[] args) {  \n            FactoryBMW320 factoryBMW320 = new FactoryBMW320();  //可通过配置文件实现 \n            BMW320 bmw320 = factoryBMW320.createBMW();  \n      \n            FactoryBMW523 factoryBMW523 = new FactoryBMW523();  \n            BMW523 bmw523 = factoryBMW523.createBMW();  \n        }  \n    }\n```\n    \n\n#### 模式分析 \n\n工厂方法模式是简单工厂模式的进一步抽象。由于使用了面向对象的多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。工厂方法模式可以允许在不修改工厂角色的情况下引进新产品。<br>\n\n基于工厂角色和产品角色的`多态性`设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，是因为所有的具体工厂类都具有同一抽象父类。\n    \n\n##### 工厂方法模式优点\n\n* `符合开闭原则`（克服了简单工厂的缺点）。引入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。\n\n\n##### 工厂方法模式的缺点\n\n* 系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。\n\n\n##### 工厂方法模式的适用场景\n* 当需要的产品种类多变，系统需要有比较好的扩展性时，可以考虑工厂模式，不同的产品用不同的实现工厂来组装。\n\n\n\n##### 工厂方法模式疑问\n\n到这里我是有点疑问的：工厂方法模式中，客户端就得知道生产某类产品对应的工厂类，当产品种类多的时候，那不就面临没有任何工厂模式时同样的问题？ \n这个问题可以通过配置文件解决。通过配置文件来存储具体工厂类ConcreteFactory的类名，更换新的具体工厂时无须修改源代码，系统扩展更为方便。\n\n那么问题又来了：那我不用工厂方法模式，我生产具体的产品（new ConcreteProduct）时，也通过配置文件来存储产品类的类名，那不就不需要工厂类了吗？ 那工厂方法模式的意义是啥呢？我的理解是 ：实际工作中，工厂类 不只是简单的new ConcreteProduct(), 同时还做一些初始化操作，比如处理前置依赖等。把这些封装在工厂类内，使得代码封装程度更高。\n\n\n\n\n### 抽象工厂 \n\n\n为了更好的理解抽象工厂模式，先说两个概念：\n\n* 产品等级结构 ：产品等级结构即产品的`继承结构`，如一个抽象类是电视机，其子类有海尔电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。\n\n* 产品族 ：产品族是指由同一个工厂生产的，位于`不同产品等级结构`中的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中。\n\n当系统所提供的工厂所需生产的具体产品并不是一个简单的对象，而是`多个位于不同产品等级结构`中属于不同类型的具体产品时需要使用抽象工厂模式。\n\n\n\n#### 模式的结构\n\n* Factory-抽象工厂类\n    * 定义了一组用于创建一组产品的方法，每个方法对应一种产品。\n    \n* ConcreteFactory-具体工厂类\n    * 实现抽象工厂中定义的创建一组产品的方法，生产一组产品。一对多。\n\n* Product-抽象产品类\n    * 定义产品接口\n    \n* ConcreteProduct-具体产品类：它定义具体工厂生产的具体产品对象，实现抽象产品接口中声明的业务方法。  \n\n\n抽象工厂中声明了多个工厂方法，用于创建不同类型的产品。\n\n\n#### 实例分析       \n\n这里改造一下上面生产宝马汽车的例子。现在我们不是生产汽车了而是生产汽车配件。现需要两种汽车配件：汽车发动机，汽车空调。还是有两个宝马型号的汽车 BMW320、BMW523。\n\n产品类\n``` java\n    //发动机以及型号    \n    public interface Engine {    \n      \n    }    \n    public class EngineA extends Engine{    \n        public EngineA(){    \n            System.out.println(\"制造-->EngineA\");    \n        }    \n    }    \n    public class EngineBextends Engine{    \n        public EngineB(){    \n            System.out.println(\"制造-->EngineB\");    \n        }    \n    }    \n      \n    //空调以及型号    \n    public interface Aircondition {    \n      \n    }    \n    public class AirconditionA extends Aircondition{    \n        public AirconditionA(){    \n            System.out.println(\"制造-->AirconditionA\");    \n        }    \n    }    \n    public class AirconditionB extends Aircondition{    \n        public AirconditionB(){    \n            System.out.println(\"制造-->AirconditionB\");    \n        }    \n    }   \n```\n \n 创建工厂类\n \n``` java\n    //创建工厂的接口   \n    public interface AbstractFactory {    \n        //制造发动机  \n        public Engine createEngine();  \n        //制造空调   \n        public Aircondition createAircondition();   \n    } \n    \n    //为宝马320系列生产配件 \n    public class FactoryBMW320 implements AbstractFactory{    \n            \n        @Override    \n        public Engine createEngine() {      \n            return new EngineA();    \n        }    \n        @Override    \n        public Aircondition createAircondition() {    \n            return new AirconditionA();    \n        }    \n    }    \n    \n    //宝马523系列配件 \n    public class FactoryBMW523 implements AbstractFactory {    \n        \n         @Override    \n        public Engine createEngine() {      \n            return new EngineB();    \n        }    \n        @Override    \n        public Aircondition createAircondition() {    \n            return new AirconditionB();    \n        }    \n      \n      \n    }\n        \n    //客户端   \n    public class Customer {    \n        public static void main(String[] args){    \n            //生产宝马320系列配件  \n            FactoryBMW320 factoryBMW320 = new FactoryBMW320();    \n            factoryBMW320.createEngine();  \n            factoryBMW320.createAircondition();  \n                \n            //生产宝马523系列配件    \n            FactoryBMW523 factoryBMW523 = new FactoryBMW523();    \n            factoryBMW320.createEngine();  \n            factoryBMW320.createAircondition();  \n        }    \n    }     \n```\n    \n    \n    \n#### 模式分析\n\n##### 抽象工厂模式的优点    \n* 首先是该模式适应了某种业务场景\n* 符合“开闭原则”：增加新的具体工厂和产品族很方便，无须修改已有系统。\n \n##### 抽象工厂模式的缺点\n\n* 在添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其`所有子类的修改`，显然会带来较大的不便。\n* 开闭原则的倾斜性（增加新的工厂和产品族容易，`增加新的产品等级结构`麻烦）\n\n##### 抽象工厂模式的适用场景   \n\n* 当系统所提供的工厂所需生产的具体产品并不是一个简单的对象，而是`多个位于不同产品等级结构`中属于不同类型的具体产品时需要使用抽象工厂模式。\n\n* 一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是重要的。\n* 系统提供一个产品类的库，所有的 `产品以同样的接口`出现，从而使客户端不依赖于具体实现。\n     \n\n##### 与工厂方法的区别\n\n抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构，一个工厂等级结构可以负责多个不同产品等级结构中的产品对象的创建 。当一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象时，抽象工厂模式比工厂方法模式更为简单、有效率。\n\n\n### 工厂模式的退化\n\n* 当`抽象工厂模式`中每一个具体工厂类只创建一个产品对象，也就是只存在一个产品等级结构时，抽象工厂模式退化成`工厂方法模式`；\n* 当工厂方法模式中抽象工厂与具体工厂合并，提供一个统一的工厂来创建产品对象将创建对象的工厂方法设计为静态方法时，工厂方法模式退化成`简单工厂模式`。\n\n\n三个工厂模式 完。\n\n\nhttp://blog.csdn.net/jason0539/article/details/44956775\n\nhttps://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/creational.html\n\n\n    ","source":"_posts/设计模式之工厂模式.md","raw":"---\ntitle: 设计模式之工厂模式\ndate: 2017-08-27 17:13:22\ntags: \n - 设计模式 \n - 工厂模式\n - 创建型模式\ncategories: \n - 设计模式\n---\n\n\n## 设计模式-创建型之工厂模式\n\n\n创建型设计模式共六种：\n\n* 简单工厂模式\n* 工厂方法模式\n* 抽象工厂模式\n* 建造者模式\n* 原型模式\n* 单例模式\n\n本篇讲三个工厂模式： 简单工厂、工厂方法、抽象工厂。\n\n<!-- more -->\n\n创建型设计模式是用来创建对象的，在面向对象的编程中最常用的一种创建对象方式是用new操作符产生一个对象实例。\n创建型模式对类的实例化过程进行了抽象，能够将对象的创建与对象的使用过程分离。\n### 简单工厂模式\n\n#### 模式定义\n\n简单工厂模式：又称静态工厂模式。在该模式中可以通过参数的不同返回不同的实例。简单工厂模式专门定义一个类来负责创建其他类的实例。被创建的实例通常都具有共同的分类。\n\n#### 模式的结构\n\n* Factory-工厂角色： 负责实现创建所有实例的内部逻辑。\n* Product-抽象产品角色： 创建的所有对象的父类，负责描述所有实例所共有的公共接口。\n* ConcreteProduct-具体产品角色：创建的目标，所有创建的对象都充当这个角色的某个具体类的实例。\n\n当然，实际应用中可能没有这么严格的三个角色。但 `Factory`和 `ConcreteProduct `是必须的。 <br>\n\n简单工厂的核心定义是：有一个工厂方法（也可以是工厂类）根据接收的参数 实例化具体的类，并且返回这个类的实例。\n\n#### 实例分析\n\n这里用一个生产宝马汽车的例子。现在有两个型号的宝马车：BMW320和BMW523。\n假设此时没有宝马工厂。用户需要这个这两个型号的车的时候需要 自己去制造生产。代码如下：\n\n没有工厂的时候：\n\n``` java\n    public class BMW320 {\n        public BMW320 {\n            System.out.println('生产320型号的宝马车');\n        }\n    }\n\n    public class BMW523 {\n        public BMW523 {\n            System.out.println('生产320型号的宝马车');\n        }\n    }\n    \n    public class Customer {\n        public static void main(String[] args) {\n            BMW320 bmw320 = new BMW320();\n            BMW523 bmw523 = new BMW523();\n        }\n    }\n```\n    \n这样客户也造出了汽车，似乎也没啥毛病。问题在于：客户需要知道怎么去创建一款车（具体new 哪个类） 这样客户和车是耦合在一起的。但车型有很多的时候，客户就需要知道每一个型号的车对应哪个类。为了解耦，我们引入简单那工厂模式  ：创建一个工厂，将创建具体那个型号的宝马车的操作细节放到工厂里，客户直接使用工厂的创建产品的方法，传入具体的型号就好了。\n\n  有了简单工厂：\n \n  产品类\n``` java\n    abstract class BMW  {\n    \n    }\n    \n    public class BMW320 extends BMW { \n        public BMW320() {  \n        System.out.println(\"制造-->BMW320\");  \n    }\n\n    public class BMW523 extends BMW {  \n        public BMW523(){  \n            System.out.println(\"制造-->BMW523\");  \n        }  \n    }\n```\n\n工厂类 \n\n``` java\n   public class BMWFactory {\n       public BMW createBMW (int type) {\n           switch (type) {\n           \n            case:  320 \n                return new BMW320();\n                \n            case: 523\n                return new BMW523();\n                \n            default:\n                break;  \n                    \n           }\n           return null;\n       }\n   }\n```\n\n客户类\n    \n``` java\n    public class Customer {\n        public static void main(Sting[] args) {\n            BMWFactory  factory = new BMWFactory();\n            BMW bmw320 = factory.createBMW(320);\n            BMW bmw523 = factory.createBMW(523); \n        }   \n    }\n```\n可以看到 具体实例化某一个class 的操作放到了工厂类里，客户只需要调用工厂方法并传参就OK了。\n\n\n#### 模式分析\n\n##### 简单工厂的优点：\n\n* 客户端更方便了：无需记忆众多复杂的类名，只需要知道具体产品类所对应的参数。\n* 责任分割： 创建产品的逻辑都放在工厂，客户端仅仅是消费产品，从而免去了直接创建产品对象的责任。\n\n\n##### 简单工厂的缺点： \n\n* 违背开闭原则的 对修改关闭。当需要新增加一类产品的时候，除了增加创建该类产品的代码外还需要修改工厂类。\n\n##### 简单工厂适用场景\n\n* 工厂类负责创建的对象比较少：由于创建的对象少，不会造成工厂法法中的业务逻辑泰国复杂。\n\n\n### 工厂方法\n\n上面我们知道了，当产品种类多了后，工厂就会很庞大，且新增一类产品就要改工厂类。此时工厂方法模式就上场了。\n\n#### 模式定义\n\n\n在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将`产品类的实例化操作延迟到工厂子类`中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。\n\n\n#### 模式的结构\n\n* Factory-抽象工厂类：\n    * 声明了工厂方法(Factory Method)，用于返回一个产品。抽象工厂是工厂方法模式的核心，所有创建对象的工厂类都必须实现该接口。\n* ConcreteFactory-具体工厂类：\n    * 它实现了抽象产品接口，一类工厂生产一类产品。\n* Product-抽象产品类：\n    *  定义产品的接口。可以是抽象类或接口。\n* ConcreteProduct-具体产品类：\n    * 实现抽象产品类的接口，产品和工厂一一对相应。\n\n    \n#### 实例分析\n\n还是接着上边简单工厂造宝马车的例子。\n\n\n产品类，和简单工厂里一样 \n``` java\n    abstract class BMW {  \n        public BMW(){  \n              \n        }  \n    }  \n    public class BMW320 extends BMW {  \n        public BMW320() {  \n            System.out.println(\"制造-->BMW320\");  \n        }  \n    }  \n    public class BMW523 extends BMW{  \n        public BMW523(){  \n            System.out.println(\"制造-->BMW523\");  \n        }  \n    }  \n```        \n\n工厂类： 抽象工厂类定义工厂类接口，工厂类创建具体的一类产品。\n\n``` java\n    interface FactoryBMW {  \n        BMW createBMW();  \n    }  \n      \n    public class FactoryBMW320 implements FactoryBMW{  \n      \n        @Override  \n        public BMW320 createBMW() {  \n      \n            return new BMW320();  \n        }  \n      \n    }  \n    public class FactoryBMW523 implements FactoryBMW {  \n        @Override  \n        public BMW523 createBMW() {  \n      \n            return new BMW523();  \n        }  \n    }       \n```\n    \n客户类：客户生产某类产品 直接实例化具体的工厂。\n\n``` java\n    public class Customer {  \n        public static void main(String[] args) {  \n            FactoryBMW320 factoryBMW320 = new FactoryBMW320();  //可通过配置文件实现 \n            BMW320 bmw320 = factoryBMW320.createBMW();  \n      \n            FactoryBMW523 factoryBMW523 = new FactoryBMW523();  \n            BMW523 bmw523 = factoryBMW523.createBMW();  \n        }  \n    }\n```\n    \n\n#### 模式分析 \n\n工厂方法模式是简单工厂模式的进一步抽象。由于使用了面向对象的多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。工厂方法模式可以允许在不修改工厂角色的情况下引进新产品。<br>\n\n基于工厂角色和产品角色的`多态性`设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，是因为所有的具体工厂类都具有同一抽象父类。\n    \n\n##### 工厂方法模式优点\n\n* `符合开闭原则`（克服了简单工厂的缺点）。引入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。\n\n\n##### 工厂方法模式的缺点\n\n* 系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。\n\n\n##### 工厂方法模式的适用场景\n* 当需要的产品种类多变，系统需要有比较好的扩展性时，可以考虑工厂模式，不同的产品用不同的实现工厂来组装。\n\n\n\n##### 工厂方法模式疑问\n\n到这里我是有点疑问的：工厂方法模式中，客户端就得知道生产某类产品对应的工厂类，当产品种类多的时候，那不就面临没有任何工厂模式时同样的问题？ \n这个问题可以通过配置文件解决。通过配置文件来存储具体工厂类ConcreteFactory的类名，更换新的具体工厂时无须修改源代码，系统扩展更为方便。\n\n那么问题又来了：那我不用工厂方法模式，我生产具体的产品（new ConcreteProduct）时，也通过配置文件来存储产品类的类名，那不就不需要工厂类了吗？ 那工厂方法模式的意义是啥呢？我的理解是 ：实际工作中，工厂类 不只是简单的new ConcreteProduct(), 同时还做一些初始化操作，比如处理前置依赖等。把这些封装在工厂类内，使得代码封装程度更高。\n\n\n\n\n### 抽象工厂 \n\n\n为了更好的理解抽象工厂模式，先说两个概念：\n\n* 产品等级结构 ：产品等级结构即产品的`继承结构`，如一个抽象类是电视机，其子类有海尔电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。\n\n* 产品族 ：产品族是指由同一个工厂生产的，位于`不同产品等级结构`中的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中。\n\n当系统所提供的工厂所需生产的具体产品并不是一个简单的对象，而是`多个位于不同产品等级结构`中属于不同类型的具体产品时需要使用抽象工厂模式。\n\n\n\n#### 模式的结构\n\n* Factory-抽象工厂类\n    * 定义了一组用于创建一组产品的方法，每个方法对应一种产品。\n    \n* ConcreteFactory-具体工厂类\n    * 实现抽象工厂中定义的创建一组产品的方法，生产一组产品。一对多。\n\n* Product-抽象产品类\n    * 定义产品接口\n    \n* ConcreteProduct-具体产品类：它定义具体工厂生产的具体产品对象，实现抽象产品接口中声明的业务方法。  \n\n\n抽象工厂中声明了多个工厂方法，用于创建不同类型的产品。\n\n\n#### 实例分析       \n\n这里改造一下上面生产宝马汽车的例子。现在我们不是生产汽车了而是生产汽车配件。现需要两种汽车配件：汽车发动机，汽车空调。还是有两个宝马型号的汽车 BMW320、BMW523。\n\n产品类\n``` java\n    //发动机以及型号    \n    public interface Engine {    \n      \n    }    \n    public class EngineA extends Engine{    \n        public EngineA(){    \n            System.out.println(\"制造-->EngineA\");    \n        }    \n    }    \n    public class EngineBextends Engine{    \n        public EngineB(){    \n            System.out.println(\"制造-->EngineB\");    \n        }    \n    }    \n      \n    //空调以及型号    \n    public interface Aircondition {    \n      \n    }    \n    public class AirconditionA extends Aircondition{    \n        public AirconditionA(){    \n            System.out.println(\"制造-->AirconditionA\");    \n        }    \n    }    \n    public class AirconditionB extends Aircondition{    \n        public AirconditionB(){    \n            System.out.println(\"制造-->AirconditionB\");    \n        }    \n    }   \n```\n \n 创建工厂类\n \n``` java\n    //创建工厂的接口   \n    public interface AbstractFactory {    \n        //制造发动机  \n        public Engine createEngine();  \n        //制造空调   \n        public Aircondition createAircondition();   \n    } \n    \n    //为宝马320系列生产配件 \n    public class FactoryBMW320 implements AbstractFactory{    \n            \n        @Override    \n        public Engine createEngine() {      \n            return new EngineA();    \n        }    \n        @Override    \n        public Aircondition createAircondition() {    \n            return new AirconditionA();    \n        }    \n    }    \n    \n    //宝马523系列配件 \n    public class FactoryBMW523 implements AbstractFactory {    \n        \n         @Override    \n        public Engine createEngine() {      \n            return new EngineB();    \n        }    \n        @Override    \n        public Aircondition createAircondition() {    \n            return new AirconditionB();    \n        }    \n      \n      \n    }\n        \n    //客户端   \n    public class Customer {    \n        public static void main(String[] args){    \n            //生产宝马320系列配件  \n            FactoryBMW320 factoryBMW320 = new FactoryBMW320();    \n            factoryBMW320.createEngine();  \n            factoryBMW320.createAircondition();  \n                \n            //生产宝马523系列配件    \n            FactoryBMW523 factoryBMW523 = new FactoryBMW523();    \n            factoryBMW320.createEngine();  \n            factoryBMW320.createAircondition();  \n        }    \n    }     \n```\n    \n    \n    \n#### 模式分析\n\n##### 抽象工厂模式的优点    \n* 首先是该模式适应了某种业务场景\n* 符合“开闭原则”：增加新的具体工厂和产品族很方便，无须修改已有系统。\n \n##### 抽象工厂模式的缺点\n\n* 在添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其`所有子类的修改`，显然会带来较大的不便。\n* 开闭原则的倾斜性（增加新的工厂和产品族容易，`增加新的产品等级结构`麻烦）\n\n##### 抽象工厂模式的适用场景   \n\n* 当系统所提供的工厂所需生产的具体产品并不是一个简单的对象，而是`多个位于不同产品等级结构`中属于不同类型的具体产品时需要使用抽象工厂模式。\n\n* 一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是重要的。\n* 系统提供一个产品类的库，所有的 `产品以同样的接口`出现，从而使客户端不依赖于具体实现。\n     \n\n##### 与工厂方法的区别\n\n抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构，一个工厂等级结构可以负责多个不同产品等级结构中的产品对象的创建 。当一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象时，抽象工厂模式比工厂方法模式更为简单、有效率。\n\n\n### 工厂模式的退化\n\n* 当`抽象工厂模式`中每一个具体工厂类只创建一个产品对象，也就是只存在一个产品等级结构时，抽象工厂模式退化成`工厂方法模式`；\n* 当工厂方法模式中抽象工厂与具体工厂合并，提供一个统一的工厂来创建产品对象将创建对象的工厂方法设计为静态方法时，工厂方法模式退化成`简单工厂模式`。\n\n\n三个工厂模式 完。\n\n\nhttp://blog.csdn.net/jason0539/article/details/44956775\n\nhttps://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/creational.html\n\n\n    ","slug":"设计模式之工厂模式","published":1,"updated":"2018-03-10T16:05:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjelnshd2000l3gffrtq7g33a","content":"<h2 id=\"设计模式-创建型之工厂模式\"><a href=\"#设计模式-创建型之工厂模式\" class=\"headerlink\" title=\"设计模式-创建型之工厂模式\"></a>设计模式-创建型之工厂模式</h2><p>创建型设计模式共六种：</p>\n<ul>\n<li>简单工厂模式</li>\n<li>工厂方法模式</li>\n<li>抽象工厂模式</li>\n<li>建造者模式</li>\n<li>原型模式</li>\n<li>单例模式</li>\n</ul>\n<p>本篇讲三个工厂模式： 简单工厂、工厂方法、抽象工厂。</p>\n<a id=\"more\"></a>\n<p>创建型设计模式是用来创建对象的，在面向对象的编程中最常用的一种创建对象方式是用new操作符产生一个对象实例。<br>创建型模式对类的实例化过程进行了抽象，能够将对象的创建与对象的使用过程分离。</p>\n<h3 id=\"简单工厂模式\"><a href=\"#简单工厂模式\" class=\"headerlink\" title=\"简单工厂模式\"></a>简单工厂模式</h3><h4 id=\"模式定义\"><a href=\"#模式定义\" class=\"headerlink\" title=\"模式定义\"></a>模式定义</h4><p>简单工厂模式：又称静态工厂模式。在该模式中可以通过参数的不同返回不同的实例。简单工厂模式专门定义一个类来负责创建其他类的实例。被创建的实例通常都具有共同的分类。</p>\n<h4 id=\"模式的结构\"><a href=\"#模式的结构\" class=\"headerlink\" title=\"模式的结构\"></a>模式的结构</h4><ul>\n<li>Factory-工厂角色： 负责实现创建所有实例的内部逻辑。</li>\n<li>Product-抽象产品角色： 创建的所有对象的父类，负责描述所有实例所共有的公共接口。</li>\n<li>ConcreteProduct-具体产品角色：创建的目标，所有创建的对象都充当这个角色的某个具体类的实例。</li>\n</ul>\n<p>当然，实际应用中可能没有这么严格的三个角色。但 <code>Factory</code>和 <code>ConcreteProduct</code>是必须的。 <br></p>\n<p>简单工厂的核心定义是：有一个工厂方法（也可以是工厂类）根据接收的参数 实例化具体的类，并且返回这个类的实例。</p>\n<h4 id=\"实例分析\"><a href=\"#实例分析\" class=\"headerlink\" title=\"实例分析\"></a>实例分析</h4><p>这里用一个生产宝马汽车的例子。现在有两个型号的宝马车：BMW320和BMW523。<br>假设此时没有宝马工厂。用户需要这个这两个型号的车的时候需要 自己去制造生产。代码如下：</p>\n<p>没有工厂的时候：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BMW320</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">public</span> BMW320 &#123;</div><div class=\"line\">        System.out.println(<span class=\"string\">'生产320型号的宝马车'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BMW523</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">public</span> BMW523 &#123;</div><div class=\"line\">        System.out.println(<span class=\"string\">'生产320型号的宝马车'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Customer</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">        BMW320 bmw320 = <span class=\"keyword\">new</span> BMW320();</div><div class=\"line\">        BMW523 bmw523 = <span class=\"keyword\">new</span> BMW523();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样客户也造出了汽车，似乎也没啥毛病。问题在于：客户需要知道怎么去创建一款车（具体new 哪个类） 这样客户和车是耦合在一起的。但车型有很多的时候，客户就需要知道每一个型号的车对应哪个类。为了解耦，我们引入简单那工厂模式  ：创建一个工厂，将创建具体那个型号的宝马车的操作细节放到工厂里，客户直接使用工厂的创建产品的方法，传入具体的型号就好了。</p>\n<p>  有了简单工厂：</p>\n<p>  产品类<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BMW</span>  </span>&#123;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BMW320</span> <span class=\"keyword\">extends</span> <span class=\"title\">BMW</span> </span>&#123; </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BMW320</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">    System.out.println(<span class=\"string\">\"制造--&gt;BMW320\"</span>);  </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BMW523</span> <span class=\"keyword\">extends</span> <span class=\"title\">BMW</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BMW523</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"制造--&gt;BMW523\"</span>);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>工厂类 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BMWFactory</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> BMW <span class=\"title\">createBMW</span> <span class=\"params\">(<span class=\"keyword\">int</span> type)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">switch</span> (type) &#123;</div><div class=\"line\">        </div><div class=\"line\">         <span class=\"keyword\">case</span>:  <span class=\"number\">320</span> </div><div class=\"line\">             <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> BMW320();</div><div class=\"line\">             </div><div class=\"line\">         <span class=\"keyword\">case</span>: <span class=\"number\">523</span></div><div class=\"line\">             <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> BMW523();</div><div class=\"line\">             </div><div class=\"line\">         <span class=\"keyword\">default</span>:</div><div class=\"line\">             <span class=\"keyword\">break</span>;  </div><div class=\"line\">                 </div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>客户类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Customer</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(Sting[] args)</span> </span>&#123;</div><div class=\"line\">        BMWFactory  factory = <span class=\"keyword\">new</span> BMWFactory();</div><div class=\"line\">        BMW bmw320 = factory.createBMW(<span class=\"number\">320</span>);</div><div class=\"line\">        BMW bmw523 = factory.createBMW(<span class=\"number\">523</span>); </div><div class=\"line\">    &#125;   </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到 具体实例化某一个class 的操作放到了工厂类里，客户只需要调用工厂方法并传参就OK了。</p>\n<h4 id=\"模式分析\"><a href=\"#模式分析\" class=\"headerlink\" title=\"模式分析\"></a>模式分析</h4><h5 id=\"简单工厂的优点：\"><a href=\"#简单工厂的优点：\" class=\"headerlink\" title=\"简单工厂的优点：\"></a>简单工厂的优点：</h5><ul>\n<li>客户端更方便了：无需记忆众多复杂的类名，只需要知道具体产品类所对应的参数。</li>\n<li>责任分割： 创建产品的逻辑都放在工厂，客户端仅仅是消费产品，从而免去了直接创建产品对象的责任。</li>\n</ul>\n<h5 id=\"简单工厂的缺点：\"><a href=\"#简单工厂的缺点：\" class=\"headerlink\" title=\"简单工厂的缺点：\"></a>简单工厂的缺点：</h5><ul>\n<li>违背开闭原则的 对修改关闭。当需要新增加一类产品的时候，除了增加创建该类产品的代码外还需要修改工厂类。</li>\n</ul>\n<h5 id=\"简单工厂适用场景\"><a href=\"#简单工厂适用场景\" class=\"headerlink\" title=\"简单工厂适用场景\"></a>简单工厂适用场景</h5><ul>\n<li>工厂类负责创建的对象比较少：由于创建的对象少，不会造成工厂法法中的业务逻辑泰国复杂。</li>\n</ul>\n<h3 id=\"工厂方法\"><a href=\"#工厂方法\" class=\"headerlink\" title=\"工厂方法\"></a>工厂方法</h3><p>上面我们知道了，当产品种类多了后，工厂就会很庞大，且新增一类产品就要改工厂类。此时工厂方法模式就上场了。</p>\n<h4 id=\"模式定义-1\"><a href=\"#模式定义-1\" class=\"headerlink\" title=\"模式定义\"></a>模式定义</h4><p>在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将<code>产品类的实例化操作延迟到工厂子类</code>中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。</p>\n<h4 id=\"模式的结构-1\"><a href=\"#模式的结构-1\" class=\"headerlink\" title=\"模式的结构\"></a>模式的结构</h4><ul>\n<li>Factory-抽象工厂类：<ul>\n<li>声明了工厂方法(Factory Method)，用于返回一个产品。抽象工厂是工厂方法模式的核心，所有创建对象的工厂类都必须实现该接口。</li>\n</ul>\n</li>\n<li>ConcreteFactory-具体工厂类：<ul>\n<li>它实现了抽象产品接口，一类工厂生产一类产品。</li>\n</ul>\n</li>\n<li>Product-抽象产品类：<ul>\n<li>定义产品的接口。可以是抽象类或接口。</li>\n</ul>\n</li>\n<li>ConcreteProduct-具体产品类：<ul>\n<li>实现抽象产品类的接口，产品和工厂一一对相应。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"实例分析-1\"><a href=\"#实例分析-1\" class=\"headerlink\" title=\"实例分析\"></a>实例分析</h4><p>还是接着上边简单工厂造宝马车的例子。</p>\n<p>产品类，和简单工厂里一样<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BMW</span> </span>&#123;  </div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BMW</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">              </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BMW320</span> <span class=\"keyword\">extends</span> <span class=\"title\">BMW</span> </span>&#123;  </div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BMW320</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">            System.out.println(<span class=\"string\">\"制造--&gt;BMW320\"</span>);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BMW523</span> <span class=\"keyword\">extends</span> <span class=\"title\">BMW</span></span>&#123;  </div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BMW523</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">            System.out.println(<span class=\"string\">\"制造--&gt;BMW523\"</span>);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">```        </div><div class=\"line\"></div><div class=\"line\">工厂类： 抽象工厂类定义工厂类接口，工厂类创建具体的一类产品。</div><div class=\"line\"></div><div class=\"line\">``` java</div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">FactoryBMW</span> </span>&#123;  </div><div class=\"line\">        <span class=\"function\">BMW <span class=\"title\">createBMW</span><span class=\"params\">()</span></span>;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">      </div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FactoryBMW320</span> <span class=\"keyword\">implements</span> <span class=\"title\">FactoryBMW</span></span>&#123;  </div><div class=\"line\">      </div><div class=\"line\">        <span class=\"meta\">@Override</span>  </div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> BMW320 <span class=\"title\">createBMW</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">      </div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> BMW320();  </div><div class=\"line\">        &#125;  </div><div class=\"line\">      </div><div class=\"line\">    &#125;  </div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FactoryBMW523</span> <span class=\"keyword\">implements</span> <span class=\"title\">FactoryBMW</span> </span>&#123;  </div><div class=\"line\">        <span class=\"meta\">@Override</span>  </div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> BMW523 <span class=\"title\">createBMW</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">      </div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> BMW523();  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>客户类：客户生产某类产品 直接实例化具体的工厂。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Customer</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </div><div class=\"line\">        FactoryBMW320 factoryBMW320 = <span class=\"keyword\">new</span> FactoryBMW320();  <span class=\"comment\">//可通过配置文件实现 </span></div><div class=\"line\">        BMW320 bmw320 = factoryBMW320.createBMW();  </div><div class=\"line\">  </div><div class=\"line\">        FactoryBMW523 factoryBMW523 = <span class=\"keyword\">new</span> FactoryBMW523();  </div><div class=\"line\">        BMW523 bmw523 = factoryBMW523.createBMW();  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"模式分析-1\"><a href=\"#模式分析-1\" class=\"headerlink\" title=\"模式分析\"></a>模式分析</h4><p>工厂方法模式是简单工厂模式的进一步抽象。由于使用了面向对象的多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。工厂方法模式可以允许在不修改工厂角色的情况下引进新产品。<br></p>\n<p>基于工厂角色和产品角色的<code>多态性</code>设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，是因为所有的具体工厂类都具有同一抽象父类。</p>\n<h5 id=\"工厂方法模式优点\"><a href=\"#工厂方法模式优点\" class=\"headerlink\" title=\"工厂方法模式优点\"></a>工厂方法模式优点</h5><ul>\n<li><code>符合开闭原则</code>（克服了简单工厂的缺点）。引入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。</li>\n</ul>\n<h5 id=\"工厂方法模式的缺点\"><a href=\"#工厂方法模式的缺点\" class=\"headerlink\" title=\"工厂方法模式的缺点\"></a>工厂方法模式的缺点</h5><ul>\n<li>系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。</li>\n</ul>\n<h5 id=\"工厂方法模式的适用场景\"><a href=\"#工厂方法模式的适用场景\" class=\"headerlink\" title=\"工厂方法模式的适用场景\"></a>工厂方法模式的适用场景</h5><ul>\n<li>当需要的产品种类多变，系统需要有比较好的扩展性时，可以考虑工厂模式，不同的产品用不同的实现工厂来组装。</li>\n</ul>\n<h5 id=\"工厂方法模式疑问\"><a href=\"#工厂方法模式疑问\" class=\"headerlink\" title=\"工厂方法模式疑问\"></a>工厂方法模式疑问</h5><p>到这里我是有点疑问的：工厂方法模式中，客户端就得知道生产某类产品对应的工厂类，当产品种类多的时候，那不就面临没有任何工厂模式时同样的问题？<br>这个问题可以通过配置文件解决。通过配置文件来存储具体工厂类ConcreteFactory的类名，更换新的具体工厂时无须修改源代码，系统扩展更为方便。</p>\n<p>那么问题又来了：那我不用工厂方法模式，我生产具体的产品（new ConcreteProduct）时，也通过配置文件来存储产品类的类名，那不就不需要工厂类了吗？ 那工厂方法模式的意义是啥呢？我的理解是 ：实际工作中，工厂类 不只是简单的new ConcreteProduct(), 同时还做一些初始化操作，比如处理前置依赖等。把这些封装在工厂类内，使得代码封装程度更高。</p>\n<h3 id=\"抽象工厂\"><a href=\"#抽象工厂\" class=\"headerlink\" title=\"抽象工厂\"></a>抽象工厂</h3><p>为了更好的理解抽象工厂模式，先说两个概念：</p>\n<ul>\n<li><p>产品等级结构 ：产品等级结构即产品的<code>继承结构</code>，如一个抽象类是电视机，其子类有海尔电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。</p>\n</li>\n<li><p>产品族 ：产品族是指由同一个工厂生产的，位于<code>不同产品等级结构</code>中的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中。</p>\n</li>\n</ul>\n<p>当系统所提供的工厂所需生产的具体产品并不是一个简单的对象，而是<code>多个位于不同产品等级结构</code>中属于不同类型的具体产品时需要使用抽象工厂模式。</p>\n<h4 id=\"模式的结构-2\"><a href=\"#模式的结构-2\" class=\"headerlink\" title=\"模式的结构\"></a>模式的结构</h4><ul>\n<li><p>Factory-抽象工厂类</p>\n<ul>\n<li>定义了一组用于创建一组产品的方法，每个方法对应一种产品。</li>\n</ul>\n</li>\n<li><p>ConcreteFactory-具体工厂类</p>\n<ul>\n<li>实现抽象工厂中定义的创建一组产品的方法，生产一组产品。一对多。</li>\n</ul>\n</li>\n<li><p>Product-抽象产品类</p>\n<ul>\n<li>定义产品接口</li>\n</ul>\n</li>\n<li><p>ConcreteProduct-具体产品类：它定义具体工厂生产的具体产品对象，实现抽象产品接口中声明的业务方法。  </p>\n</li>\n</ul>\n<p>抽象工厂中声明了多个工厂方法，用于创建不同类型的产品。</p>\n<h4 id=\"实例分析-2\"><a href=\"#实例分析-2\" class=\"headerlink\" title=\"实例分析\"></a>实例分析</h4><p>这里改造一下上面生产宝马汽车的例子。现在我们不是生产汽车了而是生产汽车配件。现需要两种汽车配件：汽车发动机，汽车空调。还是有两个宝马型号的汽车 BMW320、BMW523。</p>\n<p>产品类<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//发动机以及型号    </span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Engine</span> </span>&#123;    </div><div class=\"line\">  </div><div class=\"line\">&#125;    </div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EngineA</span> <span class=\"keyword\">extends</span> <span class=\"title\">Engine</span></span>&#123;    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">EngineA</span><span class=\"params\">()</span></span>&#123;    </div><div class=\"line\">        System.out.println(<span class=\"string\">\"制造--&gt;EngineA\"</span>);    </div><div class=\"line\">    &#125;    </div><div class=\"line\">&#125;    </div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EngineBextends</span> <span class=\"title\">Engine</span></span>&#123;    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">EngineB</span><span class=\"params\">()</span></span>&#123;    </div><div class=\"line\">        System.out.println(<span class=\"string\">\"制造--&gt;EngineB\"</span>);    </div><div class=\"line\">    &#125;    </div><div class=\"line\">&#125;    </div><div class=\"line\">  </div><div class=\"line\"><span class=\"comment\">//空调以及型号    </span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Aircondition</span> </span>&#123;    </div><div class=\"line\">  </div><div class=\"line\">&#125;    </div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AirconditionA</span> <span class=\"keyword\">extends</span> <span class=\"title\">Aircondition</span></span>&#123;    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AirconditionA</span><span class=\"params\">()</span></span>&#123;    </div><div class=\"line\">        System.out.println(<span class=\"string\">\"制造--&gt;AirconditionA\"</span>);    </div><div class=\"line\">    &#125;    </div><div class=\"line\">&#125;    </div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AirconditionB</span> <span class=\"keyword\">extends</span> <span class=\"title\">Aircondition</span></span>&#123;    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AirconditionB</span><span class=\"params\">()</span></span>&#123;    </div><div class=\"line\">        System.out.println(<span class=\"string\">\"制造--&gt;AirconditionB\"</span>);    </div><div class=\"line\">    &#125;    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p> 创建工厂类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//创建工厂的接口   </span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">AbstractFactory</span> </span>&#123;    </div><div class=\"line\">    <span class=\"comment\">//制造发动机  </span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Engine <span class=\"title\">createEngine</span><span class=\"params\">()</span></span>;  </div><div class=\"line\">    <span class=\"comment\">//制造空调   </span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Aircondition <span class=\"title\">createAircondition</span><span class=\"params\">()</span></span>;   </div><div class=\"line\">&#125; </div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//为宝马320系列生产配件 </span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FactoryBMW320</span> <span class=\"keyword\">implements</span> <span class=\"title\">AbstractFactory</span></span>&#123;    </div><div class=\"line\">        </div><div class=\"line\">    <span class=\"meta\">@Override</span>    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Engine <span class=\"title\">createEngine</span><span class=\"params\">()</span> </span>&#123;      </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> EngineA();    </div><div class=\"line\">    &#125;    </div><div class=\"line\">    <span class=\"meta\">@Override</span>    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Aircondition <span class=\"title\">createAircondition</span><span class=\"params\">()</span> </span>&#123;    </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> AirconditionA();    </div><div class=\"line\">    &#125;    </div><div class=\"line\">&#125;    </div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//宝马523系列配件 </span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FactoryBMW523</span> <span class=\"keyword\">implements</span> <span class=\"title\">AbstractFactory</span> </span>&#123;    </div><div class=\"line\">    </div><div class=\"line\">     <span class=\"meta\">@Override</span>    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Engine <span class=\"title\">createEngine</span><span class=\"params\">()</span> </span>&#123;      </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> EngineB();    </div><div class=\"line\">    &#125;    </div><div class=\"line\">    <span class=\"meta\">@Override</span>    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Aircondition <span class=\"title\">createAircondition</span><span class=\"params\">()</span> </span>&#123;    </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> AirconditionB();    </div><div class=\"line\">    &#125;    </div><div class=\"line\">  </div><div class=\"line\">  </div><div class=\"line\">&#125;</div><div class=\"line\">    </div><div class=\"line\"><span class=\"comment\">//客户端   </span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Customer</span> </span>&#123;    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;    </div><div class=\"line\">        <span class=\"comment\">//生产宝马320系列配件  </span></div><div class=\"line\">        FactoryBMW320 factoryBMW320 = <span class=\"keyword\">new</span> FactoryBMW320();    </div><div class=\"line\">        factoryBMW320.createEngine();  </div><div class=\"line\">        factoryBMW320.createAircondition();  </div><div class=\"line\">            </div><div class=\"line\">        <span class=\"comment\">//生产宝马523系列配件    </span></div><div class=\"line\">        FactoryBMW523 factoryBMW523 = <span class=\"keyword\">new</span> FactoryBMW523();    </div><div class=\"line\">        factoryBMW320.createEngine();  </div><div class=\"line\">        factoryBMW320.createAircondition();  </div><div class=\"line\">    &#125;    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"模式分析-2\"><a href=\"#模式分析-2\" class=\"headerlink\" title=\"模式分析\"></a>模式分析</h4><h5 id=\"抽象工厂模式的优点\"><a href=\"#抽象工厂模式的优点\" class=\"headerlink\" title=\"抽象工厂模式的优点\"></a>抽象工厂模式的优点</h5><ul>\n<li>首先是该模式适应了某种业务场景</li>\n<li>符合“开闭原则”：增加新的具体工厂和产品族很方便，无须修改已有系统。</li>\n</ul>\n<h5 id=\"抽象工厂模式的缺点\"><a href=\"#抽象工厂模式的缺点\" class=\"headerlink\" title=\"抽象工厂模式的缺点\"></a>抽象工厂模式的缺点</h5><ul>\n<li>在添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其<code>所有子类的修改</code>，显然会带来较大的不便。</li>\n<li>开闭原则的倾斜性（增加新的工厂和产品族容易，<code>增加新的产品等级结构</code>麻烦）</li>\n</ul>\n<h5 id=\"抽象工厂模式的适用场景\"><a href=\"#抽象工厂模式的适用场景\" class=\"headerlink\" title=\"抽象工厂模式的适用场景\"></a>抽象工厂模式的适用场景</h5><ul>\n<li><p>当系统所提供的工厂所需生产的具体产品并不是一个简单的对象，而是<code>多个位于不同产品等级结构</code>中属于不同类型的具体产品时需要使用抽象工厂模式。</p>\n</li>\n<li><p>一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是重要的。</p>\n</li>\n<li>系统提供一个产品类的库，所有的 <code>产品以同样的接口</code>出现，从而使客户端不依赖于具体实现。</li>\n</ul>\n<h5 id=\"与工厂方法的区别\"><a href=\"#与工厂方法的区别\" class=\"headerlink\" title=\"与工厂方法的区别\"></a>与工厂方法的区别</h5><p>抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构，一个工厂等级结构可以负责多个不同产品等级结构中的产品对象的创建 。当一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象时，抽象工厂模式比工厂方法模式更为简单、有效率。</p>\n<h3 id=\"工厂模式的退化\"><a href=\"#工厂模式的退化\" class=\"headerlink\" title=\"工厂模式的退化\"></a>工厂模式的退化</h3><ul>\n<li>当<code>抽象工厂模式</code>中每一个具体工厂类只创建一个产品对象，也就是只存在一个产品等级结构时，抽象工厂模式退化成<code>工厂方法模式</code>；</li>\n<li>当工厂方法模式中抽象工厂与具体工厂合并，提供一个统一的工厂来创建产品对象将创建对象的工厂方法设计为静态方法时，工厂方法模式退化成<code>简单工厂模式</code>。</li>\n</ul>\n<p>三个工厂模式 完。</p>\n<p><a href=\"http://blog.csdn.net/jason0539/article/details/44956775\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/jason0539/article/details/44956775</a></p>\n<p><a href=\"https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/creational.html\" target=\"_blank\" rel=\"external\">https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/creational.html</a></p>\n","excerpt":"<h2 id=\"设计模式-创建型之工厂模式\"><a href=\"#设计模式-创建型之工厂模式\" class=\"headerlink\" title=\"设计模式-创建型之工厂模式\"></a>设计模式-创建型之工厂模式</h2><p>创建型设计模式共六种：</p>\n<ul>\n<li>简单工厂模式</li>\n<li>工厂方法模式</li>\n<li>抽象工厂模式</li>\n<li>建造者模式</li>\n<li>原型模式</li>\n<li>单例模式</li>\n</ul>\n<p>本篇讲三个工厂模式： 简单工厂、工厂方法、抽象工厂。</p>","more":"<p>创建型设计模式是用来创建对象的，在面向对象的编程中最常用的一种创建对象方式是用new操作符产生一个对象实例。<br>创建型模式对类的实例化过程进行了抽象，能够将对象的创建与对象的使用过程分离。</p>\n<h3 id=\"简单工厂模式\"><a href=\"#简单工厂模式\" class=\"headerlink\" title=\"简单工厂模式\"></a>简单工厂模式</h3><h4 id=\"模式定义\"><a href=\"#模式定义\" class=\"headerlink\" title=\"模式定义\"></a>模式定义</h4><p>简单工厂模式：又称静态工厂模式。在该模式中可以通过参数的不同返回不同的实例。简单工厂模式专门定义一个类来负责创建其他类的实例。被创建的实例通常都具有共同的分类。</p>\n<h4 id=\"模式的结构\"><a href=\"#模式的结构\" class=\"headerlink\" title=\"模式的结构\"></a>模式的结构</h4><ul>\n<li>Factory-工厂角色： 负责实现创建所有实例的内部逻辑。</li>\n<li>Product-抽象产品角色： 创建的所有对象的父类，负责描述所有实例所共有的公共接口。</li>\n<li>ConcreteProduct-具体产品角色：创建的目标，所有创建的对象都充当这个角色的某个具体类的实例。</li>\n</ul>\n<p>当然，实际应用中可能没有这么严格的三个角色。但 <code>Factory</code>和 <code>ConcreteProduct</code>是必须的。 <br></p>\n<p>简单工厂的核心定义是：有一个工厂方法（也可以是工厂类）根据接收的参数 实例化具体的类，并且返回这个类的实例。</p>\n<h4 id=\"实例分析\"><a href=\"#实例分析\" class=\"headerlink\" title=\"实例分析\"></a>实例分析</h4><p>这里用一个生产宝马汽车的例子。现在有两个型号的宝马车：BMW320和BMW523。<br>假设此时没有宝马工厂。用户需要这个这两个型号的车的时候需要 自己去制造生产。代码如下：</p>\n<p>没有工厂的时候：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BMW320</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">public</span> BMW320 &#123;</div><div class=\"line\">        System.out.println(<span class=\"string\">'生产320型号的宝马车'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BMW523</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">public</span> BMW523 &#123;</div><div class=\"line\">        System.out.println(<span class=\"string\">'生产320型号的宝马车'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Customer</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">        BMW320 bmw320 = <span class=\"keyword\">new</span> BMW320();</div><div class=\"line\">        BMW523 bmw523 = <span class=\"keyword\">new</span> BMW523();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样客户也造出了汽车，似乎也没啥毛病。问题在于：客户需要知道怎么去创建一款车（具体new 哪个类） 这样客户和车是耦合在一起的。但车型有很多的时候，客户就需要知道每一个型号的车对应哪个类。为了解耦，我们引入简单那工厂模式  ：创建一个工厂，将创建具体那个型号的宝马车的操作细节放到工厂里，客户直接使用工厂的创建产品的方法，传入具体的型号就好了。</p>\n<p>  有了简单工厂：</p>\n<p>  产品类<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BMW</span>  </span>&#123;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BMW320</span> <span class=\"keyword\">extends</span> <span class=\"title\">BMW</span> </span>&#123; </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BMW320</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">    System.out.println(<span class=\"string\">\"制造--&gt;BMW320\"</span>);  </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BMW523</span> <span class=\"keyword\">extends</span> <span class=\"title\">BMW</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BMW523</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"制造--&gt;BMW523\"</span>);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>工厂类 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BMWFactory</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> BMW <span class=\"title\">createBMW</span> <span class=\"params\">(<span class=\"keyword\">int</span> type)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">switch</span> (type) &#123;</div><div class=\"line\">        </div><div class=\"line\">         <span class=\"keyword\">case</span>:  <span class=\"number\">320</span> </div><div class=\"line\">             <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> BMW320();</div><div class=\"line\">             </div><div class=\"line\">         <span class=\"keyword\">case</span>: <span class=\"number\">523</span></div><div class=\"line\">             <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> BMW523();</div><div class=\"line\">             </div><div class=\"line\">         <span class=\"keyword\">default</span>:</div><div class=\"line\">             <span class=\"keyword\">break</span>;  </div><div class=\"line\">                 </div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>客户类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Customer</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(Sting[] args)</span> </span>&#123;</div><div class=\"line\">        BMWFactory  factory = <span class=\"keyword\">new</span> BMWFactory();</div><div class=\"line\">        BMW bmw320 = factory.createBMW(<span class=\"number\">320</span>);</div><div class=\"line\">        BMW bmw523 = factory.createBMW(<span class=\"number\">523</span>); </div><div class=\"line\">    &#125;   </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到 具体实例化某一个class 的操作放到了工厂类里，客户只需要调用工厂方法并传参就OK了。</p>\n<h4 id=\"模式分析\"><a href=\"#模式分析\" class=\"headerlink\" title=\"模式分析\"></a>模式分析</h4><h5 id=\"简单工厂的优点：\"><a href=\"#简单工厂的优点：\" class=\"headerlink\" title=\"简单工厂的优点：\"></a>简单工厂的优点：</h5><ul>\n<li>客户端更方便了：无需记忆众多复杂的类名，只需要知道具体产品类所对应的参数。</li>\n<li>责任分割： 创建产品的逻辑都放在工厂，客户端仅仅是消费产品，从而免去了直接创建产品对象的责任。</li>\n</ul>\n<h5 id=\"简单工厂的缺点：\"><a href=\"#简单工厂的缺点：\" class=\"headerlink\" title=\"简单工厂的缺点：\"></a>简单工厂的缺点：</h5><ul>\n<li>违背开闭原则的 对修改关闭。当需要新增加一类产品的时候，除了增加创建该类产品的代码外还需要修改工厂类。</li>\n</ul>\n<h5 id=\"简单工厂适用场景\"><a href=\"#简单工厂适用场景\" class=\"headerlink\" title=\"简单工厂适用场景\"></a>简单工厂适用场景</h5><ul>\n<li>工厂类负责创建的对象比较少：由于创建的对象少，不会造成工厂法法中的业务逻辑泰国复杂。</li>\n</ul>\n<h3 id=\"工厂方法\"><a href=\"#工厂方法\" class=\"headerlink\" title=\"工厂方法\"></a>工厂方法</h3><p>上面我们知道了，当产品种类多了后，工厂就会很庞大，且新增一类产品就要改工厂类。此时工厂方法模式就上场了。</p>\n<h4 id=\"模式定义-1\"><a href=\"#模式定义-1\" class=\"headerlink\" title=\"模式定义\"></a>模式定义</h4><p>在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将<code>产品类的实例化操作延迟到工厂子类</code>中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。</p>\n<h4 id=\"模式的结构-1\"><a href=\"#模式的结构-1\" class=\"headerlink\" title=\"模式的结构\"></a>模式的结构</h4><ul>\n<li>Factory-抽象工厂类：<ul>\n<li>声明了工厂方法(Factory Method)，用于返回一个产品。抽象工厂是工厂方法模式的核心，所有创建对象的工厂类都必须实现该接口。</li>\n</ul>\n</li>\n<li>ConcreteFactory-具体工厂类：<ul>\n<li>它实现了抽象产品接口，一类工厂生产一类产品。</li>\n</ul>\n</li>\n<li>Product-抽象产品类：<ul>\n<li>定义产品的接口。可以是抽象类或接口。</li>\n</ul>\n</li>\n<li>ConcreteProduct-具体产品类：<ul>\n<li>实现抽象产品类的接口，产品和工厂一一对相应。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"实例分析-1\"><a href=\"#实例分析-1\" class=\"headerlink\" title=\"实例分析\"></a>实例分析</h4><p>还是接着上边简单工厂造宝马车的例子。</p>\n<p>产品类，和简单工厂里一样<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BMW</span> </span>&#123;  </div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BMW</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">              </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BMW320</span> <span class=\"keyword\">extends</span> <span class=\"title\">BMW</span> </span>&#123;  </div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BMW320</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">            System.out.println(<span class=\"string\">\"制造--&gt;BMW320\"</span>);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BMW523</span> <span class=\"keyword\">extends</span> <span class=\"title\">BMW</span></span>&#123;  </div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BMW523</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">            System.out.println(<span class=\"string\">\"制造--&gt;BMW523\"</span>);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">```        </div><div class=\"line\"></div><div class=\"line\">工厂类： 抽象工厂类定义工厂类接口，工厂类创建具体的一类产品。</div><div class=\"line\"></div><div class=\"line\">``` java</div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">FactoryBMW</span> </span>&#123;  </div><div class=\"line\">        <span class=\"function\">BMW <span class=\"title\">createBMW</span><span class=\"params\">()</span></span>;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">      </div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FactoryBMW320</span> <span class=\"keyword\">implements</span> <span class=\"title\">FactoryBMW</span></span>&#123;  </div><div class=\"line\">      </div><div class=\"line\">        <span class=\"meta\">@Override</span>  </div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> BMW320 <span class=\"title\">createBMW</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">      </div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> BMW320();  </div><div class=\"line\">        &#125;  </div><div class=\"line\">      </div><div class=\"line\">    &#125;  </div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FactoryBMW523</span> <span class=\"keyword\">implements</span> <span class=\"title\">FactoryBMW</span> </span>&#123;  </div><div class=\"line\">        <span class=\"meta\">@Override</span>  </div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> BMW523 <span class=\"title\">createBMW</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">      </div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> BMW523();  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>客户类：客户生产某类产品 直接实例化具体的工厂。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Customer</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </div><div class=\"line\">        FactoryBMW320 factoryBMW320 = <span class=\"keyword\">new</span> FactoryBMW320();  <span class=\"comment\">//可通过配置文件实现 </span></div><div class=\"line\">        BMW320 bmw320 = factoryBMW320.createBMW();  </div><div class=\"line\">  </div><div class=\"line\">        FactoryBMW523 factoryBMW523 = <span class=\"keyword\">new</span> FactoryBMW523();  </div><div class=\"line\">        BMW523 bmw523 = factoryBMW523.createBMW();  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"模式分析-1\"><a href=\"#模式分析-1\" class=\"headerlink\" title=\"模式分析\"></a>模式分析</h4><p>工厂方法模式是简单工厂模式的进一步抽象。由于使用了面向对象的多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。工厂方法模式可以允许在不修改工厂角色的情况下引进新产品。<br></p>\n<p>基于工厂角色和产品角色的<code>多态性</code>设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，是因为所有的具体工厂类都具有同一抽象父类。</p>\n<h5 id=\"工厂方法模式优点\"><a href=\"#工厂方法模式优点\" class=\"headerlink\" title=\"工厂方法模式优点\"></a>工厂方法模式优点</h5><ul>\n<li><code>符合开闭原则</code>（克服了简单工厂的缺点）。引入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。</li>\n</ul>\n<h5 id=\"工厂方法模式的缺点\"><a href=\"#工厂方法模式的缺点\" class=\"headerlink\" title=\"工厂方法模式的缺点\"></a>工厂方法模式的缺点</h5><ul>\n<li>系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。</li>\n</ul>\n<h5 id=\"工厂方法模式的适用场景\"><a href=\"#工厂方法模式的适用场景\" class=\"headerlink\" title=\"工厂方法模式的适用场景\"></a>工厂方法模式的适用场景</h5><ul>\n<li>当需要的产品种类多变，系统需要有比较好的扩展性时，可以考虑工厂模式，不同的产品用不同的实现工厂来组装。</li>\n</ul>\n<h5 id=\"工厂方法模式疑问\"><a href=\"#工厂方法模式疑问\" class=\"headerlink\" title=\"工厂方法模式疑问\"></a>工厂方法模式疑问</h5><p>到这里我是有点疑问的：工厂方法模式中，客户端就得知道生产某类产品对应的工厂类，当产品种类多的时候，那不就面临没有任何工厂模式时同样的问题？<br>这个问题可以通过配置文件解决。通过配置文件来存储具体工厂类ConcreteFactory的类名，更换新的具体工厂时无须修改源代码，系统扩展更为方便。</p>\n<p>那么问题又来了：那我不用工厂方法模式，我生产具体的产品（new ConcreteProduct）时，也通过配置文件来存储产品类的类名，那不就不需要工厂类了吗？ 那工厂方法模式的意义是啥呢？我的理解是 ：实际工作中，工厂类 不只是简单的new ConcreteProduct(), 同时还做一些初始化操作，比如处理前置依赖等。把这些封装在工厂类内，使得代码封装程度更高。</p>\n<h3 id=\"抽象工厂\"><a href=\"#抽象工厂\" class=\"headerlink\" title=\"抽象工厂\"></a>抽象工厂</h3><p>为了更好的理解抽象工厂模式，先说两个概念：</p>\n<ul>\n<li><p>产品等级结构 ：产品等级结构即产品的<code>继承结构</code>，如一个抽象类是电视机，其子类有海尔电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。</p>\n</li>\n<li><p>产品族 ：产品族是指由同一个工厂生产的，位于<code>不同产品等级结构</code>中的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中。</p>\n</li>\n</ul>\n<p>当系统所提供的工厂所需生产的具体产品并不是一个简单的对象，而是<code>多个位于不同产品等级结构</code>中属于不同类型的具体产品时需要使用抽象工厂模式。</p>\n<h4 id=\"模式的结构-2\"><a href=\"#模式的结构-2\" class=\"headerlink\" title=\"模式的结构\"></a>模式的结构</h4><ul>\n<li><p>Factory-抽象工厂类</p>\n<ul>\n<li>定义了一组用于创建一组产品的方法，每个方法对应一种产品。</li>\n</ul>\n</li>\n<li><p>ConcreteFactory-具体工厂类</p>\n<ul>\n<li>实现抽象工厂中定义的创建一组产品的方法，生产一组产品。一对多。</li>\n</ul>\n</li>\n<li><p>Product-抽象产品类</p>\n<ul>\n<li>定义产品接口</li>\n</ul>\n</li>\n<li><p>ConcreteProduct-具体产品类：它定义具体工厂生产的具体产品对象，实现抽象产品接口中声明的业务方法。  </p>\n</li>\n</ul>\n<p>抽象工厂中声明了多个工厂方法，用于创建不同类型的产品。</p>\n<h4 id=\"实例分析-2\"><a href=\"#实例分析-2\" class=\"headerlink\" title=\"实例分析\"></a>实例分析</h4><p>这里改造一下上面生产宝马汽车的例子。现在我们不是生产汽车了而是生产汽车配件。现需要两种汽车配件：汽车发动机，汽车空调。还是有两个宝马型号的汽车 BMW320、BMW523。</p>\n<p>产品类<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//发动机以及型号    </span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Engine</span> </span>&#123;    </div><div class=\"line\">  </div><div class=\"line\">&#125;    </div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EngineA</span> <span class=\"keyword\">extends</span> <span class=\"title\">Engine</span></span>&#123;    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">EngineA</span><span class=\"params\">()</span></span>&#123;    </div><div class=\"line\">        System.out.println(<span class=\"string\">\"制造--&gt;EngineA\"</span>);    </div><div class=\"line\">    &#125;    </div><div class=\"line\">&#125;    </div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EngineBextends</span> <span class=\"title\">Engine</span></span>&#123;    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">EngineB</span><span class=\"params\">()</span></span>&#123;    </div><div class=\"line\">        System.out.println(<span class=\"string\">\"制造--&gt;EngineB\"</span>);    </div><div class=\"line\">    &#125;    </div><div class=\"line\">&#125;    </div><div class=\"line\">  </div><div class=\"line\"><span class=\"comment\">//空调以及型号    </span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Aircondition</span> </span>&#123;    </div><div class=\"line\">  </div><div class=\"line\">&#125;    </div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AirconditionA</span> <span class=\"keyword\">extends</span> <span class=\"title\">Aircondition</span></span>&#123;    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AirconditionA</span><span class=\"params\">()</span></span>&#123;    </div><div class=\"line\">        System.out.println(<span class=\"string\">\"制造--&gt;AirconditionA\"</span>);    </div><div class=\"line\">    &#125;    </div><div class=\"line\">&#125;    </div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AirconditionB</span> <span class=\"keyword\">extends</span> <span class=\"title\">Aircondition</span></span>&#123;    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AirconditionB</span><span class=\"params\">()</span></span>&#123;    </div><div class=\"line\">        System.out.println(<span class=\"string\">\"制造--&gt;AirconditionB\"</span>);    </div><div class=\"line\">    &#125;    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p> 创建工厂类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//创建工厂的接口   </span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">AbstractFactory</span> </span>&#123;    </div><div class=\"line\">    <span class=\"comment\">//制造发动机  </span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Engine <span class=\"title\">createEngine</span><span class=\"params\">()</span></span>;  </div><div class=\"line\">    <span class=\"comment\">//制造空调   </span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Aircondition <span class=\"title\">createAircondition</span><span class=\"params\">()</span></span>;   </div><div class=\"line\">&#125; </div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//为宝马320系列生产配件 </span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FactoryBMW320</span> <span class=\"keyword\">implements</span> <span class=\"title\">AbstractFactory</span></span>&#123;    </div><div class=\"line\">        </div><div class=\"line\">    <span class=\"meta\">@Override</span>    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Engine <span class=\"title\">createEngine</span><span class=\"params\">()</span> </span>&#123;      </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> EngineA();    </div><div class=\"line\">    &#125;    </div><div class=\"line\">    <span class=\"meta\">@Override</span>    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Aircondition <span class=\"title\">createAircondition</span><span class=\"params\">()</span> </span>&#123;    </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> AirconditionA();    </div><div class=\"line\">    &#125;    </div><div class=\"line\">&#125;    </div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//宝马523系列配件 </span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FactoryBMW523</span> <span class=\"keyword\">implements</span> <span class=\"title\">AbstractFactory</span> </span>&#123;    </div><div class=\"line\">    </div><div class=\"line\">     <span class=\"meta\">@Override</span>    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Engine <span class=\"title\">createEngine</span><span class=\"params\">()</span> </span>&#123;      </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> EngineB();    </div><div class=\"line\">    &#125;    </div><div class=\"line\">    <span class=\"meta\">@Override</span>    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Aircondition <span class=\"title\">createAircondition</span><span class=\"params\">()</span> </span>&#123;    </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> AirconditionB();    </div><div class=\"line\">    &#125;    </div><div class=\"line\">  </div><div class=\"line\">  </div><div class=\"line\">&#125;</div><div class=\"line\">    </div><div class=\"line\"><span class=\"comment\">//客户端   </span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Customer</span> </span>&#123;    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;    </div><div class=\"line\">        <span class=\"comment\">//生产宝马320系列配件  </span></div><div class=\"line\">        FactoryBMW320 factoryBMW320 = <span class=\"keyword\">new</span> FactoryBMW320();    </div><div class=\"line\">        factoryBMW320.createEngine();  </div><div class=\"line\">        factoryBMW320.createAircondition();  </div><div class=\"line\">            </div><div class=\"line\">        <span class=\"comment\">//生产宝马523系列配件    </span></div><div class=\"line\">        FactoryBMW523 factoryBMW523 = <span class=\"keyword\">new</span> FactoryBMW523();    </div><div class=\"line\">        factoryBMW320.createEngine();  </div><div class=\"line\">        factoryBMW320.createAircondition();  </div><div class=\"line\">    &#125;    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"模式分析-2\"><a href=\"#模式分析-2\" class=\"headerlink\" title=\"模式分析\"></a>模式分析</h4><h5 id=\"抽象工厂模式的优点\"><a href=\"#抽象工厂模式的优点\" class=\"headerlink\" title=\"抽象工厂模式的优点\"></a>抽象工厂模式的优点</h5><ul>\n<li>首先是该模式适应了某种业务场景</li>\n<li>符合“开闭原则”：增加新的具体工厂和产品族很方便，无须修改已有系统。</li>\n</ul>\n<h5 id=\"抽象工厂模式的缺点\"><a href=\"#抽象工厂模式的缺点\" class=\"headerlink\" title=\"抽象工厂模式的缺点\"></a>抽象工厂模式的缺点</h5><ul>\n<li>在添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其<code>所有子类的修改</code>，显然会带来较大的不便。</li>\n<li>开闭原则的倾斜性（增加新的工厂和产品族容易，<code>增加新的产品等级结构</code>麻烦）</li>\n</ul>\n<h5 id=\"抽象工厂模式的适用场景\"><a href=\"#抽象工厂模式的适用场景\" class=\"headerlink\" title=\"抽象工厂模式的适用场景\"></a>抽象工厂模式的适用场景</h5><ul>\n<li><p>当系统所提供的工厂所需生产的具体产品并不是一个简单的对象，而是<code>多个位于不同产品等级结构</code>中属于不同类型的具体产品时需要使用抽象工厂模式。</p>\n</li>\n<li><p>一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是重要的。</p>\n</li>\n<li>系统提供一个产品类的库，所有的 <code>产品以同样的接口</code>出现，从而使客户端不依赖于具体实现。</li>\n</ul>\n<h5 id=\"与工厂方法的区别\"><a href=\"#与工厂方法的区别\" class=\"headerlink\" title=\"与工厂方法的区别\"></a>与工厂方法的区别</h5><p>抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构，一个工厂等级结构可以负责多个不同产品等级结构中的产品对象的创建 。当一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象时，抽象工厂模式比工厂方法模式更为简单、有效率。</p>\n<h3 id=\"工厂模式的退化\"><a href=\"#工厂模式的退化\" class=\"headerlink\" title=\"工厂模式的退化\"></a>工厂模式的退化</h3><ul>\n<li>当<code>抽象工厂模式</code>中每一个具体工厂类只创建一个产品对象，也就是只存在一个产品等级结构时，抽象工厂模式退化成<code>工厂方法模式</code>；</li>\n<li>当工厂方法模式中抽象工厂与具体工厂合并，提供一个统一的工厂来创建产品对象将创建对象的工厂方法设计为静态方法时，工厂方法模式退化成<code>简单工厂模式</code>。</li>\n</ul>\n<p>三个工厂模式 完。</p>\n<p><a href=\"http://blog.csdn.net/jason0539/article/details/44956775\">http://blog.csdn.net/jason0539/article/details/44956775</a></p>\n<p><a href=\"https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/creational.html\">https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/creational.html</a></p>"},{"title":"随笔：《王者荣耀》-论网游成瘾","date":"2017-07-16T16:34:35.000Z","_content":"## 随笔：游戏成瘾\n\n以前一直不明白那些网瘾少年为什么网络游戏如此痴迷。都是些虚虚假假的游戏，有什么好沉迷的。大概正是因为我没有深入玩过任何一款网络游戏所以才有这个疑惑。就好像一直不明白传销的那些人如何被洗脑的一样，怎么会那么啥？\n\n入手《王者荣耀》初衷是想探探网络游戏究竟是什么如此令人着迷。也断断续续的完了好长时间了。来做个记录吧。\n\n<!-- more -->\n\n#### 着迷的并不是游戏本身\n着迷的并不是游戏本身，而是游戏设计者在游戏中设计的很多\"陷阱\"。一下从简说下我的感受吧。这些陷阱包括：好胜心，贪婪，虚荣心...\n\n* 好胜心：我们在杀掉他人并取得胜利的时候会有爽快感觉。\n* 贪婪：我们在赢了之后还想再赢，再输了之后还想赢回来\n* 虚荣心：我们行不断提升段位，获得更多的MVP成就数据，因为这些能被游戏好友、微信好友看到。\n\n#### 吸引你的更多的是游戏本身之外的东西\n\n* 如果这个游戏没有了段位设定，还会有这么多人如此痴迷吗？\n* 如果这个游戏里不是基于微信或qq帐号体系的，甚至游戏里不能互相交流也永远不知道谁是谁 还会有这么多人如此痴迷？\n\n#### 网游的根本目标是盈利\n游戏策划者在游戏里设计那么多陷阱，最终是为了实现盈利的目标。首先要有人玩，有很多人玩，然后这其中有部分人愿意花钱买单就行了。\n举几个例子：\n##### 首冲\n游戏里首冲一般都有奖励，这个是先建立你的支付习惯。\n##### 抽奖概率\n每个玩家每个阶段中奖概率肯定不一样。通常前期中奖概率会高一点，好引诱你冲更多的值。后面会根据玩家的行为做概率调整，比如判定大拿玩家和普通玩家的概率，对不同阶段的概率都会有波动调整。最终为了让你花钱或化更多的钱来参与。\n\n##### 匹配机制\n这也是影响有游戏声明周期的关键环节。\n在保证游戏的平衡性大前提下，根据你的游戏记录适当倾斜下难易程度，比如当你连赢几把的时候，肯定就要给你匹配些强对手和弱队友了。让你不那么容易的升到顶级。实时证明王者荣耀这个匹配做的很极致。\n\n#### 社交属性\n当然网友还有一大属性是社交属性，先不说这点了...\n\n##### 等等吧\n不断增加英雄，赛季重置等 这都是延长游戏生命周期的又一手段。\n增加皮肤，抽奖等都是为了增加盈利...\n\n\n### 最初我们为什么玩游戏？\n这里不说职业玩家，就说普通玩家。本来我们玩游戏是为了放松，休闲。然而我发现每次我玩完都会很累。当我们得到的结果不符合我们的目标预期的时候，我们就要注意了，肯定有坑。\n然而游戏策划们就是利用人们的各种人性的弱点或者优点让你玩更久的游戏话更多的钱。而这一切都是你愿意的。\n\n### 结语\n没啥逻辑，想到啥就写了。总之手游大多是坑，他们都是为了赚钱。我已经不再主动玩这这个游戏了（好友邀请可以玩一把，这就是他的社交属性的体现了）。\n\n### 真正的结语\n再想想这些网友的沉迷，往往并不是对有游戏的热爱和痴迷，而是更多的是对自己的暂时性失控。玩玩单机游戏吧，坑少些。\n有个电影叫《爆裂鼓手》，其中男主的偏执最后算是一种痴迷吧。玩网友的沉迷算是一种痴迷吗？也算是吧，对职业玩家来说。也算是吧，只是并不是我们想要的。\n\n\n\n","source":"_posts/随笔：《王者荣耀》-论网游成瘾.md","raw":"---\ntitle: 随笔：《王者荣耀》-论网游成瘾\ndate: 2017-07-17 00:34:35\ntags: \n- 随笔 \n- 游戏\ncategories: \n- 随笔 \n---\n## 随笔：游戏成瘾\n\n以前一直不明白那些网瘾少年为什么网络游戏如此痴迷。都是些虚虚假假的游戏，有什么好沉迷的。大概正是因为我没有深入玩过任何一款网络游戏所以才有这个疑惑。就好像一直不明白传销的那些人如何被洗脑的一样，怎么会那么啥？\n\n入手《王者荣耀》初衷是想探探网络游戏究竟是什么如此令人着迷。也断断续续的完了好长时间了。来做个记录吧。\n\n<!-- more -->\n\n#### 着迷的并不是游戏本身\n着迷的并不是游戏本身，而是游戏设计者在游戏中设计的很多\"陷阱\"。一下从简说下我的感受吧。这些陷阱包括：好胜心，贪婪，虚荣心...\n\n* 好胜心：我们在杀掉他人并取得胜利的时候会有爽快感觉。\n* 贪婪：我们在赢了之后还想再赢，再输了之后还想赢回来\n* 虚荣心：我们行不断提升段位，获得更多的MVP成就数据，因为这些能被游戏好友、微信好友看到。\n\n#### 吸引你的更多的是游戏本身之外的东西\n\n* 如果这个游戏没有了段位设定，还会有这么多人如此痴迷吗？\n* 如果这个游戏里不是基于微信或qq帐号体系的，甚至游戏里不能互相交流也永远不知道谁是谁 还会有这么多人如此痴迷？\n\n#### 网游的根本目标是盈利\n游戏策划者在游戏里设计那么多陷阱，最终是为了实现盈利的目标。首先要有人玩，有很多人玩，然后这其中有部分人愿意花钱买单就行了。\n举几个例子：\n##### 首冲\n游戏里首冲一般都有奖励，这个是先建立你的支付习惯。\n##### 抽奖概率\n每个玩家每个阶段中奖概率肯定不一样。通常前期中奖概率会高一点，好引诱你冲更多的值。后面会根据玩家的行为做概率调整，比如判定大拿玩家和普通玩家的概率，对不同阶段的概率都会有波动调整。最终为了让你花钱或化更多的钱来参与。\n\n##### 匹配机制\n这也是影响有游戏声明周期的关键环节。\n在保证游戏的平衡性大前提下，根据你的游戏记录适当倾斜下难易程度，比如当你连赢几把的时候，肯定就要给你匹配些强对手和弱队友了。让你不那么容易的升到顶级。实时证明王者荣耀这个匹配做的很极致。\n\n#### 社交属性\n当然网友还有一大属性是社交属性，先不说这点了...\n\n##### 等等吧\n不断增加英雄，赛季重置等 这都是延长游戏生命周期的又一手段。\n增加皮肤，抽奖等都是为了增加盈利...\n\n\n### 最初我们为什么玩游戏？\n这里不说职业玩家，就说普通玩家。本来我们玩游戏是为了放松，休闲。然而我发现每次我玩完都会很累。当我们得到的结果不符合我们的目标预期的时候，我们就要注意了，肯定有坑。\n然而游戏策划们就是利用人们的各种人性的弱点或者优点让你玩更久的游戏话更多的钱。而这一切都是你愿意的。\n\n### 结语\n没啥逻辑，想到啥就写了。总之手游大多是坑，他们都是为了赚钱。我已经不再主动玩这这个游戏了（好友邀请可以玩一把，这就是他的社交属性的体现了）。\n\n### 真正的结语\n再想想这些网友的沉迷，往往并不是对有游戏的热爱和痴迷，而是更多的是对自己的暂时性失控。玩玩单机游戏吧，坑少些。\n有个电影叫《爆裂鼓手》，其中男主的偏执最后算是一种痴迷吧。玩网友的沉迷算是一种痴迷吗？也算是吧，对职业玩家来说。也算是吧，只是并不是我们想要的。\n\n\n\n","slug":"随笔：《王者荣耀》-论网游成瘾","published":1,"updated":"2018-03-10T16:05:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjelnshd4000n3gfflx777dyu","content":"<h2 id=\"随笔：游戏成瘾\"><a href=\"#随笔：游戏成瘾\" class=\"headerlink\" title=\"随笔：游戏成瘾\"></a>随笔：游戏成瘾</h2><p>以前一直不明白那些网瘾少年为什么网络游戏如此痴迷。都是些虚虚假假的游戏，有什么好沉迷的。大概正是因为我没有深入玩过任何一款网络游戏所以才有这个疑惑。就好像一直不明白传销的那些人如何被洗脑的一样，怎么会那么啥？</p>\n<p>入手《王者荣耀》初衷是想探探网络游戏究竟是什么如此令人着迷。也断断续续的完了好长时间了。来做个记录吧。</p>\n<a id=\"more\"></a>\n<h4 id=\"着迷的并不是游戏本身\"><a href=\"#着迷的并不是游戏本身\" class=\"headerlink\" title=\"着迷的并不是游戏本身\"></a>着迷的并不是游戏本身</h4><p>着迷的并不是游戏本身，而是游戏设计者在游戏中设计的很多”陷阱”。一下从简说下我的感受吧。这些陷阱包括：好胜心，贪婪，虚荣心…</p>\n<ul>\n<li>好胜心：我们在杀掉他人并取得胜利的时候会有爽快感觉。</li>\n<li>贪婪：我们在赢了之后还想再赢，再输了之后还想赢回来</li>\n<li>虚荣心：我们行不断提升段位，获得更多的MVP成就数据，因为这些能被游戏好友、微信好友看到。</li>\n</ul>\n<h4 id=\"吸引你的更多的是游戏本身之外的东西\"><a href=\"#吸引你的更多的是游戏本身之外的东西\" class=\"headerlink\" title=\"吸引你的更多的是游戏本身之外的东西\"></a>吸引你的更多的是游戏本身之外的东西</h4><ul>\n<li>如果这个游戏没有了段位设定，还会有这么多人如此痴迷吗？</li>\n<li>如果这个游戏里不是基于微信或qq帐号体系的，甚至游戏里不能互相交流也永远不知道谁是谁 还会有这么多人如此痴迷？</li>\n</ul>\n<h4 id=\"网游的根本目标是盈利\"><a href=\"#网游的根本目标是盈利\" class=\"headerlink\" title=\"网游的根本目标是盈利\"></a>网游的根本目标是盈利</h4><p>游戏策划者在游戏里设计那么多陷阱，最终是为了实现盈利的目标。首先要有人玩，有很多人玩，然后这其中有部分人愿意花钱买单就行了。<br>举几个例子：</p>\n<h5 id=\"首冲\"><a href=\"#首冲\" class=\"headerlink\" title=\"首冲\"></a>首冲</h5><p>游戏里首冲一般都有奖励，这个是先建立你的支付习惯。</p>\n<h5 id=\"抽奖概率\"><a href=\"#抽奖概率\" class=\"headerlink\" title=\"抽奖概率\"></a>抽奖概率</h5><p>每个玩家每个阶段中奖概率肯定不一样。通常前期中奖概率会高一点，好引诱你冲更多的值。后面会根据玩家的行为做概率调整，比如判定大拿玩家和普通玩家的概率，对不同阶段的概率都会有波动调整。最终为了让你花钱或化更多的钱来参与。</p>\n<h5 id=\"匹配机制\"><a href=\"#匹配机制\" class=\"headerlink\" title=\"匹配机制\"></a>匹配机制</h5><p>这也是影响有游戏声明周期的关键环节。<br>在保证游戏的平衡性大前提下，根据你的游戏记录适当倾斜下难易程度，比如当你连赢几把的时候，肯定就要给你匹配些强对手和弱队友了。让你不那么容易的升到顶级。实时证明王者荣耀这个匹配做的很极致。</p>\n<h4 id=\"社交属性\"><a href=\"#社交属性\" class=\"headerlink\" title=\"社交属性\"></a>社交属性</h4><p>当然网友还有一大属性是社交属性，先不说这点了…</p>\n<h5 id=\"等等吧\"><a href=\"#等等吧\" class=\"headerlink\" title=\"等等吧\"></a>等等吧</h5><p>不断增加英雄，赛季重置等 这都是延长游戏生命周期的又一手段。<br>增加皮肤，抽奖等都是为了增加盈利…</p>\n<h3 id=\"最初我们为什么玩游戏？\"><a href=\"#最初我们为什么玩游戏？\" class=\"headerlink\" title=\"最初我们为什么玩游戏？\"></a>最初我们为什么玩游戏？</h3><p>这里不说职业玩家，就说普通玩家。本来我们玩游戏是为了放松，休闲。然而我发现每次我玩完都会很累。当我们得到的结果不符合我们的目标预期的时候，我们就要注意了，肯定有坑。<br>然而游戏策划们就是利用人们的各种人性的弱点或者优点让你玩更久的游戏话更多的钱。而这一切都是你愿意的。</p>\n<h3 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h3><p>没啥逻辑，想到啥就写了。总之手游大多是坑，他们都是为了赚钱。我已经不再主动玩这这个游戏了（好友邀请可以玩一把，这就是他的社交属性的体现了）。</p>\n<h3 id=\"真正的结语\"><a href=\"#真正的结语\" class=\"headerlink\" title=\"真正的结语\"></a>真正的结语</h3><p>再想想这些网友的沉迷，往往并不是对有游戏的热爱和痴迷，而是更多的是对自己的暂时性失控。玩玩单机游戏吧，坑少些。<br>有个电影叫《爆裂鼓手》，其中男主的偏执最后算是一种痴迷吧。玩网友的沉迷算是一种痴迷吗？也算是吧，对职业玩家来说。也算是吧，只是并不是我们想要的。</p>\n","excerpt":"<h2 id=\"随笔：游戏成瘾\"><a href=\"#随笔：游戏成瘾\" class=\"headerlink\" title=\"随笔：游戏成瘾\"></a>随笔：游戏成瘾</h2><p>以前一直不明白那些网瘾少年为什么网络游戏如此痴迷。都是些虚虚假假的游戏，有什么好沉迷的。大概正是因为我没有深入玩过任何一款网络游戏所以才有这个疑惑。就好像一直不明白传销的那些人如何被洗脑的一样，怎么会那么啥？</p>\n<p>入手《王者荣耀》初衷是想探探网络游戏究竟是什么如此令人着迷。也断断续续的完了好长时间了。来做个记录吧。</p>","more":"<h4 id=\"着迷的并不是游戏本身\"><a href=\"#着迷的并不是游戏本身\" class=\"headerlink\" title=\"着迷的并不是游戏本身\"></a>着迷的并不是游戏本身</h4><p>着迷的并不是游戏本身，而是游戏设计者在游戏中设计的很多”陷阱”。一下从简说下我的感受吧。这些陷阱包括：好胜心，贪婪，虚荣心…</p>\n<ul>\n<li>好胜心：我们在杀掉他人并取得胜利的时候会有爽快感觉。</li>\n<li>贪婪：我们在赢了之后还想再赢，再输了之后还想赢回来</li>\n<li>虚荣心：我们行不断提升段位，获得更多的MVP成就数据，因为这些能被游戏好友、微信好友看到。</li>\n</ul>\n<h4 id=\"吸引你的更多的是游戏本身之外的东西\"><a href=\"#吸引你的更多的是游戏本身之外的东西\" class=\"headerlink\" title=\"吸引你的更多的是游戏本身之外的东西\"></a>吸引你的更多的是游戏本身之外的东西</h4><ul>\n<li>如果这个游戏没有了段位设定，还会有这么多人如此痴迷吗？</li>\n<li>如果这个游戏里不是基于微信或qq帐号体系的，甚至游戏里不能互相交流也永远不知道谁是谁 还会有这么多人如此痴迷？</li>\n</ul>\n<h4 id=\"网游的根本目标是盈利\"><a href=\"#网游的根本目标是盈利\" class=\"headerlink\" title=\"网游的根本目标是盈利\"></a>网游的根本目标是盈利</h4><p>游戏策划者在游戏里设计那么多陷阱，最终是为了实现盈利的目标。首先要有人玩，有很多人玩，然后这其中有部分人愿意花钱买单就行了。<br>举几个例子：</p>\n<h5 id=\"首冲\"><a href=\"#首冲\" class=\"headerlink\" title=\"首冲\"></a>首冲</h5><p>游戏里首冲一般都有奖励，这个是先建立你的支付习惯。</p>\n<h5 id=\"抽奖概率\"><a href=\"#抽奖概率\" class=\"headerlink\" title=\"抽奖概率\"></a>抽奖概率</h5><p>每个玩家每个阶段中奖概率肯定不一样。通常前期中奖概率会高一点，好引诱你冲更多的值。后面会根据玩家的行为做概率调整，比如判定大拿玩家和普通玩家的概率，对不同阶段的概率都会有波动调整。最终为了让你花钱或化更多的钱来参与。</p>\n<h5 id=\"匹配机制\"><a href=\"#匹配机制\" class=\"headerlink\" title=\"匹配机制\"></a>匹配机制</h5><p>这也是影响有游戏声明周期的关键环节。<br>在保证游戏的平衡性大前提下，根据你的游戏记录适当倾斜下难易程度，比如当你连赢几把的时候，肯定就要给你匹配些强对手和弱队友了。让你不那么容易的升到顶级。实时证明王者荣耀这个匹配做的很极致。</p>\n<h4 id=\"社交属性\"><a href=\"#社交属性\" class=\"headerlink\" title=\"社交属性\"></a>社交属性</h4><p>当然网友还有一大属性是社交属性，先不说这点了…</p>\n<h5 id=\"等等吧\"><a href=\"#等等吧\" class=\"headerlink\" title=\"等等吧\"></a>等等吧</h5><p>不断增加英雄，赛季重置等 这都是延长游戏生命周期的又一手段。<br>增加皮肤，抽奖等都是为了增加盈利…</p>\n<h3 id=\"最初我们为什么玩游戏？\"><a href=\"#最初我们为什么玩游戏？\" class=\"headerlink\" title=\"最初我们为什么玩游戏？\"></a>最初我们为什么玩游戏？</h3><p>这里不说职业玩家，就说普通玩家。本来我们玩游戏是为了放松，休闲。然而我发现每次我玩完都会很累。当我们得到的结果不符合我们的目标预期的时候，我们就要注意了，肯定有坑。<br>然而游戏策划们就是利用人们的各种人性的弱点或者优点让你玩更久的游戏话更多的钱。而这一切都是你愿意的。</p>\n<h3 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h3><p>没啥逻辑，想到啥就写了。总之手游大多是坑，他们都是为了赚钱。我已经不再主动玩这这个游戏了（好友邀请可以玩一把，这就是他的社交属性的体现了）。</p>\n<h3 id=\"真正的结语\"><a href=\"#真正的结语\" class=\"headerlink\" title=\"真正的结语\"></a>真正的结语</h3><p>再想想这些网友的沉迷，往往并不是对有游戏的热爱和痴迷，而是更多的是对自己的暂时性失控。玩玩单机游戏吧，坑少些。<br>有个电影叫《爆裂鼓手》，其中男主的偏执最后算是一种痴迷吧。玩网友的沉迷算是一种痴迷吗？也算是吧，对职业玩家来说。也算是吧，只是并不是我们想要的。</p>"},{"title":"非对称加密(公钥加密)及其应用","date":"2018-02-23T04:20:48.000Z","_content":"\n### 什么是非对称加密\n[维基百科](https://zh.wikipedia.org/wiki/ %E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86)已经解释的非常清楚了（只看对公开密钥加密的解释这部分就好，其他部分说的并不好，引用如下）。\n\n> 公开密钥加密（英语：Public-key cryptography），也称为非对称加密（英语：asymmetric cryptography），是密码学的一种算法，它需要两个密钥，一个是公开密钥，另一个是私有密钥；一个用作加密的时候，另一个则用作解密。使用其中一个密钥把明文加密后所得的密文，只能用相对应的另一个密钥才能解密得到原本的明文；甚至连最初用来加密的密钥也不能用作解密。由于加密和解密需要两个不同的密钥，故被称为非对称加密；不同于加密和解密都使用同一个密钥的对称加密。虽然两个密钥在数学上相关，但如果知道了其中一个，并不能凭此计算出另外一个；因此其中一个可以公开，称为公钥，任意向外发布；不公开的密钥为私钥，必须由用户自行严格秘密保管，绝不通过任何途径向任何人提供，也不会透露给要通信的另一方，即使他被信任。\n\n维基上说的说的有点啰嗦，精简一下就是：\n\n<!-- more -->\n\n> 加密解密通过一个秘钥对即公开密钥和私有密钥完成的。\n> <br/>用公钥加密明文得到的密文，只能通过对应的私钥解密得到明文。\n> （类似私钥加密明文得到密的文，只能通过对应的公钥解密得到明文）\n> <br/> 密钥对是数学相关的。\n\n在现实世界上可作比拟的例子是，一个传统保管箱，开门和关门都是使用同一把钥匙，这是对称加密；而一个公开的邮箱，投递口是任何人都可以寄信进去的，这可视为公钥；而只有邮箱主人拥有钥匙可以打开邮箱，这就视为私钥。这就是非对称加密。（以下说的公钥加密和对对称加密是一回事）\n\n\n### 与对称加密的比较\n对称加密的问题在于通信双方要事先交换密钥，而事先传递密钥的过程 存在密钥泄露的风险。密钥一旦泄露，数据就不安全了。 \n而非对称加密，密钥对的私钥是保密的不需要事先传递或公开的，所以安全性更高。\n\n注意，看网上的博文很多人对这里的理解是不太透彻的: 认为对称加密的问题在于加解密用同样的密钥，所以导致对称加密不安全的。 \n > 加解密使用同样的密钥-这是对称加密的概念也是其形式，把对称加密安全性差归咎于此不太妥（要强扯也┑(￣Д ￣)┍）。\n \n 对称加密的安全性低，问题在于两点： \n \n  * 由于加密解密用同样的密钥，其密钥需要通信双方事先交换（或单向传递），密钥交换的过程存在泄漏的风险。\n  * 由于密钥通信双方都知道，通信接收方可以泄漏发送方的密钥给其他人。 \n    \n而以上两个问题非对称加密都解决了：\n\n  * 加密解密需要一对密钥来完成，其中私钥是不公开也不需要事先传递的，所以泄漏的概率更小。 \n  * 公钥加密的信息只能通过其对应的私钥来解密，私钥是属于通信双方中某一方且保密的，而公钥是公开的，所以不存在泄漏对方密钥的风险。 \n \n 所以，在保证密钥不被泄漏的前提下对称加密和非对称加密是一样安全的。 但是，对称加密中，通信双方在事后有泄漏对方密钥的可能。 如果再加一个条件通信双方的发送者对每一个接收者使用不同的密钥，这样就能保证对称加密和非对称加密一样安全了。 但是这两点都比较难保证：1.传递密钥过程的安全性依赖传递环境。2.需要每个人都要有很多很多密钥，不同的接收方用不同的密钥，密钥难以保管。\n \n所以这个时候非对称加密华丽登场了。 \n下面我们通过对具体的某一种非对称加密算法的学习来理解非对称加密的数学原理。这里我们选用应用最广泛的非对称加密算法之一：RSA加密算法。\n\n### RSA算法\nRSA算法的数学基础是：欧拉定理，此处不做解释。公钥加密算法根据其所依据的数学难题一般分为三类：大整数因式分解问题类、离散对数问题类，椭圆曲线类。RSA属于大数分解类，也是最好理解的。\n\n下面直接介绍RSA算法的基础步骤；\n\n#### 1. 生成公钥（PK）和私钥(SK)\n\n* (1) 随意选两个大的素数p和q，p不等于q\n* (2) 将p、q两个素数相乘得到n，即n=pq\n* (3) 计算n的欧拉函数φ(n):根据公式 φ(n)=(p-1)(q-1)\n* (4) 选择一个整数e，作为密钥，使得e和φ(n)互质，且e < φ(n)\n* (5) 计算e对于φ(n)的模反元素d: 根据公式 ed mod φ(n)  = 1 ,计算出d的值，作为另一个密钥。\n 所谓\"模反元素\"就是指有一个整数d，可以使得ed被φ(n)除的余数为1。\n``` txt\n        ed ≡ 1 (mod φ(n)) ==> \n        ed - 1 = kφ(n)  //求解二元一次方程 k 从1带入试就行了 \n    思考： 一个整数A除以另一个整数B的余数是C， 已知B和C，A是唯一的吗？\n```\n* (6) 通过以上步骤计算出 n 、e 、d 3个数据，其中（n、e）作为公钥，（n、d）作为私钥（也可以互换）\n* (7) 生成公钥和私钥后就可以公开公钥了。\n\n      \n\n#### 2. 用公钥加密信息\n信息发送方收到接收方公钥PK后，就可以用PK对数据加密。加密步骤如下。 其中明文为M，加密后的密文为C，公钥（n,e）\n\n    \n> 加密： M^e  mod n = C\n \n \n#### 3. 用私钥解密信息\n接收方持有私钥（N，D）,在接收到密文C后，通过私钥对其解密，得到明文M：\n\n> 解密： C^d mod n = M  \n \n### RSA 安全性分析\n\n通常到这里我们会有个疑问？ 公钥和私钥存在一定的数学关系， 公钥公开，那么有没有可能通过公钥推导出私钥呢？ 如果能那不就不安全了吗。 答案是：能，但是很难。\n问题变成 能否在已知 n和e的前提下，推导出d ?\n\n``` txt\n    ed ≡ 1 (mod φ(n))   //等价于 ed mod φ(n)  = 1 \n    φ(n)=(p-1)(q-1)\n    n=pq\n```\n结论：如果n可以被因数分解，d就可以算出。\n但是，大整数的因式分解是很困难的，目前除了暴力破解，还没有更好的有效方式。\n\n所以整数n的因式分解难度决定了RSA算法的可靠度。\n>  RSA可靠性就是建立在分解两个大素数乘积的十分困难上。\n\n这个难度是个什么概念呢？[引用](http://blog.csdn.net/woyaokaoyan/article/details/5169098)\n>RSA算法的破解与密钥的长度有关，最常见的破解方法是因式分解，如果密钥的长度小于等于256位，一台较快的电脑可以在几个小时内成功分解其因子。位数越高因式分解所需时间也越长。1999年，一台Cray超级电脑用了5个月时间分解了512位长的密钥。而目前典型密钥长度是1028位。在512位RSA算法破解10年之后，一群研究人员报告(PDF)他们因式分解了768位RSA算法。他们是在2009年12月9日分解了768位、232数位数字的RSA-768密钥。分解一个768位RSA密钥所需时间是512位的数千倍，而1024位所需时间则是768位的一千多倍，因此在短时间内1024位仍然是安全的。研究人员表示1024位密钥预计也将会在10年内攻破，因此在未来三到四年内应逐步淘汰1024位RSA密钥。\n\n思考一下大整数n 因式分解为什么难？有多难？\n\n### RSA 算法实例\n#### 生成公钥私钥\n* 随机取大质数p=11，q=13，那n=11*13=143，φ(N)=(p-1)(q-1) = 130 \n* 取一个e=7，由 ed mod φ(n)  = 1 计算出d=103。\n``` txt\n        公钥（n,e） 即 （143, 7）\n        私钥 (n,d) 即 （143, 103）\n```\n#### 用公钥加密\n由于手工计算，为了使计算量小一点，我们将上面的公钥和私钥交换： 即公钥 （143, 103），私钥（143, 7）。取明文 m =2,加密过程如下：\n\n``` txt\n    密文 c =  m^e mod n\n          =  2^103 mod 143 \n          = 10141204801825835211973625643008 mod 143 \n          = 63 \n```\n          \n\n#### 用私钥解密\n\n收到密文c = 63,通过 私钥（143，7）进行解密，解密过程如下：\n\n``` txt\n    明文  m = c^d mod n \n             = 63^7 mod 143\n             = 3938980639167 mod 143 \n             = 2 \n```\n至此，我们用RSA算法进行了一次加密解密，其实很简单，只是计算量可能会比较大。  \n\n常见的公钥加密算法除了RSA。还有ElGamal、背包算法、椭圆曲线加密算法（英语：Elliptic Curve Cryptography, ECC）等。下面我们说下非对称加密的应用。\n\n### 非对称加密的应用\n\n先插入一个概念： `信息系统安全的基本属性`。\n\n> 信息系统安全的基本属性: 保密性、完整性、可用性、不可抵赖性。\n\n* 保密性：是应用系统的信息不被泄露给非授权的用户。常用保密技术：最小授权原则，信息加密等。\n* 完整性：完整性是信息未经授权不能进行改变的特性。完整性是一种面向信息的安全性。\n* 可用性： 可用性是应用系统面向用户的安全性能，不做赘述。\n* 不可抵赖性：不可抵赖性也称作不可否认性，在应用系统的信息交互过程中，确信参与者的真实同一性。即所有参与者都不可能否认或抵赖曾经完成的操作和承诺。利用信息源证据可以防止发信方不真实地否认已发送信息，利用递交接收证据可以防止收信方事后否认已经接收的信息。\n\n加密技术也是用来加强信息安全的，接下来说的几个非对称加密实际应用也是如此。\n回归正题，接下来说非对称加密最广泛的应用之一：数字签名。\n\n#### 数字签名 \n    \n> 数字签名在ISO7498—2标准中定义为：“附加在数据单元上的一些数据，或是对数据单元所作的密码变换，这种数据和变换允许数据单元的接收者用以确认数据单元来源和数据单元的完整性，并保护数据，防止被人（例如接收者）进行伪造”\n\n首先搞清楚数字签名解决的是什么问题？ 然后看看什么是数字签名？最后分析下数字签名为什么能解决这些问题？\n\n##### 数字签名解决什么问题？\n纸质书信或文件根据亲笔签名或印章来证明其真实性，及防抵赖。对应上述信息安全的 完整性和不可抵赖性。 而数字签名则可以看做是对在网络中传输的报文的签名，作用自然也是为了保证信息的完整性及不可抵赖性。 \n\n那下面我们看下数字签名是如何做到证明信息的完整性及防抵赖的？\n\n##### 数字签名的实现方法？\n建立在公钥密码技术上的数字签名方法有很多，有RSA签名、DSA签名和椭圆曲线数字签名算法（ECDSA）等等。下面对RSA签名进行详细分析。\n\n这里需要理解[哈希-hash](https://baike.baidu.com/item/%E5%93%88%E5%B8%8C%E5%80%BC)的概念。简单说hash 就是计算机可以对任意内容计算出一个固定长度的值，且不会重复。\n\n直接看图：\n\n![数字签名](https://ws1.sinaimg.cn/large/d16dcf79ly1fobiaii5v2j22fk12812h.jpg)\n\n\n   （1）发送方采用某种摘要算法从报文中生成一个128位的散列值（称为报文摘要）；\n\n　　（2）发送方用RSA算法和自己的私钥对这个散列值进行加密，产生一个摘要密文，这就是发送方的数字签名；\n\n　　（3）将这个加密后的数字签名作为报文的附件和报文一起发送给接收方：\n\n　　（4）接收方从接收到的原始报文中采用相同的摘要算法计算出128位的散列值；\n\n　　（5）报文的接收方用RSA算法和发送方的公钥对报文附加的数字签名进行解密；\n\n　　（6）如果两个散列值相同，那么接收方就能确认报文是由发送方签名的。\n\n最常用的摘要算法叫做MD5（Message Digest 5）。MD5采用单向Hash函数将任意长度的“字节串”变换成一个128位的散列值，并且它是一个不可逆的字符串变换算法。\n\n\n\n##### 数字为什么能保证信息完整性及不可抵赖性？\n\n###### 信息的完整性\n如果报文在网络传输过程中被修改，接收方收到此报文后，使用相同的摘要算法将计算出不同的报文摘要，这就保证了接收方可以判断报文自签名后到收到为止，是否被修改过。\n###### 信息的不可抵赖性 \n如果发送方A想让接收方误认为此报文是由发送方B签名发送的，由于发送方A不知道发送方B的私钥，所以接收方用发送方B的公钥对发送方A加密的报文摘要进行解密时，也将得出不同的报文摘要，这就保证了接收方可以判断报文是否是由指定的签名者发送。同时也可以看出，当两个散列值相同时，发送方B无法否认这个报文是他签名发送的。\n\n\n##### 关于数字签名的一点问题\n\n关于数字签名就说完了。但有个疑问：传输过程中原文没有被加密吗？是的。上面是无保密机制的数字签名。具有保密机制的RSA签名机制自己看[这边文章](http://www.elecfans.com/baike/tongxingjishu/chungshuwang/20110710205779.html)吧 。\n\n\n#### 数字证书\n关于上面数字签名有一个问题：信息接收方如何确认拿到的公钥就是期望的发送方的公钥？ \n\n举个例子：\n\n小红与小绿写信。 小绿写完信后 用自己的私钥对信件摘要生成 ‘数字签名’ 连同信件一块发给小红。 小红收到信件后用小绿的公钥解密信件里的数字签名得到信件摘要。 这个过程没有问题。\n\n但是有一天，第三者-小强出现了。小强偷偷将小红电脑里的小绿的公钥换成他自己的了，但此时小红还以为那是小绿的公钥。 因此，小强就可以冒充小绿，用自己的私钥对信件摘要进行 ‘数字签名’，发给小红。小红用小强掉包后的公钥对数字签名解密，还以为对方是小绿。\n\n后来小红感觉不对劲，他发现自己无法确定公钥是否真的是小绿的。于是她想了一个办法，让小绿找“证书中心\"（certificate authority，简称CA） 为自己的公钥做认证。认证机构用自己的私钥对小绿的公钥和一些相关信息一起加密，生成‘数字证书’。\n\n小绿拿到‘数字证书’后，再给苏珊写信，只要在签名的同时，再附上数字证书就行了。\n小红收信后，用CA的公钥解开数字证书，就可以拿到小绿的公钥了\n，然后就能验证数字签名是否是小绿的。\n\n这里我们先大概知道CA是一个第三方机构，用来对个人身份认证的，而认证的形式就是‘数字证书’。\n这个例子中忽略了一个关键细节，如何确定证书的真实性呢？ 接下来我们细细介绍。\n\n#### https 实例分析\n\nhttps 是数字证书的应用之一。我们通过对https的从简介绍来理解数字证书。 \n##### CA \nCA（certificate authority）证书授权中心。 受信任的第三方机构。 CA为每个使用公开密钥的用户发放一个数字证书。证书生成的过程可以认为就是CA用自己的私钥对公钥持有方的公钥及一些相关信息进行数字签名。\n\n> 数字证书是一个经证书授权中心（CA）数字签名的包含公钥拥有者信息以及公钥的文件。\n\n数字证书的作用是证明证书中列出的用户合法拥有证书中列出的公钥。\n##### 根证书\n而CA的公钥叫做根证书。 这些根证书是预先被安装在浏览器里的,用来解密服务器的证书的。\n  \n##### https 访问\n通过https建立了一个安全 Web 事务之后，现代的浏览器都会自动获取所连接服务器的数字证书。如果服务器没有证书，安全连接就会失败。\n浏览器预先安装了一些CA的根证书。浏览器用对应的根证书去解密网站服务器的数字证书获取到网站服务器的公钥。然后浏览器发送一个随机字符串给服务器，服务器用自己的私钥加密这个随机字符串后返回给浏览器，浏览器比较这个随机字符串是否和发出去的一样。 如果一样，则说明服务器的公钥和证书里的公钥一致，则证明服务器就是服务器。\n\n当然真实的https过程 比这个复杂很多，这里只是为了方便理解证书在非对称加密应用中的作用，忽略了很多技术细节。\n\n\n### 最后\n\n静静的学习完了，我们再来说下时下最热的加密币。加密币里的交易安全基础就是非对称加密算法。就以币王BTC（比特币）来说。\n\n > 比特币钱包: 是用来存放私钥和公钥的，而不是存放币的。\n <br/>比特币地址: 钱包公钥的哈希值（更短，方便保存和传播），用来收币的。 \n <br/>比特币使用了基于secp256k1椭圆曲线加密算法（非对称加密算法的一种）。\n <br/>一笔交易实质就是一个地址的一定数量的比特币转移到另一个地址。而交易过程安全则是由其非对称加密算法保障。\n\n\n\n最最后总结下本文：\n\n*  什么是非对称加密\n*  RSA算法的原理和用法\n*  什么是数字签名\n*  什么是数字证书及数字证书的作用\n*  又要上班了。\n\n\n### 参考资料\n[数字签名技术原理介绍](http://www.elecfans.com/baike/tongxingjishu/chungshuwang/20110710205779.html)","source":"_posts/非对称加密及其应用.md","raw":"---\ntitle: 非对称加密(公钥加密)及其应用\ndate: 2018-02-23 12:20:48\ntags:\n    - RSA\n    - 非对称加密\n    - 数字签名\ncategories:\n   \n---\n\n### 什么是非对称加密\n[维基百科](https://zh.wikipedia.org/wiki/ %E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86)已经解释的非常清楚了（只看对公开密钥加密的解释这部分就好，其他部分说的并不好，引用如下）。\n\n> 公开密钥加密（英语：Public-key cryptography），也称为非对称加密（英语：asymmetric cryptography），是密码学的一种算法，它需要两个密钥，一个是公开密钥，另一个是私有密钥；一个用作加密的时候，另一个则用作解密。使用其中一个密钥把明文加密后所得的密文，只能用相对应的另一个密钥才能解密得到原本的明文；甚至连最初用来加密的密钥也不能用作解密。由于加密和解密需要两个不同的密钥，故被称为非对称加密；不同于加密和解密都使用同一个密钥的对称加密。虽然两个密钥在数学上相关，但如果知道了其中一个，并不能凭此计算出另外一个；因此其中一个可以公开，称为公钥，任意向外发布；不公开的密钥为私钥，必须由用户自行严格秘密保管，绝不通过任何途径向任何人提供，也不会透露给要通信的另一方，即使他被信任。\n\n维基上说的说的有点啰嗦，精简一下就是：\n\n<!-- more -->\n\n> 加密解密通过一个秘钥对即公开密钥和私有密钥完成的。\n> <br/>用公钥加密明文得到的密文，只能通过对应的私钥解密得到明文。\n> （类似私钥加密明文得到密的文，只能通过对应的公钥解密得到明文）\n> <br/> 密钥对是数学相关的。\n\n在现实世界上可作比拟的例子是，一个传统保管箱，开门和关门都是使用同一把钥匙，这是对称加密；而一个公开的邮箱，投递口是任何人都可以寄信进去的，这可视为公钥；而只有邮箱主人拥有钥匙可以打开邮箱，这就视为私钥。这就是非对称加密。（以下说的公钥加密和对对称加密是一回事）\n\n\n### 与对称加密的比较\n对称加密的问题在于通信双方要事先交换密钥，而事先传递密钥的过程 存在密钥泄露的风险。密钥一旦泄露，数据就不安全了。 \n而非对称加密，密钥对的私钥是保密的不需要事先传递或公开的，所以安全性更高。\n\n注意，看网上的博文很多人对这里的理解是不太透彻的: 认为对称加密的问题在于加解密用同样的密钥，所以导致对称加密不安全的。 \n > 加解密使用同样的密钥-这是对称加密的概念也是其形式，把对称加密安全性差归咎于此不太妥（要强扯也┑(￣Д ￣)┍）。\n \n 对称加密的安全性低，问题在于两点： \n \n  * 由于加密解密用同样的密钥，其密钥需要通信双方事先交换（或单向传递），密钥交换的过程存在泄漏的风险。\n  * 由于密钥通信双方都知道，通信接收方可以泄漏发送方的密钥给其他人。 \n    \n而以上两个问题非对称加密都解决了：\n\n  * 加密解密需要一对密钥来完成，其中私钥是不公开也不需要事先传递的，所以泄漏的概率更小。 \n  * 公钥加密的信息只能通过其对应的私钥来解密，私钥是属于通信双方中某一方且保密的，而公钥是公开的，所以不存在泄漏对方密钥的风险。 \n \n 所以，在保证密钥不被泄漏的前提下对称加密和非对称加密是一样安全的。 但是，对称加密中，通信双方在事后有泄漏对方密钥的可能。 如果再加一个条件通信双方的发送者对每一个接收者使用不同的密钥，这样就能保证对称加密和非对称加密一样安全了。 但是这两点都比较难保证：1.传递密钥过程的安全性依赖传递环境。2.需要每个人都要有很多很多密钥，不同的接收方用不同的密钥，密钥难以保管。\n \n所以这个时候非对称加密华丽登场了。 \n下面我们通过对具体的某一种非对称加密算法的学习来理解非对称加密的数学原理。这里我们选用应用最广泛的非对称加密算法之一：RSA加密算法。\n\n### RSA算法\nRSA算法的数学基础是：欧拉定理，此处不做解释。公钥加密算法根据其所依据的数学难题一般分为三类：大整数因式分解问题类、离散对数问题类，椭圆曲线类。RSA属于大数分解类，也是最好理解的。\n\n下面直接介绍RSA算法的基础步骤；\n\n#### 1. 生成公钥（PK）和私钥(SK)\n\n* (1) 随意选两个大的素数p和q，p不等于q\n* (2) 将p、q两个素数相乘得到n，即n=pq\n* (3) 计算n的欧拉函数φ(n):根据公式 φ(n)=(p-1)(q-1)\n* (4) 选择一个整数e，作为密钥，使得e和φ(n)互质，且e < φ(n)\n* (5) 计算e对于φ(n)的模反元素d: 根据公式 ed mod φ(n)  = 1 ,计算出d的值，作为另一个密钥。\n 所谓\"模反元素\"就是指有一个整数d，可以使得ed被φ(n)除的余数为1。\n``` txt\n        ed ≡ 1 (mod φ(n)) ==> \n        ed - 1 = kφ(n)  //求解二元一次方程 k 从1带入试就行了 \n    思考： 一个整数A除以另一个整数B的余数是C， 已知B和C，A是唯一的吗？\n```\n* (6) 通过以上步骤计算出 n 、e 、d 3个数据，其中（n、e）作为公钥，（n、d）作为私钥（也可以互换）\n* (7) 生成公钥和私钥后就可以公开公钥了。\n\n      \n\n#### 2. 用公钥加密信息\n信息发送方收到接收方公钥PK后，就可以用PK对数据加密。加密步骤如下。 其中明文为M，加密后的密文为C，公钥（n,e）\n\n    \n> 加密： M^e  mod n = C\n \n \n#### 3. 用私钥解密信息\n接收方持有私钥（N，D）,在接收到密文C后，通过私钥对其解密，得到明文M：\n\n> 解密： C^d mod n = M  \n \n### RSA 安全性分析\n\n通常到这里我们会有个疑问？ 公钥和私钥存在一定的数学关系， 公钥公开，那么有没有可能通过公钥推导出私钥呢？ 如果能那不就不安全了吗。 答案是：能，但是很难。\n问题变成 能否在已知 n和e的前提下，推导出d ?\n\n``` txt\n    ed ≡ 1 (mod φ(n))   //等价于 ed mod φ(n)  = 1 \n    φ(n)=(p-1)(q-1)\n    n=pq\n```\n结论：如果n可以被因数分解，d就可以算出。\n但是，大整数的因式分解是很困难的，目前除了暴力破解，还没有更好的有效方式。\n\n所以整数n的因式分解难度决定了RSA算法的可靠度。\n>  RSA可靠性就是建立在分解两个大素数乘积的十分困难上。\n\n这个难度是个什么概念呢？[引用](http://blog.csdn.net/woyaokaoyan/article/details/5169098)\n>RSA算法的破解与密钥的长度有关，最常见的破解方法是因式分解，如果密钥的长度小于等于256位，一台较快的电脑可以在几个小时内成功分解其因子。位数越高因式分解所需时间也越长。1999年，一台Cray超级电脑用了5个月时间分解了512位长的密钥。而目前典型密钥长度是1028位。在512位RSA算法破解10年之后，一群研究人员报告(PDF)他们因式分解了768位RSA算法。他们是在2009年12月9日分解了768位、232数位数字的RSA-768密钥。分解一个768位RSA密钥所需时间是512位的数千倍，而1024位所需时间则是768位的一千多倍，因此在短时间内1024位仍然是安全的。研究人员表示1024位密钥预计也将会在10年内攻破，因此在未来三到四年内应逐步淘汰1024位RSA密钥。\n\n思考一下大整数n 因式分解为什么难？有多难？\n\n### RSA 算法实例\n#### 生成公钥私钥\n* 随机取大质数p=11，q=13，那n=11*13=143，φ(N)=(p-1)(q-1) = 130 \n* 取一个e=7，由 ed mod φ(n)  = 1 计算出d=103。\n``` txt\n        公钥（n,e） 即 （143, 7）\n        私钥 (n,d) 即 （143, 103）\n```\n#### 用公钥加密\n由于手工计算，为了使计算量小一点，我们将上面的公钥和私钥交换： 即公钥 （143, 103），私钥（143, 7）。取明文 m =2,加密过程如下：\n\n``` txt\n    密文 c =  m^e mod n\n          =  2^103 mod 143 \n          = 10141204801825835211973625643008 mod 143 \n          = 63 \n```\n          \n\n#### 用私钥解密\n\n收到密文c = 63,通过 私钥（143，7）进行解密，解密过程如下：\n\n``` txt\n    明文  m = c^d mod n \n             = 63^7 mod 143\n             = 3938980639167 mod 143 \n             = 2 \n```\n至此，我们用RSA算法进行了一次加密解密，其实很简单，只是计算量可能会比较大。  \n\n常见的公钥加密算法除了RSA。还有ElGamal、背包算法、椭圆曲线加密算法（英语：Elliptic Curve Cryptography, ECC）等。下面我们说下非对称加密的应用。\n\n### 非对称加密的应用\n\n先插入一个概念： `信息系统安全的基本属性`。\n\n> 信息系统安全的基本属性: 保密性、完整性、可用性、不可抵赖性。\n\n* 保密性：是应用系统的信息不被泄露给非授权的用户。常用保密技术：最小授权原则，信息加密等。\n* 完整性：完整性是信息未经授权不能进行改变的特性。完整性是一种面向信息的安全性。\n* 可用性： 可用性是应用系统面向用户的安全性能，不做赘述。\n* 不可抵赖性：不可抵赖性也称作不可否认性，在应用系统的信息交互过程中，确信参与者的真实同一性。即所有参与者都不可能否认或抵赖曾经完成的操作和承诺。利用信息源证据可以防止发信方不真实地否认已发送信息，利用递交接收证据可以防止收信方事后否认已经接收的信息。\n\n加密技术也是用来加强信息安全的，接下来说的几个非对称加密实际应用也是如此。\n回归正题，接下来说非对称加密最广泛的应用之一：数字签名。\n\n#### 数字签名 \n    \n> 数字签名在ISO7498—2标准中定义为：“附加在数据单元上的一些数据，或是对数据单元所作的密码变换，这种数据和变换允许数据单元的接收者用以确认数据单元来源和数据单元的完整性，并保护数据，防止被人（例如接收者）进行伪造”\n\n首先搞清楚数字签名解决的是什么问题？ 然后看看什么是数字签名？最后分析下数字签名为什么能解决这些问题？\n\n##### 数字签名解决什么问题？\n纸质书信或文件根据亲笔签名或印章来证明其真实性，及防抵赖。对应上述信息安全的 完整性和不可抵赖性。 而数字签名则可以看做是对在网络中传输的报文的签名，作用自然也是为了保证信息的完整性及不可抵赖性。 \n\n那下面我们看下数字签名是如何做到证明信息的完整性及防抵赖的？\n\n##### 数字签名的实现方法？\n建立在公钥密码技术上的数字签名方法有很多，有RSA签名、DSA签名和椭圆曲线数字签名算法（ECDSA）等等。下面对RSA签名进行详细分析。\n\n这里需要理解[哈希-hash](https://baike.baidu.com/item/%E5%93%88%E5%B8%8C%E5%80%BC)的概念。简单说hash 就是计算机可以对任意内容计算出一个固定长度的值，且不会重复。\n\n直接看图：\n\n![数字签名](https://ws1.sinaimg.cn/large/d16dcf79ly1fobiaii5v2j22fk12812h.jpg)\n\n\n   （1）发送方采用某种摘要算法从报文中生成一个128位的散列值（称为报文摘要）；\n\n　　（2）发送方用RSA算法和自己的私钥对这个散列值进行加密，产生一个摘要密文，这就是发送方的数字签名；\n\n　　（3）将这个加密后的数字签名作为报文的附件和报文一起发送给接收方：\n\n　　（4）接收方从接收到的原始报文中采用相同的摘要算法计算出128位的散列值；\n\n　　（5）报文的接收方用RSA算法和发送方的公钥对报文附加的数字签名进行解密；\n\n　　（6）如果两个散列值相同，那么接收方就能确认报文是由发送方签名的。\n\n最常用的摘要算法叫做MD5（Message Digest 5）。MD5采用单向Hash函数将任意长度的“字节串”变换成一个128位的散列值，并且它是一个不可逆的字符串变换算法。\n\n\n\n##### 数字为什么能保证信息完整性及不可抵赖性？\n\n###### 信息的完整性\n如果报文在网络传输过程中被修改，接收方收到此报文后，使用相同的摘要算法将计算出不同的报文摘要，这就保证了接收方可以判断报文自签名后到收到为止，是否被修改过。\n###### 信息的不可抵赖性 \n如果发送方A想让接收方误认为此报文是由发送方B签名发送的，由于发送方A不知道发送方B的私钥，所以接收方用发送方B的公钥对发送方A加密的报文摘要进行解密时，也将得出不同的报文摘要，这就保证了接收方可以判断报文是否是由指定的签名者发送。同时也可以看出，当两个散列值相同时，发送方B无法否认这个报文是他签名发送的。\n\n\n##### 关于数字签名的一点问题\n\n关于数字签名就说完了。但有个疑问：传输过程中原文没有被加密吗？是的。上面是无保密机制的数字签名。具有保密机制的RSA签名机制自己看[这边文章](http://www.elecfans.com/baike/tongxingjishu/chungshuwang/20110710205779.html)吧 。\n\n\n#### 数字证书\n关于上面数字签名有一个问题：信息接收方如何确认拿到的公钥就是期望的发送方的公钥？ \n\n举个例子：\n\n小红与小绿写信。 小绿写完信后 用自己的私钥对信件摘要生成 ‘数字签名’ 连同信件一块发给小红。 小红收到信件后用小绿的公钥解密信件里的数字签名得到信件摘要。 这个过程没有问题。\n\n但是有一天，第三者-小强出现了。小强偷偷将小红电脑里的小绿的公钥换成他自己的了，但此时小红还以为那是小绿的公钥。 因此，小强就可以冒充小绿，用自己的私钥对信件摘要进行 ‘数字签名’，发给小红。小红用小强掉包后的公钥对数字签名解密，还以为对方是小绿。\n\n后来小红感觉不对劲，他发现自己无法确定公钥是否真的是小绿的。于是她想了一个办法，让小绿找“证书中心\"（certificate authority，简称CA） 为自己的公钥做认证。认证机构用自己的私钥对小绿的公钥和一些相关信息一起加密，生成‘数字证书’。\n\n小绿拿到‘数字证书’后，再给苏珊写信，只要在签名的同时，再附上数字证书就行了。\n小红收信后，用CA的公钥解开数字证书，就可以拿到小绿的公钥了\n，然后就能验证数字签名是否是小绿的。\n\n这里我们先大概知道CA是一个第三方机构，用来对个人身份认证的，而认证的形式就是‘数字证书’。\n这个例子中忽略了一个关键细节，如何确定证书的真实性呢？ 接下来我们细细介绍。\n\n#### https 实例分析\n\nhttps 是数字证书的应用之一。我们通过对https的从简介绍来理解数字证书。 \n##### CA \nCA（certificate authority）证书授权中心。 受信任的第三方机构。 CA为每个使用公开密钥的用户发放一个数字证书。证书生成的过程可以认为就是CA用自己的私钥对公钥持有方的公钥及一些相关信息进行数字签名。\n\n> 数字证书是一个经证书授权中心（CA）数字签名的包含公钥拥有者信息以及公钥的文件。\n\n数字证书的作用是证明证书中列出的用户合法拥有证书中列出的公钥。\n##### 根证书\n而CA的公钥叫做根证书。 这些根证书是预先被安装在浏览器里的,用来解密服务器的证书的。\n  \n##### https 访问\n通过https建立了一个安全 Web 事务之后，现代的浏览器都会自动获取所连接服务器的数字证书。如果服务器没有证书，安全连接就会失败。\n浏览器预先安装了一些CA的根证书。浏览器用对应的根证书去解密网站服务器的数字证书获取到网站服务器的公钥。然后浏览器发送一个随机字符串给服务器，服务器用自己的私钥加密这个随机字符串后返回给浏览器，浏览器比较这个随机字符串是否和发出去的一样。 如果一样，则说明服务器的公钥和证书里的公钥一致，则证明服务器就是服务器。\n\n当然真实的https过程 比这个复杂很多，这里只是为了方便理解证书在非对称加密应用中的作用，忽略了很多技术细节。\n\n\n### 最后\n\n静静的学习完了，我们再来说下时下最热的加密币。加密币里的交易安全基础就是非对称加密算法。就以币王BTC（比特币）来说。\n\n > 比特币钱包: 是用来存放私钥和公钥的，而不是存放币的。\n <br/>比特币地址: 钱包公钥的哈希值（更短，方便保存和传播），用来收币的。 \n <br/>比特币使用了基于secp256k1椭圆曲线加密算法（非对称加密算法的一种）。\n <br/>一笔交易实质就是一个地址的一定数量的比特币转移到另一个地址。而交易过程安全则是由其非对称加密算法保障。\n\n\n\n最最后总结下本文：\n\n*  什么是非对称加密\n*  RSA算法的原理和用法\n*  什么是数字签名\n*  什么是数字证书及数字证书的作用\n*  又要上班了。\n\n\n### 参考资料\n[数字签名技术原理介绍](http://www.elecfans.com/baike/tongxingjishu/chungshuwang/20110710205779.html)","slug":"非对称加密及其应用","published":1,"updated":"2018-03-10T16:05:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjelnshd8000s3gff05yujqx0","content":"<h3 id=\"什么是非对称加密\"><a href=\"#什么是非对称加密\" class=\"headerlink\" title=\"什么是非对称加密\"></a>什么是非对称加密</h3><p><a href=\"https://zh.wikipedia.org/wiki/ %E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86\" target=\"_blank\" rel=\"external\">维基百科</a>已经解释的非常清楚了（只看对公开密钥加密的解释这部分就好，其他部分说的并不好，引用如下）。</p>\n<blockquote>\n<p>公开密钥加密（英语：Public-key cryptography），也称为非对称加密（英语：asymmetric cryptography），是密码学的一种算法，它需要两个密钥，一个是公开密钥，另一个是私有密钥；一个用作加密的时候，另一个则用作解密。使用其中一个密钥把明文加密后所得的密文，只能用相对应的另一个密钥才能解密得到原本的明文；甚至连最初用来加密的密钥也不能用作解密。由于加密和解密需要两个不同的密钥，故被称为非对称加密；不同于加密和解密都使用同一个密钥的对称加密。虽然两个密钥在数学上相关，但如果知道了其中一个，并不能凭此计算出另外一个；因此其中一个可以公开，称为公钥，任意向外发布；不公开的密钥为私钥，必须由用户自行严格秘密保管，绝不通过任何途径向任何人提供，也不会透露给要通信的另一方，即使他被信任。</p>\n</blockquote>\n<p>维基上说的说的有点啰嗦，精简一下就是：</p>\n<a id=\"more\"></a>\n<blockquote>\n<p>加密解密通过一个秘钥对即公开密钥和私有密钥完成的。<br><br>用公钥加密明文得到的密文，只能通过对应的私钥解密得到明文。<br>（类似私钥加密明文得到密的文，只能通过对应的公钥解密得到明文）<br><br> 密钥对是数学相关的。</p>\n</blockquote>\n<p>在现实世界上可作比拟的例子是，一个传统保管箱，开门和关门都是使用同一把钥匙，这是对称加密；而一个公开的邮箱，投递口是任何人都可以寄信进去的，这可视为公钥；而只有邮箱主人拥有钥匙可以打开邮箱，这就视为私钥。这就是非对称加密。（以下说的公钥加密和对对称加密是一回事）</p>\n<h3 id=\"与对称加密的比较\"><a href=\"#与对称加密的比较\" class=\"headerlink\" title=\"与对称加密的比较\"></a>与对称加密的比较</h3><p>对称加密的问题在于通信双方要事先交换密钥，而事先传递密钥的过程 存在密钥泄露的风险。密钥一旦泄露，数据就不安全了。<br>而非对称加密，密钥对的私钥是保密的不需要事先传递或公开的，所以安全性更高。</p>\n<p>注意，看网上的博文很多人对这里的理解是不太透彻的: 认为对称加密的问题在于加解密用同样的密钥，所以导致对称加密不安全的。 </p>\n<blockquote>\n<p>加解密使用同样的密钥-这是对称加密的概念也是其形式，把对称加密安全性差归咎于此不太妥（要强扯也┑(￣Д ￣)┍）。</p>\n</blockquote>\n<p> 对称加密的安全性低，问题在于两点： </p>\n<ul>\n<li>由于加密解密用同样的密钥，其密钥需要通信双方事先交换（或单向传递），密钥交换的过程存在泄漏的风险。</li>\n<li>由于密钥通信双方都知道，通信接收方可以泄漏发送方的密钥给其他人。 </li>\n</ul>\n<p>而以上两个问题非对称加密都解决了：</p>\n<ul>\n<li>加密解密需要一对密钥来完成，其中私钥是不公开也不需要事先传递的，所以泄漏的概率更小。 </li>\n<li><p>公钥加密的信息只能通过其对应的私钥来解密，私钥是属于通信双方中某一方且保密的，而公钥是公开的，所以不存在泄漏对方密钥的风险。 </p>\n<p>所以，在保证密钥不被泄漏的前提下对称加密和非对称加密是一样安全的。 但是，对称加密中，通信双方在事后有泄漏对方密钥的可能。 如果再加一个条件通信双方的发送者对每一个接收者使用不同的密钥，这样就能保证对称加密和非对称加密一样安全了。 但是这两点都比较难保证：1.传递密钥过程的安全性依赖传递环境。2.需要每个人都要有很多很多密钥，不同的接收方用不同的密钥，密钥难以保管。</p>\n</li>\n</ul>\n<p>所以这个时候非对称加密华丽登场了。<br>下面我们通过对具体的某一种非对称加密算法的学习来理解非对称加密的数学原理。这里我们选用应用最广泛的非对称加密算法之一：RSA加密算法。</p>\n<h3 id=\"RSA算法\"><a href=\"#RSA算法\" class=\"headerlink\" title=\"RSA算法\"></a>RSA算法</h3><p>RSA算法的数学基础是：欧拉定理，此处不做解释。公钥加密算法根据其所依据的数学难题一般分为三类：大整数因式分解问题类、离散对数问题类，椭圆曲线类。RSA属于大数分解类，也是最好理解的。</p>\n<p>下面直接介绍RSA算法的基础步骤；</p>\n<h4 id=\"1-生成公钥（PK）和私钥-SK\"><a href=\"#1-生成公钥（PK）和私钥-SK\" class=\"headerlink\" title=\"1. 生成公钥（PK）和私钥(SK)\"></a>1. 生成公钥（PK）和私钥(SK)</h4><ul>\n<li>(1) 随意选两个大的素数p和q，p不等于q</li>\n<li>(2) 将p、q两个素数相乘得到n，即n=pq</li>\n<li>(3) 计算n的欧拉函数φ(n):根据公式 φ(n)=(p-1)(q-1)</li>\n<li>(4) 选择一个整数e，作为密钥，使得e和φ(n)互质，且e &lt; φ(n)</li>\n<li><p>(5) 计算e对于φ(n)的模反元素d: 根据公式 ed mod φ(n)  = 1 ,计算出d的值，作为另一个密钥。<br>所谓”模反元素”就是指有一个整数d，可以使得ed被φ(n)除的余数为1。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">    ed ≡ 1 (mod φ(n)) ==&gt; </div><div class=\"line\">    ed - 1 = kφ(n)  //求解二元一次方程 k 从1带入试就行了 </div><div class=\"line\">思考： 一个整数A除以另一个整数B的余数是C， 已知B和C，A是唯一的吗？</div></pre></td></tr></table></figure>\n</li>\n<li><p>(6) 通过以上步骤计算出 n 、e 、d 3个数据，其中（n、e）作为公钥，（n、d）作为私钥（也可以互换）</p>\n</li>\n<li>(7) 生成公钥和私钥后就可以公开公钥了。</li>\n</ul>\n<h4 id=\"2-用公钥加密信息\"><a href=\"#2-用公钥加密信息\" class=\"headerlink\" title=\"2. 用公钥加密信息\"></a>2. 用公钥加密信息</h4><p>信息发送方收到接收方公钥PK后，就可以用PK对数据加密。加密步骤如下。 其中明文为M，加密后的密文为C，公钥（n,e）</p>\n<blockquote>\n<p>加密： M^e  mod n = C</p>\n</blockquote>\n<h4 id=\"3-用私钥解密信息\"><a href=\"#3-用私钥解密信息\" class=\"headerlink\" title=\"3. 用私钥解密信息\"></a>3. 用私钥解密信息</h4><p>接收方持有私钥（N，D）,在接收到密文C后，通过私钥对其解密，得到明文M：</p>\n<blockquote>\n<p>解密： C^d mod n = M  </p>\n</blockquote>\n<h3 id=\"RSA-安全性分析\"><a href=\"#RSA-安全性分析\" class=\"headerlink\" title=\"RSA 安全性分析\"></a>RSA 安全性分析</h3><p>通常到这里我们会有个疑问？ 公钥和私钥存在一定的数学关系， 公钥公开，那么有没有可能通过公钥推导出私钥呢？ 如果能那不就不安全了吗。 答案是：能，但是很难。<br>问题变成 能否在已知 n和e的前提下，推导出d ?</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">ed ≡ 1 (mod φ(n))   //等价于 ed mod φ(n)  = 1 </div><div class=\"line\">φ(n)=(p-1)(q-1)</div><div class=\"line\">n=pq</div></pre></td></tr></table></figure>\n<p>结论：如果n可以被因数分解，d就可以算出。<br>但是，大整数的因式分解是很困难的，目前除了暴力破解，还没有更好的有效方式。</p>\n<p>所以整数n的因式分解难度决定了RSA算法的可靠度。</p>\n<blockquote>\n<p> RSA可靠性就是建立在分解两个大素数乘积的十分困难上。</p>\n</blockquote>\n<p>这个难度是个什么概念呢？<a href=\"http://blog.csdn.net/woyaokaoyan/article/details/5169098\" target=\"_blank\" rel=\"external\">引用</a></p>\n<blockquote>\n<p>RSA算法的破解与密钥的长度有关，最常见的破解方法是因式分解，如果密钥的长度小于等于256位，一台较快的电脑可以在几个小时内成功分解其因子。位数越高因式分解所需时间也越长。1999年，一台Cray超级电脑用了5个月时间分解了512位长的密钥。而目前典型密钥长度是1028位。在512位RSA算法破解10年之后，一群研究人员报告(PDF)他们因式分解了768位RSA算法。他们是在2009年12月9日分解了768位、232数位数字的RSA-768密钥。分解一个768位RSA密钥所需时间是512位的数千倍，而1024位所需时间则是768位的一千多倍，因此在短时间内1024位仍然是安全的。研究人员表示1024位密钥预计也将会在10年内攻破，因此在未来三到四年内应逐步淘汰1024位RSA密钥。</p>\n</blockquote>\n<p>思考一下大整数n 因式分解为什么难？有多难？</p>\n<h3 id=\"RSA-算法实例\"><a href=\"#RSA-算法实例\" class=\"headerlink\" title=\"RSA 算法实例\"></a>RSA 算法实例</h3><h4 id=\"生成公钥私钥\"><a href=\"#生成公钥私钥\" class=\"headerlink\" title=\"生成公钥私钥\"></a>生成公钥私钥</h4><ul>\n<li>随机取大质数p=11，q=13，那n=11*13=143，φ(N)=(p-1)(q-1) = 130 </li>\n<li>取一个e=7，由 ed mod φ(n)  = 1 计算出d=103。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">公钥（n,e） 即 （143, 7）</div><div class=\"line\">私钥 (n,d) 即 （143, 103）</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"用公钥加密\"><a href=\"#用公钥加密\" class=\"headerlink\" title=\"用公钥加密\"></a>用公钥加密</h4><p>由于手工计算，为了使计算量小一点，我们将上面的公钥和私钥交换： 即公钥 （143, 103），私钥（143, 7）。取明文 m =2,加密过程如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">密文 c =  m^e mod n</div><div class=\"line\">      =  2^103 mod 143 </div><div class=\"line\">      = 10141204801825835211973625643008 mod 143 </div><div class=\"line\">      = 63</div></pre></td></tr></table></figure>\n<h4 id=\"用私钥解密\"><a href=\"#用私钥解密\" class=\"headerlink\" title=\"用私钥解密\"></a>用私钥解密</h4><p>收到密文c = 63,通过 私钥（143，7）进行解密，解密过程如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">明文  m = c^d mod n </div><div class=\"line\">         = 63^7 mod 143</div><div class=\"line\">         = 3938980639167 mod 143 </div><div class=\"line\">         = 2</div></pre></td></tr></table></figure>\n<p>至此，我们用RSA算法进行了一次加密解密，其实很简单，只是计算量可能会比较大。  </p>\n<p>常见的公钥加密算法除了RSA。还有ElGamal、背包算法、椭圆曲线加密算法（英语：Elliptic Curve Cryptography, ECC）等。下面我们说下非对称加密的应用。</p>\n<h3 id=\"非对称加密的应用\"><a href=\"#非对称加密的应用\" class=\"headerlink\" title=\"非对称加密的应用\"></a>非对称加密的应用</h3><p>先插入一个概念： <code>信息系统安全的基本属性</code>。</p>\n<blockquote>\n<p>信息系统安全的基本属性: 保密性、完整性、可用性、不可抵赖性。</p>\n</blockquote>\n<ul>\n<li>保密性：是应用系统的信息不被泄露给非授权的用户。常用保密技术：最小授权原则，信息加密等。</li>\n<li>完整性：完整性是信息未经授权不能进行改变的特性。完整性是一种面向信息的安全性。</li>\n<li>可用性： 可用性是应用系统面向用户的安全性能，不做赘述。</li>\n<li>不可抵赖性：不可抵赖性也称作不可否认性，在应用系统的信息交互过程中，确信参与者的真实同一性。即所有参与者都不可能否认或抵赖曾经完成的操作和承诺。利用信息源证据可以防止发信方不真实地否认已发送信息，利用递交接收证据可以防止收信方事后否认已经接收的信息。</li>\n</ul>\n<p>加密技术也是用来加强信息安全的，接下来说的几个非对称加密实际应用也是如此。<br>回归正题，接下来说非对称加密最广泛的应用之一：数字签名。</p>\n<h4 id=\"数字签名\"><a href=\"#数字签名\" class=\"headerlink\" title=\"数字签名\"></a>数字签名</h4><blockquote>\n<p>数字签名在ISO7498—2标准中定义为：“附加在数据单元上的一些数据，或是对数据单元所作的密码变换，这种数据和变换允许数据单元的接收者用以确认数据单元来源和数据单元的完整性，并保护数据，防止被人（例如接收者）进行伪造”</p>\n</blockquote>\n<p>首先搞清楚数字签名解决的是什么问题？ 然后看看什么是数字签名？最后分析下数字签名为什么能解决这些问题？</p>\n<h5 id=\"数字签名解决什么问题？\"><a href=\"#数字签名解决什么问题？\" class=\"headerlink\" title=\"数字签名解决什么问题？\"></a>数字签名解决什么问题？</h5><p>纸质书信或文件根据亲笔签名或印章来证明其真实性，及防抵赖。对应上述信息安全的 完整性和不可抵赖性。 而数字签名则可以看做是对在网络中传输的报文的签名，作用自然也是为了保证信息的完整性及不可抵赖性。 </p>\n<p>那下面我们看下数字签名是如何做到证明信息的完整性及防抵赖的？</p>\n<h5 id=\"数字签名的实现方法？\"><a href=\"#数字签名的实现方法？\" class=\"headerlink\" title=\"数字签名的实现方法？\"></a>数字签名的实现方法？</h5><p>建立在公钥密码技术上的数字签名方法有很多，有RSA签名、DSA签名和椭圆曲线数字签名算法（ECDSA）等等。下面对RSA签名进行详细分析。</p>\n<p>这里需要理解<a href=\"https://baike.baidu.com/item/%E5%93%88%E5%B8%8C%E5%80%BC\" target=\"_blank\" rel=\"external\">哈希-hash</a>的概念。简单说hash 就是计算机可以对任意内容计算出一个固定长度的值，且不会重复。</p>\n<p>直接看图：</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/d16dcf79ly1fobiaii5v2j22fk12812h.jpg\" alt=\"数字签名\"></p>\n<p>   （1）发送方采用某种摘要算法从报文中生成一个128位的散列值（称为报文摘要）；</p>\n<p>　　（2）发送方用RSA算法和自己的私钥对这个散列值进行加密，产生一个摘要密文，这就是发送方的数字签名；</p>\n<p>　　（3）将这个加密后的数字签名作为报文的附件和报文一起发送给接收方：</p>\n<p>　　（4）接收方从接收到的原始报文中采用相同的摘要算法计算出128位的散列值；</p>\n<p>　　（5）报文的接收方用RSA算法和发送方的公钥对报文附加的数字签名进行解密；</p>\n<p>　　（6）如果两个散列值相同，那么接收方就能确认报文是由发送方签名的。</p>\n<p>最常用的摘要算法叫做MD5（Message Digest 5）。MD5采用单向Hash函数将任意长度的“字节串”变换成一个128位的散列值，并且它是一个不可逆的字符串变换算法。</p>\n<h5 id=\"数字为什么能保证信息完整性及不可抵赖性？\"><a href=\"#数字为什么能保证信息完整性及不可抵赖性？\" class=\"headerlink\" title=\"数字为什么能保证信息完整性及不可抵赖性？\"></a>数字为什么能保证信息完整性及不可抵赖性？</h5><h6 id=\"信息的完整性\"><a href=\"#信息的完整性\" class=\"headerlink\" title=\"信息的完整性\"></a>信息的完整性</h6><p>如果报文在网络传输过程中被修改，接收方收到此报文后，使用相同的摘要算法将计算出不同的报文摘要，这就保证了接收方可以判断报文自签名后到收到为止，是否被修改过。</p>\n<h6 id=\"信息的不可抵赖性\"><a href=\"#信息的不可抵赖性\" class=\"headerlink\" title=\"信息的不可抵赖性\"></a>信息的不可抵赖性</h6><p>如果发送方A想让接收方误认为此报文是由发送方B签名发送的，由于发送方A不知道发送方B的私钥，所以接收方用发送方B的公钥对发送方A加密的报文摘要进行解密时，也将得出不同的报文摘要，这就保证了接收方可以判断报文是否是由指定的签名者发送。同时也可以看出，当两个散列值相同时，发送方B无法否认这个报文是他签名发送的。</p>\n<h5 id=\"关于数字签名的一点问题\"><a href=\"#关于数字签名的一点问题\" class=\"headerlink\" title=\"关于数字签名的一点问题\"></a>关于数字签名的一点问题</h5><p>关于数字签名就说完了。但有个疑问：传输过程中原文没有被加密吗？是的。上面是无保密机制的数字签名。具有保密机制的RSA签名机制自己看<a href=\"http://www.elecfans.com/baike/tongxingjishu/chungshuwang/20110710205779.html\" target=\"_blank\" rel=\"external\">这边文章</a>吧 。</p>\n<h4 id=\"数字证书\"><a href=\"#数字证书\" class=\"headerlink\" title=\"数字证书\"></a>数字证书</h4><p>关于上面数字签名有一个问题：信息接收方如何确认拿到的公钥就是期望的发送方的公钥？ </p>\n<p>举个例子：</p>\n<p>小红与小绿写信。 小绿写完信后 用自己的私钥对信件摘要生成 ‘数字签名’ 连同信件一块发给小红。 小红收到信件后用小绿的公钥解密信件里的数字签名得到信件摘要。 这个过程没有问题。</p>\n<p>但是有一天，第三者-小强出现了。小强偷偷将小红电脑里的小绿的公钥换成他自己的了，但此时小红还以为那是小绿的公钥。 因此，小强就可以冒充小绿，用自己的私钥对信件摘要进行 ‘数字签名’，发给小红。小红用小强掉包后的公钥对数字签名解密，还以为对方是小绿。</p>\n<p>后来小红感觉不对劲，他发现自己无法确定公钥是否真的是小绿的。于是她想了一个办法，让小绿找“证书中心”（certificate authority，简称CA） 为自己的公钥做认证。认证机构用自己的私钥对小绿的公钥和一些相关信息一起加密，生成‘数字证书’。</p>\n<p>小绿拿到‘数字证书’后，再给苏珊写信，只要在签名的同时，再附上数字证书就行了。<br>小红收信后，用CA的公钥解开数字证书，就可以拿到小绿的公钥了<br>，然后就能验证数字签名是否是小绿的。</p>\n<p>这里我们先大概知道CA是一个第三方机构，用来对个人身份认证的，而认证的形式就是‘数字证书’。<br>这个例子中忽略了一个关键细节，如何确定证书的真实性呢？ 接下来我们细细介绍。</p>\n<h4 id=\"https-实例分析\"><a href=\"#https-实例分析\" class=\"headerlink\" title=\"https 实例分析\"></a>https 实例分析</h4><p>https 是数字证书的应用之一。我们通过对https的从简介绍来理解数字证书。 </p>\n<h5 id=\"CA\"><a href=\"#CA\" class=\"headerlink\" title=\"CA\"></a>CA</h5><p>CA（certificate authority）证书授权中心。 受信任的第三方机构。 CA为每个使用公开密钥的用户发放一个数字证书。证书生成的过程可以认为就是CA用自己的私钥对公钥持有方的公钥及一些相关信息进行数字签名。</p>\n<blockquote>\n<p>数字证书是一个经证书授权中心（CA）数字签名的包含公钥拥有者信息以及公钥的文件。</p>\n</blockquote>\n<p>数字证书的作用是证明证书中列出的用户合法拥有证书中列出的公钥。</p>\n<h5 id=\"根证书\"><a href=\"#根证书\" class=\"headerlink\" title=\"根证书\"></a>根证书</h5><p>而CA的公钥叫做根证书。 这些根证书是预先被安装在浏览器里的,用来解密服务器的证书的。</p>\n<h5 id=\"https-访问\"><a href=\"#https-访问\" class=\"headerlink\" title=\"https 访问\"></a>https 访问</h5><p>通过https建立了一个安全 Web 事务之后，现代的浏览器都会自动获取所连接服务器的数字证书。如果服务器没有证书，安全连接就会失败。<br>浏览器预先安装了一些CA的根证书。浏览器用对应的根证书去解密网站服务器的数字证书获取到网站服务器的公钥。然后浏览器发送一个随机字符串给服务器，服务器用自己的私钥加密这个随机字符串后返回给浏览器，浏览器比较这个随机字符串是否和发出去的一样。 如果一样，则说明服务器的公钥和证书里的公钥一致，则证明服务器就是服务器。</p>\n<p>当然真实的https过程 比这个复杂很多，这里只是为了方便理解证书在非对称加密应用中的作用，忽略了很多技术细节。</p>\n<h3 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h3><p>静静的学习完了，我们再来说下时下最热的加密币。加密币里的交易安全基础就是非对称加密算法。就以币王BTC（比特币）来说。</p>\n<blockquote>\n<p>比特币钱包: 是用来存放私钥和公钥的，而不是存放币的。<br> <br>比特币地址: 钱包公钥的哈希值（更短，方便保存和传播），用来收币的。<br> <br>比特币使用了基于secp256k1椭圆曲线加密算法（非对称加密算法的一种）。<br> <br>一笔交易实质就是一个地址的一定数量的比特币转移到另一个地址。而交易过程安全则是由其非对称加密算法保障。</p>\n</blockquote>\n<p>最最后总结下本文：</p>\n<ul>\n<li>什么是非对称加密</li>\n<li>RSA算法的原理和用法</li>\n<li>什么是数字签名</li>\n<li>什么是数字证书及数字证书的作用</li>\n<li>又要上班了。</li>\n</ul>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p><a href=\"http://www.elecfans.com/baike/tongxingjishu/chungshuwang/20110710205779.html\" target=\"_blank\" rel=\"external\">数字签名技术原理介绍</a></p>\n","excerpt":"<h3 id=\"什么是非对称加密\"><a href=\"#什么是非对称加密\" class=\"headerlink\" title=\"什么是非对称加密\"></a>什么是非对称加密</h3><p><a href=\"https://zh.wikipedia.org/wiki/ %E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86\">维基百科</a>已经解释的非常清楚了（只看对公开密钥加密的解释这部分就好，其他部分说的并不好，引用如下）。</p>\n<blockquote>\n<p>公开密钥加密（英语：Public-key cryptography），也称为非对称加密（英语：asymmetric cryptography），是密码学的一种算法，它需要两个密钥，一个是公开密钥，另一个是私有密钥；一个用作加密的时候，另一个则用作解密。使用其中一个密钥把明文加密后所得的密文，只能用相对应的另一个密钥才能解密得到原本的明文；甚至连最初用来加密的密钥也不能用作解密。由于加密和解密需要两个不同的密钥，故被称为非对称加密；不同于加密和解密都使用同一个密钥的对称加密。虽然两个密钥在数学上相关，但如果知道了其中一个，并不能凭此计算出另外一个；因此其中一个可以公开，称为公钥，任意向外发布；不公开的密钥为私钥，必须由用户自行严格秘密保管，绝不通过任何途径向任何人提供，也不会透露给要通信的另一方，即使他被信任。</p>\n</blockquote>\n<p>维基上说的说的有点啰嗦，精简一下就是：</p>","more":"<blockquote>\n<p>加密解密通过一个秘钥对即公开密钥和私有密钥完成的。<br><br/>用公钥加密明文得到的密文，只能通过对应的私钥解密得到明文。<br>（类似私钥加密明文得到密的文，只能通过对应的公钥解密得到明文）<br><br/> 密钥对是数学相关的。</p>\n</blockquote>\n<p>在现实世界上可作比拟的例子是，一个传统保管箱，开门和关门都是使用同一把钥匙，这是对称加密；而一个公开的邮箱，投递口是任何人都可以寄信进去的，这可视为公钥；而只有邮箱主人拥有钥匙可以打开邮箱，这就视为私钥。这就是非对称加密。（以下说的公钥加密和对对称加密是一回事）</p>\n<h3 id=\"与对称加密的比较\"><a href=\"#与对称加密的比较\" class=\"headerlink\" title=\"与对称加密的比较\"></a>与对称加密的比较</h3><p>对称加密的问题在于通信双方要事先交换密钥，而事先传递密钥的过程 存在密钥泄露的风险。密钥一旦泄露，数据就不安全了。<br>而非对称加密，密钥对的私钥是保密的不需要事先传递或公开的，所以安全性更高。</p>\n<p>注意，看网上的博文很多人对这里的理解是不太透彻的: 认为对称加密的问题在于加解密用同样的密钥，所以导致对称加密不安全的。 </p>\n<blockquote>\n<p>加解密使用同样的密钥-这是对称加密的概念也是其形式，把对称加密安全性差归咎于此不太妥（要强扯也┑(￣Д ￣)┍）。</p>\n</blockquote>\n<p> 对称加密的安全性低，问题在于两点： </p>\n<ul>\n<li>由于加密解密用同样的密钥，其密钥需要通信双方事先交换（或单向传递），密钥交换的过程存在泄漏的风险。</li>\n<li>由于密钥通信双方都知道，通信接收方可以泄漏发送方的密钥给其他人。 </li>\n</ul>\n<p>而以上两个问题非对称加密都解决了：</p>\n<ul>\n<li>加密解密需要一对密钥来完成，其中私钥是不公开也不需要事先传递的，所以泄漏的概率更小。 </li>\n<li><p>公钥加密的信息只能通过其对应的私钥来解密，私钥是属于通信双方中某一方且保密的，而公钥是公开的，所以不存在泄漏对方密钥的风险。 </p>\n<p>所以，在保证密钥不被泄漏的前提下对称加密和非对称加密是一样安全的。 但是，对称加密中，通信双方在事后有泄漏对方密钥的可能。 如果再加一个条件通信双方的发送者对每一个接收者使用不同的密钥，这样就能保证对称加密和非对称加密一样安全了。 但是这两点都比较难保证：1.传递密钥过程的安全性依赖传递环境。2.需要每个人都要有很多很多密钥，不同的接收方用不同的密钥，密钥难以保管。</p>\n</li>\n</ul>\n<p>所以这个时候非对称加密华丽登场了。<br>下面我们通过对具体的某一种非对称加密算法的学习来理解非对称加密的数学原理。这里我们选用应用最广泛的非对称加密算法之一：RSA加密算法。</p>\n<h3 id=\"RSA算法\"><a href=\"#RSA算法\" class=\"headerlink\" title=\"RSA算法\"></a>RSA算法</h3><p>RSA算法的数学基础是：欧拉定理，此处不做解释。公钥加密算法根据其所依据的数学难题一般分为三类：大整数因式分解问题类、离散对数问题类，椭圆曲线类。RSA属于大数分解类，也是最好理解的。</p>\n<p>下面直接介绍RSA算法的基础步骤；</p>\n<h4 id=\"1-生成公钥（PK）和私钥-SK\"><a href=\"#1-生成公钥（PK）和私钥-SK\" class=\"headerlink\" title=\"1. 生成公钥（PK）和私钥(SK)\"></a>1. 生成公钥（PK）和私钥(SK)</h4><ul>\n<li>(1) 随意选两个大的素数p和q，p不等于q</li>\n<li>(2) 将p、q两个素数相乘得到n，即n=pq</li>\n<li>(3) 计算n的欧拉函数φ(n):根据公式 φ(n)=(p-1)(q-1)</li>\n<li>(4) 选择一个整数e，作为密钥，使得e和φ(n)互质，且e &lt; φ(n)</li>\n<li><p>(5) 计算e对于φ(n)的模反元素d: 根据公式 ed mod φ(n)  = 1 ,计算出d的值，作为另一个密钥。<br>所谓”模反元素”就是指有一个整数d，可以使得ed被φ(n)除的余数为1。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">    ed ≡ 1 (mod φ(n)) ==&gt; </div><div class=\"line\">    ed - 1 = kφ(n)  //求解二元一次方程 k 从1带入试就行了 </div><div class=\"line\">思考： 一个整数A除以另一个整数B的余数是C， 已知B和C，A是唯一的吗？</div></pre></td></tr></table></figure>\n</li>\n<li><p>(6) 通过以上步骤计算出 n 、e 、d 3个数据，其中（n、e）作为公钥，（n、d）作为私钥（也可以互换）</p>\n</li>\n<li>(7) 生成公钥和私钥后就可以公开公钥了。</li>\n</ul>\n<h4 id=\"2-用公钥加密信息\"><a href=\"#2-用公钥加密信息\" class=\"headerlink\" title=\"2. 用公钥加密信息\"></a>2. 用公钥加密信息</h4><p>信息发送方收到接收方公钥PK后，就可以用PK对数据加密。加密步骤如下。 其中明文为M，加密后的密文为C，公钥（n,e）</p>\n<blockquote>\n<p>加密： M^e  mod n = C</p>\n</blockquote>\n<h4 id=\"3-用私钥解密信息\"><a href=\"#3-用私钥解密信息\" class=\"headerlink\" title=\"3. 用私钥解密信息\"></a>3. 用私钥解密信息</h4><p>接收方持有私钥（N，D）,在接收到密文C后，通过私钥对其解密，得到明文M：</p>\n<blockquote>\n<p>解密： C^d mod n = M  </p>\n</blockquote>\n<h3 id=\"RSA-安全性分析\"><a href=\"#RSA-安全性分析\" class=\"headerlink\" title=\"RSA 安全性分析\"></a>RSA 安全性分析</h3><p>通常到这里我们会有个疑问？ 公钥和私钥存在一定的数学关系， 公钥公开，那么有没有可能通过公钥推导出私钥呢？ 如果能那不就不安全了吗。 答案是：能，但是很难。<br>问题变成 能否在已知 n和e的前提下，推导出d ?</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">ed ≡ 1 (mod φ(n))   //等价于 ed mod φ(n)  = 1 </div><div class=\"line\">φ(n)=(p-1)(q-1)</div><div class=\"line\">n=pq</div></pre></td></tr></table></figure>\n<p>结论：如果n可以被因数分解，d就可以算出。<br>但是，大整数的因式分解是很困难的，目前除了暴力破解，还没有更好的有效方式。</p>\n<p>所以整数n的因式分解难度决定了RSA算法的可靠度。</p>\n<blockquote>\n<p> RSA可靠性就是建立在分解两个大素数乘积的十分困难上。</p>\n</blockquote>\n<p>这个难度是个什么概念呢？<a href=\"http://blog.csdn.net/woyaokaoyan/article/details/5169098\">引用</a></p>\n<blockquote>\n<p>RSA算法的破解与密钥的长度有关，最常见的破解方法是因式分解，如果密钥的长度小于等于256位，一台较快的电脑可以在几个小时内成功分解其因子。位数越高因式分解所需时间也越长。1999年，一台Cray超级电脑用了5个月时间分解了512位长的密钥。而目前典型密钥长度是1028位。在512位RSA算法破解10年之后，一群研究人员报告(PDF)他们因式分解了768位RSA算法。他们是在2009年12月9日分解了768位、232数位数字的RSA-768密钥。分解一个768位RSA密钥所需时间是512位的数千倍，而1024位所需时间则是768位的一千多倍，因此在短时间内1024位仍然是安全的。研究人员表示1024位密钥预计也将会在10年内攻破，因此在未来三到四年内应逐步淘汰1024位RSA密钥。</p>\n</blockquote>\n<p>思考一下大整数n 因式分解为什么难？有多难？</p>\n<h3 id=\"RSA-算法实例\"><a href=\"#RSA-算法实例\" class=\"headerlink\" title=\"RSA 算法实例\"></a>RSA 算法实例</h3><h4 id=\"生成公钥私钥\"><a href=\"#生成公钥私钥\" class=\"headerlink\" title=\"生成公钥私钥\"></a>生成公钥私钥</h4><ul>\n<li>随机取大质数p=11，q=13，那n=11*13=143，φ(N)=(p-1)(q-1) = 130 </li>\n<li>取一个e=7，由 ed mod φ(n)  = 1 计算出d=103。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">公钥（n,e） 即 （143, 7）</div><div class=\"line\">私钥 (n,d) 即 （143, 103）</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"用公钥加密\"><a href=\"#用公钥加密\" class=\"headerlink\" title=\"用公钥加密\"></a>用公钥加密</h4><p>由于手工计算，为了使计算量小一点，我们将上面的公钥和私钥交换： 即公钥 （143, 103），私钥（143, 7）。取明文 m =2,加密过程如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">密文 c =  m^e mod n</div><div class=\"line\">      =  2^103 mod 143 </div><div class=\"line\">      = 10141204801825835211973625643008 mod 143 </div><div class=\"line\">      = 63</div></pre></td></tr></table></figure>\n<h4 id=\"用私钥解密\"><a href=\"#用私钥解密\" class=\"headerlink\" title=\"用私钥解密\"></a>用私钥解密</h4><p>收到密文c = 63,通过 私钥（143，7）进行解密，解密过程如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">明文  m = c^d mod n </div><div class=\"line\">         = 63^7 mod 143</div><div class=\"line\">         = 3938980639167 mod 143 </div><div class=\"line\">         = 2</div></pre></td></tr></table></figure>\n<p>至此，我们用RSA算法进行了一次加密解密，其实很简单，只是计算量可能会比较大。  </p>\n<p>常见的公钥加密算法除了RSA。还有ElGamal、背包算法、椭圆曲线加密算法（英语：Elliptic Curve Cryptography, ECC）等。下面我们说下非对称加密的应用。</p>\n<h3 id=\"非对称加密的应用\"><a href=\"#非对称加密的应用\" class=\"headerlink\" title=\"非对称加密的应用\"></a>非对称加密的应用</h3><p>先插入一个概念： <code>信息系统安全的基本属性</code>。</p>\n<blockquote>\n<p>信息系统安全的基本属性: 保密性、完整性、可用性、不可抵赖性。</p>\n</blockquote>\n<ul>\n<li>保密性：是应用系统的信息不被泄露给非授权的用户。常用保密技术：最小授权原则，信息加密等。</li>\n<li>完整性：完整性是信息未经授权不能进行改变的特性。完整性是一种面向信息的安全性。</li>\n<li>可用性： 可用性是应用系统面向用户的安全性能，不做赘述。</li>\n<li>不可抵赖性：不可抵赖性也称作不可否认性，在应用系统的信息交互过程中，确信参与者的真实同一性。即所有参与者都不可能否认或抵赖曾经完成的操作和承诺。利用信息源证据可以防止发信方不真实地否认已发送信息，利用递交接收证据可以防止收信方事后否认已经接收的信息。</li>\n</ul>\n<p>加密技术也是用来加强信息安全的，接下来说的几个非对称加密实际应用也是如此。<br>回归正题，接下来说非对称加密最广泛的应用之一：数字签名。</p>\n<h4 id=\"数字签名\"><a href=\"#数字签名\" class=\"headerlink\" title=\"数字签名\"></a>数字签名</h4><blockquote>\n<p>数字签名在ISO7498—2标准中定义为：“附加在数据单元上的一些数据，或是对数据单元所作的密码变换，这种数据和变换允许数据单元的接收者用以确认数据单元来源和数据单元的完整性，并保护数据，防止被人（例如接收者）进行伪造”</p>\n</blockquote>\n<p>首先搞清楚数字签名解决的是什么问题？ 然后看看什么是数字签名？最后分析下数字签名为什么能解决这些问题？</p>\n<h5 id=\"数字签名解决什么问题？\"><a href=\"#数字签名解决什么问题？\" class=\"headerlink\" title=\"数字签名解决什么问题？\"></a>数字签名解决什么问题？</h5><p>纸质书信或文件根据亲笔签名或印章来证明其真实性，及防抵赖。对应上述信息安全的 完整性和不可抵赖性。 而数字签名则可以看做是对在网络中传输的报文的签名，作用自然也是为了保证信息的完整性及不可抵赖性。 </p>\n<p>那下面我们看下数字签名是如何做到证明信息的完整性及防抵赖的？</p>\n<h5 id=\"数字签名的实现方法？\"><a href=\"#数字签名的实现方法？\" class=\"headerlink\" title=\"数字签名的实现方法？\"></a>数字签名的实现方法？</h5><p>建立在公钥密码技术上的数字签名方法有很多，有RSA签名、DSA签名和椭圆曲线数字签名算法（ECDSA）等等。下面对RSA签名进行详细分析。</p>\n<p>这里需要理解<a href=\"https://baike.baidu.com/item/%E5%93%88%E5%B8%8C%E5%80%BC\">哈希-hash</a>的概念。简单说hash 就是计算机可以对任意内容计算出一个固定长度的值，且不会重复。</p>\n<p>直接看图：</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/d16dcf79ly1fobiaii5v2j22fk12812h.jpg\" alt=\"数字签名\"></p>\n<p>   （1）发送方采用某种摘要算法从报文中生成一个128位的散列值（称为报文摘要）；</p>\n<p>　　（2）发送方用RSA算法和自己的私钥对这个散列值进行加密，产生一个摘要密文，这就是发送方的数字签名；</p>\n<p>　　（3）将这个加密后的数字签名作为报文的附件和报文一起发送给接收方：</p>\n<p>　　（4）接收方从接收到的原始报文中采用相同的摘要算法计算出128位的散列值；</p>\n<p>　　（5）报文的接收方用RSA算法和发送方的公钥对报文附加的数字签名进行解密；</p>\n<p>　　（6）如果两个散列值相同，那么接收方就能确认报文是由发送方签名的。</p>\n<p>最常用的摘要算法叫做MD5（Message Digest 5）。MD5采用单向Hash函数将任意长度的“字节串”变换成一个128位的散列值，并且它是一个不可逆的字符串变换算法。</p>\n<h5 id=\"数字为什么能保证信息完整性及不可抵赖性？\"><a href=\"#数字为什么能保证信息完整性及不可抵赖性？\" class=\"headerlink\" title=\"数字为什么能保证信息完整性及不可抵赖性？\"></a>数字为什么能保证信息完整性及不可抵赖性？</h5><h6 id=\"信息的完整性\"><a href=\"#信息的完整性\" class=\"headerlink\" title=\"信息的完整性\"></a>信息的完整性</h6><p>如果报文在网络传输过程中被修改，接收方收到此报文后，使用相同的摘要算法将计算出不同的报文摘要，这就保证了接收方可以判断报文自签名后到收到为止，是否被修改过。</p>\n<h6 id=\"信息的不可抵赖性\"><a href=\"#信息的不可抵赖性\" class=\"headerlink\" title=\"信息的不可抵赖性\"></a>信息的不可抵赖性</h6><p>如果发送方A想让接收方误认为此报文是由发送方B签名发送的，由于发送方A不知道发送方B的私钥，所以接收方用发送方B的公钥对发送方A加密的报文摘要进行解密时，也将得出不同的报文摘要，这就保证了接收方可以判断报文是否是由指定的签名者发送。同时也可以看出，当两个散列值相同时，发送方B无法否认这个报文是他签名发送的。</p>\n<h5 id=\"关于数字签名的一点问题\"><a href=\"#关于数字签名的一点问题\" class=\"headerlink\" title=\"关于数字签名的一点问题\"></a>关于数字签名的一点问题</h5><p>关于数字签名就说完了。但有个疑问：传输过程中原文没有被加密吗？是的。上面是无保密机制的数字签名。具有保密机制的RSA签名机制自己看<a href=\"http://www.elecfans.com/baike/tongxingjishu/chungshuwang/20110710205779.html\">这边文章</a>吧 。</p>\n<h4 id=\"数字证书\"><a href=\"#数字证书\" class=\"headerlink\" title=\"数字证书\"></a>数字证书</h4><p>关于上面数字签名有一个问题：信息接收方如何确认拿到的公钥就是期望的发送方的公钥？ </p>\n<p>举个例子：</p>\n<p>小红与小绿写信。 小绿写完信后 用自己的私钥对信件摘要生成 ‘数字签名’ 连同信件一块发给小红。 小红收到信件后用小绿的公钥解密信件里的数字签名得到信件摘要。 这个过程没有问题。</p>\n<p>但是有一天，第三者-小强出现了。小强偷偷将小红电脑里的小绿的公钥换成他自己的了，但此时小红还以为那是小绿的公钥。 因此，小强就可以冒充小绿，用自己的私钥对信件摘要进行 ‘数字签名’，发给小红。小红用小强掉包后的公钥对数字签名解密，还以为对方是小绿。</p>\n<p>后来小红感觉不对劲，他发现自己无法确定公钥是否真的是小绿的。于是她想了一个办法，让小绿找“证书中心”（certificate authority，简称CA） 为自己的公钥做认证。认证机构用自己的私钥对小绿的公钥和一些相关信息一起加密，生成‘数字证书’。</p>\n<p>小绿拿到‘数字证书’后，再给苏珊写信，只要在签名的同时，再附上数字证书就行了。<br>小红收信后，用CA的公钥解开数字证书，就可以拿到小绿的公钥了<br>，然后就能验证数字签名是否是小绿的。</p>\n<p>这里我们先大概知道CA是一个第三方机构，用来对个人身份认证的，而认证的形式就是‘数字证书’。<br>这个例子中忽略了一个关键细节，如何确定证书的真实性呢？ 接下来我们细细介绍。</p>\n<h4 id=\"https-实例分析\"><a href=\"#https-实例分析\" class=\"headerlink\" title=\"https 实例分析\"></a>https 实例分析</h4><p>https 是数字证书的应用之一。我们通过对https的从简介绍来理解数字证书。 </p>\n<h5 id=\"CA\"><a href=\"#CA\" class=\"headerlink\" title=\"CA\"></a>CA</h5><p>CA（certificate authority）证书授权中心。 受信任的第三方机构。 CA为每个使用公开密钥的用户发放一个数字证书。证书生成的过程可以认为就是CA用自己的私钥对公钥持有方的公钥及一些相关信息进行数字签名。</p>\n<blockquote>\n<p>数字证书是一个经证书授权中心（CA）数字签名的包含公钥拥有者信息以及公钥的文件。</p>\n</blockquote>\n<p>数字证书的作用是证明证书中列出的用户合法拥有证书中列出的公钥。</p>\n<h5 id=\"根证书\"><a href=\"#根证书\" class=\"headerlink\" title=\"根证书\"></a>根证书</h5><p>而CA的公钥叫做根证书。 这些根证书是预先被安装在浏览器里的,用来解密服务器的证书的。</p>\n<h5 id=\"https-访问\"><a href=\"#https-访问\" class=\"headerlink\" title=\"https 访问\"></a>https 访问</h5><p>通过https建立了一个安全 Web 事务之后，现代的浏览器都会自动获取所连接服务器的数字证书。如果服务器没有证书，安全连接就会失败。<br>浏览器预先安装了一些CA的根证书。浏览器用对应的根证书去解密网站服务器的数字证书获取到网站服务器的公钥。然后浏览器发送一个随机字符串给服务器，服务器用自己的私钥加密这个随机字符串后返回给浏览器，浏览器比较这个随机字符串是否和发出去的一样。 如果一样，则说明服务器的公钥和证书里的公钥一致，则证明服务器就是服务器。</p>\n<p>当然真实的https过程 比这个复杂很多，这里只是为了方便理解证书在非对称加密应用中的作用，忽略了很多技术细节。</p>\n<h3 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h3><p>静静的学习完了，我们再来说下时下最热的加密币。加密币里的交易安全基础就是非对称加密算法。就以币王BTC（比特币）来说。</p>\n<blockquote>\n<p>比特币钱包: 是用来存放私钥和公钥的，而不是存放币的。<br> <br/>比特币地址: 钱包公钥的哈希值（更短，方便保存和传播），用来收币的。<br> <br/>比特币使用了基于secp256k1椭圆曲线加密算法（非对称加密算法的一种）。<br> <br/>一笔交易实质就是一个地址的一定数量的比特币转移到另一个地址。而交易过程安全则是由其非对称加密算法保障。</p>\n</blockquote>\n<p>最最后总结下本文：</p>\n<ul>\n<li>什么是非对称加密</li>\n<li>RSA算法的原理和用法</li>\n<li>什么是数字签名</li>\n<li>什么是数字证书及数字证书的作用</li>\n<li>又要上班了。</li>\n</ul>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p><a href=\"http://www.elecfans.com/baike/tongxingjishu/chungshuwang/20110710205779.html\">数字签名技术原理介绍</a></p>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjelnshcn00063gfffcept66t","category_id":"cjelnshch00033gff3c5bwmnc","_id":"cjelnshcv000b3gffytego4s4"},{"post_id":"cjelnshc400003gffne33t2i5","category_id":"cjelnshch00033gff3c5bwmnc","_id":"cjelnshcy000f3gffhb0vdqw1"},{"post_id":"cjelnshcc00023gff0dtg0bw6","category_id":"cjelnshch00033gff3c5bwmnc","_id":"cjelnshd0000h3gffc12rc9tw"},{"post_id":"cjelnshck00053gffub27v4r5","category_id":"cjelnshcx000d3gfffq7bdym9","_id":"cjelnshd5000o3gffe3x79z86"},{"post_id":"cjelnshco00073gffj7culcpj","category_id":"cjelnshd1000j3gffk2pdoxs2","_id":"cjelnshda000u3gffx13505qq"},{"post_id":"cjelnshcw000c3gffwmx3n5ng","category_id":"cjelnshch00033gff3c5bwmnc","_id":"cjelnshdb00113gffgzgqzg8h"},{"post_id":"cjelnshcw000c3gffwmx3n5ng","category_id":"cjelnshda000v3gff0jzq4juk","_id":"cjelnshdc00143gffpa5pvwx5"},{"post_id":"cjelnshcz000g3gffhuk6txj6","category_id":"cjelnshdb000z3gffbue7r4c1","_id":"cjelnshdc00163gffxowmj8pp"},{"post_id":"cjelnshd0000i3gffkdb7p2y2","category_id":"cjelnshdb000z3gffbue7r4c1","_id":"cjelnshdd001a3gffn40rfqa8"},{"post_id":"cjelnshd2000l3gffrtq7g33a","category_id":"cjelnshdc00183gffn007or1z","_id":"cjelnshdf001e3gffaztcqrb9"},{"post_id":"cjelnshd4000n3gfflx777dyu","category_id":"cjelnshdd001b3gff37lejijy","_id":"cjelnshdh001j3gffwrpo27e8"},{"post_id":"cjelnshcs000a3gffqx24ny4q","category_id":"cjelnshd6000q3gff5254db7k","_id":"cjelnshdh001l3gffnae54s5i"},{"post_id":"cjelnshcs000a3gffqx24ny4q","category_id":"cjelnshdf001g3gffkrdoqeks","_id":"cjelnshdi001n3gff42x9rfty"}],"PostTag":[{"post_id":"cjelnshc400003gffne33t2i5","tag_id":"cjelnshcj00043gffc70yzj8b","_id":"cjelnshd3000m3gffquaacscu"},{"post_id":"cjelnshc400003gffne33t2i5","tag_id":"cjelnshcq00093gff12yxq90a","_id":"cjelnshd6000p3gffeucqarph"},{"post_id":"cjelnshc400003gffne33t2i5","tag_id":"cjelnshcy000e3gffi6mt9yxl","_id":"cjelnshd9000t3gff1kbd15fs"},{"post_id":"cjelnshcc00023gff0dtg0bw6","tag_id":"cjelnshd1000k3gffx3r7aqhg","_id":"cjelnshdb000x3gffm2q181uh"},{"post_id":"cjelnshcc00023gff0dtg0bw6","tag_id":"cjelnshcy000e3gffi6mt9yxl","_id":"cjelnshdb000y3gffbhgeg8dj"},{"post_id":"cjelnshck00053gffub27v4r5","tag_id":"cjelnshda000w3gffad2720vl","_id":"cjelnshdc00153gffz211qqs2"},{"post_id":"cjelnshck00053gffub27v4r5","tag_id":"cjelnshdb00103gffcq77142x","_id":"cjelnshdc00173gffb1gc5t75"},{"post_id":"cjelnshcn00063gfffcept66t","tag_id":"cjelnshdc00133gffk8oq7vyt","_id":"cjelnshde001d3gff88bsqohw"},{"post_id":"cjelnshcn00063gfffcept66t","tag_id":"cjelnshdd00193gff2wp8ihax","_id":"cjelnshdf001f3gffcepzj3bk"},{"post_id":"cjelnshco00073gffj7culcpj","tag_id":"cjelnshde001c3gffgc18dck1","_id":"cjelnshdg001i3gffl9ga675f"},{"post_id":"cjelnshcs000a3gffqx24ny4q","tag_id":"cjelnshdf001h3gffol9usebr","_id":"cjelnshdi001o3gff7ir0x1li"},{"post_id":"cjelnshcs000a3gffqx24ny4q","tag_id":"cjelnshdh001k3gffs4rz7sc1","_id":"cjelnshdj001p3gfff8amao66"},{"post_id":"cjelnshcw000c3gffwmx3n5ng","tag_id":"cjelnshdh001m3gff0qqeq7p8","_id":"cjelnshdl001s3gffj6h8w8rj"},{"post_id":"cjelnshcw000c3gffwmx3n5ng","tag_id":"cjelnshdk001q3gff1q9tap45","_id":"cjelnshdl001t3gffurankj0t"},{"post_id":"cjelnshcz000g3gffhuk6txj6","tag_id":"cjelnshdk001r3gff4bf7aebb","_id":"cjelnshdn001w3gff0vgi9rj3"},{"post_id":"cjelnshcz000g3gffhuk6txj6","tag_id":"cjelnshdl001u3gffjnkf9sh8","_id":"cjelnshdn001x3gfftedqfme0"},{"post_id":"cjelnshd0000i3gffkdb7p2y2","tag_id":"cjelnshdn001v3gff1qli2ir8","_id":"cjelnshdq00203gffrei6bzg3"},{"post_id":"cjelnshd0000i3gffkdb7p2y2","tag_id":"cjelnshdl001u3gffjnkf9sh8","_id":"cjelnshdq00213gffu20fo7ie"},{"post_id":"cjelnshd2000l3gffrtq7g33a","tag_id":"cjelnshdp001z3gffe9ep436o","_id":"cjelnshds00253gffjul310zo"},{"post_id":"cjelnshd2000l3gffrtq7g33a","tag_id":"cjelnshdq00223gffzruoywj1","_id":"cjelnshds00263gff9so39r8q"},{"post_id":"cjelnshd2000l3gffrtq7g33a","tag_id":"cjelnshdr00233gff218xl99m","_id":"cjelnshds00283gffymk6aub4"},{"post_id":"cjelnshd4000n3gfflx777dyu","tag_id":"cjelnshdr00243gffwv11tfay","_id":"cjelnshdt002a3gffv3kmy3qp"},{"post_id":"cjelnshd4000n3gfflx777dyu","tag_id":"cjelnshds00273gffxgl84v5a","_id":"cjelnshdu002b3gffdyqx8lio"},{"post_id":"cjelnshd8000s3gff05yujqx0","tag_id":"cjelnshds00293gffai0af8bb","_id":"cjelnshdv002e3gfffc3y17b3"},{"post_id":"cjelnshd8000s3gff05yujqx0","tag_id":"cjelnshdu002c3gffv4asfohy","_id":"cjelnshdv002f3gffkjbs73hf"},{"post_id":"cjelnshd8000s3gff05yujqx0","tag_id":"cjelnshdu002d3gffy66p5us6","_id":"cjelnshdv002g3gffjwa3xf0g"}],"Tag":[{"name":"作用域链","_id":"cjelnshcj00043gffc70yzj8b"},{"name":"执行期上下文","_id":"cjelnshcq00093gff12yxq90a"},{"name":"javascript核心","_id":"cjelnshcy000e3gffi6mt9yxl"},{"name":"this","_id":"cjelnshd1000k3gffx3r7aqhg"},{"name":"博客","_id":"cjelnshda000w3gffad2720vl"},{"name":"hexo","_id":"cjelnshdb00103gffcq77142x"},{"name":"函数节流（throttle）","_id":"cjelnshdc00133gffk8oq7vyt"},{"name":"函数防抖（debounce）","_id":"cjelnshdd00193gff2wp8ihax"},{"name":"深度工作","_id":"cjelnshde001c3gffgc18dck1"},{"name":"MVC","_id":"cjelnshdf001h3gffol9usebr"},{"name":"MVP","_id":"cjelnshdh001k3gffs4rz7sc1"},{"name":"JSX","_id":"cjelnshdh001m3gff0qqeq7p8"},{"name":"React","_id":"cjelnshdk001q3gff1q9tap45"},{"name":"flux","_id":"cjelnshdk001r3gff4bf7aebb"},{"name":"数据流","_id":"cjelnshdl001u3gffjnkf9sh8"},{"name":"redux","_id":"cjelnshdn001v3gff1qli2ir8"},{"name":"设计模式","_id":"cjelnshdp001z3gffe9ep436o"},{"name":"工厂模式","_id":"cjelnshdq00223gffzruoywj1"},{"name":"创建型模式","_id":"cjelnshdr00233gff218xl99m"},{"name":"随笔","_id":"cjelnshdr00243gffwv11tfay"},{"name":"游戏","_id":"cjelnshds00273gffxgl84v5a"},{"name":"RSA","_id":"cjelnshds00293gffai0af8bb"},{"name":"非对称加密","_id":"cjelnshdu002c3gffv4asfohy"},{"name":"数字签名","_id":"cjelnshdu002d3gffy66p5us6"}]}}