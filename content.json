{"meta":{"title":"瞧，这个人","subtitle":null,"description":"世界你好","author":"foreverwang","url":"https://foreverwang.github.io","root":"/"},"pages":[{"title":"分了个类","date":"2017-01-23T16:46:09.000Z","updated":"2020-06-21T11:08:05.119Z","comments":true,"path":"categories/index.html","permalink":"https://foreverwang.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-03-15T17:20:21.000Z","updated":"2020-06-21T11:08:05.119Z","comments":true,"path":"tags/index.html","permalink":"https://foreverwang.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"事件循环","slug":"事件循环","date":"2019-09-01T04:20:48.000Z","updated":"2020-06-21T11:08:05.115Z","comments":true,"path":"2019/09/01/事件循环/","link":"","permalink":"https://foreverwang.github.io/2019/09/01/事件循环/","excerpt":"说在前头：事件循环和js语言本身没有关系，和js引擎也没有关系。 先看一个题目： setTimeout(()=&gt;{ console.log(1); },10) for (let i=0; i&lt;100000000; i++) {} console.log(2); setTimeout(()=&gt;{ console.log(3); },0) Promise.resolve().then(function(){ console.log(4); }) console.log(5); 答案是 2 5 4 1 3 或 2 5 4 3 1。 这取决于这个for循环执行耗时。","text":"说在前头：事件循环和js语言本身没有关系，和js引擎也没有关系。 先看一个题目： setTimeout(()=&gt;{ console.log(1); },10) for (let i=0; i&lt;100000000; i++) {} console.log(2); setTimeout(()=&gt;{ console.log(3); },0) Promise.resolve().then(function(){ console.log(4); }) console.log(5); 答案是 2 5 4 1 3 或 2 5 4 3 1。 这取决于这个for循环执行耗时。 先思考一个问题，我们的javascript代码是如何在浏览器或者是Node环境跑起来的。真正执行javascript代码的是谁？保证我们代码有序执行的都有哪些参与者？ 执行javascript代码的是javascript引擎(Engine)，比如chrome里是V8，safari里是javascriptCore。要想执行javascript代码只有引擎是不行的，还得有宿主环境,也叫javascript运行时环境(Runtime)，比如浏览器或者Node。宿主给引擎一段js代码，引擎才开始执行js代码。 在浏览器里js代码的执行是多个角色参与，看图： Call stack （js引擎内） Web API (浏览器提供) Callback queue (事件队列对应的回调队列) 事件循环所有的宿主环境都有一个共同点就是都实现了一个叫 Event Loop(事件循环)的内置机制。它来通过多次调用javascript引擎来调度程序中多个模块的执行顺序。 Event Loop有一个简单的工作机制——就是去监视Call Stack和Callback Queue。 如果调用栈为空，它将从Callback队列中取出第一个事件回调，并将其推送到调用栈，调用栈开始顺序执行代码。而Callback Queue里的回调是宿主环境在一定的时机推入的。 现在我们看开头那断代码，这里我们先不考虑Promise： // 标号1 setTimeout(()=&gt;{ console.log(1); },10) //标号5 for (let i=0; i&lt;100000000; i++) {} //标号2 console.log(2); //标号3 setTimeout(()=&gt;{ console.log(3); },0) //标号4 console.log(5); 当宿主环境将这段代码给到js引擎时，引擎创建一个常驻内存的调用栈开始顺序执行代码。这段代码可能是一段script内的代码也可能是一个模块代码，我们暂且将其用一个名为main函数指代。最初调用栈的栈里只有一个main。随着代码顺序执行： 标号1的setTimeout函数入栈，执行完出栈 标号2的console.log函数入栈，执行完出栈 标号3的setTimeout函数入栈，执行完出栈 标号4console.log函数入栈，执行完出栈 此时main也执行完了，出栈，调用栈空了 注：这里说的函数入栈即所得函数上下文入栈。 接下来关键Event Loop该登场了，Event Loop检测到调用栈空了，说明当前迭代已经执行完毕，就会去Callback Queue 取队首的事件回调，并将其推入调用栈，下一轮迭代就开始了。 到这里我们好像忽略了一件事情，Callback Queue 里有东西吗？有的话是什么时候有的呢？我们再看第一次迭代中的步骤1，setTimeout函数是浏览器提供的api, js引擎告诉浏览器10ms后给我做点事(传入的回调)，此时浏览器就开启了一个定时器，并保存下这个回调函数，定时器时间到了后，将这个回调推入Callback Queue。 所以说标号5(示例代码中， 下同)的for循环执行耗时，会影响标号1和标号3两个setTimeout的回调被推入Callback Queue的顺序，进而影响其被执行的顺序。 如果在执行标号3的setTimeout时，标号1的setTimeout时间已到，则标号1的回调会先于标号3的回调被推入Callback Queue。所以在第二次迭代时，从Callback Queue队首取到的是标号1的回调，接下来的执行过程： console.log(1) 入栈，执行完出栈 调用栈为空，Event Loop从Callback Queue取出此时队首的事件回调并推入调用栈（开启时间循环第三次迭代） console.log(3) 入栈，执行完出栈 此时调用栈为空，Callback Queue也为空，js引擎就可以先休息会了。 我在mbp的chrome 运行上面代码打印顺序是： 2 5 1 3 我们可以把for循环的次数调小至100，再次查看打印顺序，来验证上面的论证。此时的打印顺序是： 2 5 3 1 宏任务和微任务在上面例子中的setTimeout是由浏览器这个宿主提供的api,这个异步任务也是有其发起的。 宿主环境发起的任务叫宏任务。 在ES5及更早版本，javascript本身是没有异步执行代码的能力的。宿主环境把一段代码给js引擎，引擎就把这段代码顺次执行了，而这个任务就是宿主发起的任务。ES6引入了Promise,这使得不用依赖宿主环境，javascript引擎自己也可以发起任务了。 javascript引擎发起的任务叫微任务(对应ES规范里的job) 微任务通常来说就是需要在当前宏任务执行结束后立即执行的任务。所有的微任务会在下一个宏任务执行之前执行完毕。 我们再看开头的带有promise的例子，这里我们简化一下： // 标号1 setTimeout(()=&gt;{ console.log(3); },0) // 标号2 Promise.resolve().then(function(){ console.log(4); }) // 标号3 console.log(5); 标号1的timeout入栈，执行完毕出栈；同时浏览器开一个定时器，立即将该回调函数推入Callback Queue 标号2的promise入栈，执行完毕出栈；同时javascript引擎发起了一个微任务，promise的then回调会被推入本轮迭代的队尾。 标号3的console.log(5)入栈，执行完毕出栈 关键的一步来了，正常是本轮迭代已经执行完毕，栈也为空了，但是本轮迭代还有微任务的回调队列即标号2的promise的then回调，上面我们说了微任务永远会在本轮迭代完成，故先执行console.log(4); 此时本轮迭代的调用栈真的为空了，Event Loop从Callback Queue队首去取回调：console.log(3); 故打印顺序： 5 4 3 可以看到一个宏观任务可能会包含一个或多个微观任务，而我们的任务队列可以看做是一个二维数组：第一纬是宏观任务，第二维则是每一个宏观任务包含的微观任务。 参考资料 ES规范:Jobs and Job Queues H5规范:event-loops event-loops可视化学习工具 参考文章 javascriptConf 2014演讲视频","categories":[{"name":"javascript","slug":"javascript","permalink":"https://foreverwang.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://foreverwang.github.io/tags/javascript/"},{"name":"事件循环","slug":"事件循环","permalink":"https://foreverwang.github.io/tags/事件循环/"},{"name":"异步","slug":"异步","permalink":"https://foreverwang.github.io/tags/异步/"}]},{"title":"你真的懂vue的数据绑定原理了吗","slug":"你真的懂vue的数据绑定原理了吗","date":"2019-07-05T08:21:50.000Z","updated":"2020-06-21T11:08:05.116Z","comments":true,"path":"2019/07/05/你真的懂vue的数据绑定原理了吗/","link":"","permalink":"https://foreverwang.github.io/2019/07/05/你真的懂vue的数据绑定原理了吗/","excerpt":"前言数据绑定有很多种实现方案，vue中的实现只是众多实现中的一种。都知道vue数据绑定是通过Object.defineProperty() 实现，但是在面试过程中，真正清楚vue数据绑定具体实现的不多，而网上各种vue原理解析的文章很多是二手三手的解读，千篇一律很多关键点都没有说到，本文主要是整理下自己的理解，并试图让不完全懂vue数据绑定原理实现的人看了能彻底懂。 数据绑定最终达到的效果先了解数据绑定绑定的是什么？是UI。数据绑定要达到的效果就是：UI渲染的时候使用数据对象(data)里的数据初始化UI，当UI中使用到的数据变化时，这个数据对应的UI会同步更新，而无需开发者手动修改DOM。下面行文中，数据我们用一个命名为data的对象代指；而UI对应开发者直接接触的就是描述DOM部分的代码， 可能是一段html模板，也可能是一段jsx。","text":"前言数据绑定有很多种实现方案，vue中的实现只是众多实现中的一种。都知道vue数据绑定是通过Object.defineProperty() 实现，但是在面试过程中，真正清楚vue数据绑定具体实现的不多，而网上各种vue原理解析的文章很多是二手三手的解读，千篇一律很多关键点都没有说到，本文主要是整理下自己的理解，并试图让不完全懂vue数据绑定原理实现的人看了能彻底懂。 数据绑定最终达到的效果先了解数据绑定绑定的是什么？是UI。数据绑定要达到的效果就是：UI渲染的时候使用数据对象(data)里的数据初始化UI，当UI中使用到的数据变化时，这个数据对应的UI会同步更新，而无需开发者手动修改DOM。下面行文中，数据我们用一个命名为data的对象代指；而UI对应开发者直接接触的就是描述DOM部分的代码， 可能是一段html模板，也可能是一段jsx。 数据绑定的实现先上一个张原理图 知识储备（如果已经熟练掌握可跳过）： 访问器属性和Object.defineProperty() defineProperty() 可以定义属性的getter和setter方法，当访问访问器属性的时候会调用该属性的getter方法，这样我们就可以知道全部的数据访问，并在此时做一些额外的工作。 var data = { a: 1 } Object.defineProperty(data,&apos;_a&apos;, { get() { console.log(`属性_a被访问了，在这里可以劫持这个数据访问的操作，返回我们想返回的值，并做些额外操作`); return this.a; }, set(newVal) { console.log(`属性_a被赋值了，我们可以在此时劫持改操作`); this.a = newVal } }) console.log(data._a)// 1, 属性_a被访问了... data._a = 2; //属性_a被赋值了... console.log(data._a); //2, 属性_a被访问了.. 定义了getter setter的属性即成了 访问器属性。上例中属性 ‘_a’就是访问器属性。 当我们访问访问器属性的时候会先调用我们定义的getter方法，当赋值访问器属性的时候会先调用我们定义的setter方法。 这里可能有人会疑问，为什么不直接通过Object.defineProperty 定义属性’a’,而是定义了一个和属性’a’关联的新属性’_a’ ? 有这个疑问的同学建议在浏览器控制台执行以下上面代码（将被定义的属性改成’a’），可能就一下明白了： 这样当我们访问属性a的时候会造成死循环，因为我们将属性a定义为访问器属性，当访问属性a的时候会调用getter方法getter 方法内执行 return this.a时又访问了属性a,导致又调用了setter方法，然后死循环。 你可能还是有疑惑，如果我们想将一个对象的属性转成访问器属性那岂不是只能新增属性，那这对数据使用方十分不友好。答案是我们可以通过闭包变量实现不增加新属性而将原属性定义成访问器属性， 而我们还是访问原始的属性。具体做法看下边。 闭包变量 var data = {a:3}; function defineReactive(data, key, val) { Object.defineProperty(obj, key, { get() { return val; }, set(newVal) { val = newVal; } }) } defineReactive(data, &apos;a&apos;, obj[&apos;a&apos;]) 这里我们就将属性’a’定义成了访问器属性。这里方法名defineReactive直译过来叫「定义响应式」，也比较好理解：正是访问器属性的setter和getter可以劫持属性的读写操作，我们可以响应这些操作，故叫定义响应式，这样的数据也叫响应式数据。 示例中defineReactive 内部 变量val即是一个闭包变量，函数调用结束后不会被释放，因为在getter中有引用。所以当我们重新赋值属性a的时候 会将新值赋给闭包变量val,再次访问属性a的时候执行getter方法 返回闭包变量val的值。 发布/订阅模式 发布/订阅模式是一个再常见不过的模式了，这里不做赘述。下文提到的依赖收集及通知依赖即是发布订阅模式。 原理解读现在回到上面的原理图。这里相对于源码我做了最大可能的精简，只保留了核心角色，这有是为了降低我们的理解负担。 首先看到这里有两个角色： 数据（data）, 和订阅者（watcher）。最开始我们对data做了一个操作：定义响应式即定义getter和setter。 这是vue整个数据绑定实现的最关键的一步。 我们的数据变成了响应式这意味着，数据的访问和修改我们都能知道，并在这个时机做一些操作。当访问某个数据（比如data对象的a属性）时，会触发这个数据的getter方法，我们在此将用到这个数据的订阅者（watcher）存起来；当这个数据发生变化时即修改其值时会触发该数据的setter方法，我们在此通知这个数据的订阅者们，订阅者们收到变化后会更新自己。 这里我们说一下订阅者（watcher）。 订阅者自身都有一个更新自己的方法（update）,当接收到通知后会调用自身update 方法，更新自己。 每个数据会有多个订阅者，UI中每当一处用到了该数据，就会添加一个该数据的订阅者。举个小栗子：我们的data对象如下： data = {a:1} 在模板中我们有一处用到了这个数据： &lt;div&gt; 第一次使用数据a:{{a}} &lt;/div&gt; 当我们解析模板的时候访问到数据a, 就会触发数据a的getter,在其getter里我们将添加一个订阅者至数据a的订阅者列表。这里的订阅者就是这个div标签，前面我们说了每一个订阅者都有一个更新自己的方法。 当数据a发生变化是会触发其setter,在setter里我们通知数据a的订阅者们，这些订阅者们收到通知的时候再调用自己的更新方法。 注意：在vue 1.x 里面当触发数据更新的时候是直接通知到其订阅者使其订阅者更新，这个更新粒度是节点级的。而vue2.x里加入了虚拟DOM，这个流程发生一点变化：状态侦测不再细化到某个具体节点，而是某个组件组件内部通过通过虚拟DOM来渲染视图。不过数据绑定的原理并没有变化。关于虚拟DOM，我会另开一篇。 关于源码这里并不会逐行解读源码，这类的文章网上一大片，而且篇幅会很长，我们这里只是结合源码的实现对上文做些补充，以及对源码里的我认为的巧妙之处单独说下。 通过上面或许已经大致能明白vue里数据绑定的实现了。而此时你去看源码的时候，会发现在有一些差异。在源码中数据绑定相关的还多了Observer类、Dep类。 Observer类。其实我觉得这个命名不好，它所做的事情就是给所有数据添加getter和setter将其改写成响应式数据，所以我这里直接叫「定义响应式」语义上会更准确，对应我们上图中defineReactive。Observer在通俗意义上更多的是指观察者模式里的观察者，而发布订阅模式即是观察者模式的一个变体，所以还容易造成理解上困扰。（比如我第一次看网上的原理图看到Observer时，还以为数据添加订阅者是在这个类里操作的)。 Dep类。它是和Watcher紧密关联的。 它是作用是用来为每个数据存放其订阅者，当这个数据变化了再通知这些订阅者们更新。可以看到Dep就是一个中介者。以租房中介为例：某个数据是一个房东，Dep是中介，租房者们是一个个watcher。当有人租房的时候都找Dep,当房东要收钱的时候告诉中介，中介负责通知各个租客交房租。 这里又一次用到了闭包变量： function defineReactive(data, key, val) { let dep = new Dep(); //闭包变量 Object.defineProperty(obj, key, { get() { dep.depend(); //添加订阅者 return val; }, set(newVal) { val = newVal; dep.notify(); //通知订阅者更新 } }) } let data = {a: 1}; defineReactive(data, &apos;a&apos;, obj[&apos;a&apos;]); 这里我们调用defineReactive方法将data的属性a定义响应式，这里产生一个闭包变量dep, 而其是和属性a绑定的，后续读写属性a会调用属性a的getter/setter，会用到dep 变量。每访问一次属性a都对会对a添加一个订阅者。 看defineReactive方法，你可能会有疑问的：dep.depend() 具体添加的是什么？答案是Watcher实例。但此时你可能还有疑问：在定义dep.depend 方法的时候我们还不知道watcher长什么样呢，因为watcher是有多种类型的（比如更新文本值、更新指令值等），当我们在需要添加的那一刻才知道订阅者长什么样。那怎么做到 dep 可以不事先关心 watcher的具体实现，在需要添加的地方又能自动将watcher添加到dep里呢？ 直线的思维是当我需要添加watcher的时候，调用一下dep.depend(watcher)。单这样有一个问题： 当我们在外部调用dep.depend(watcher)，就要知道每一个数据其对应的dep如何访问到，这可以定义一个全局对象来存放每个数据的dep，但这样其实并不优雅，封装性不够好。所以我们看到vue 源码里用一个闭包变量来存放每个数据对应的dep，而闭包变量在外部我们访问不到。 接下来我们就看一下vue 里是怎么做的，十分之巧妙。 下面为便于理解用的是伪代码，并不是vue 里源代码。 Dep的depend方法 depend() { if (Dep.target) { this.addSub(Dep.target); } } depend方法判断了一个条件 Dep.target如果存在则添加将Dep.target添加到订阅者队列里。 Watcher里get方法（会在constructor 调用） //为数据添加订阅者 get() { Dep.target = this; let value = this.getter(vm，expOrFn,cb); // 会触发数据的getter 方法， 可以先不关心它具体做了啥 Dep.target = null; return value; } 当解析到UI里用到了某一个数据后，我们就new Watcher(vm，expOrFn,cb)得到一个watcher实例, Watcher的constructor 会执行其get方法，该方法里先将Dep.target赋值为当前watcher实例，接着去访问这个数据，就会触发这个数据的getter方法，在数据的getter 里我们调用dep.deepend方法，deepend方法内将Dep.target（此时就是watcher实例）添加到当前数据的订阅者队列。 然后再将Dep.target置空。 我们再回顾下前面的定义响应式的方法对每个数据定义的getter： function defineReactive(data, key, val) { let dep = new Dep(); //闭包变量 Object.defineProperty(obj, key, { get() { dep.depend(); //添加订阅者 return val; }, set(newVal) { //.... } }) } 这就保证了只有通过new Watcher去访问的数据才会被添加到该数据的订阅者队列。比如我们在代码里写 data.a 这样去访问属性a时，由于Dep.target是null,所以不会被添加无意义的订阅者。 至此数据绑定原理基本上讲完了。 下面附上数据绑定相关部分精简代码实现的完整版： // Observer /** * Observer会将数据对象的所有属性都转换为getter/setter的形式来收集依赖（前面我们说的订阅者），并当属性值变化时通知这些依赖 */ export default class Observer() { constructor(value) { this.value = value; if (!Array.isArray(value)) { this.walk(value); } // 注意数组的处理方式略有不同，这里不暂且不包括数组的处理 } walk(obj) { const keys = Objects.keys(obj); for(let i=0, l = keys.length; i&lt;l; i++) { defineReactive(obj, keys[i], obj[keys[i]]) } } } // defineReactive function defineReactive(data, key, val) { // 递归子属性 if (typeof val === &apos;object&apos;) { new Observer(val); } let dep = new Dep(); Object.defineProperty(data, key, { enumerable: true, configulable: true, get() { dep.depend(); return val; }, set(newVal) { if (val === newVal) { return; } val = newVal; dep.notify(); } }) } // Dep export default class Dep { constructor() { this.subs = []; } addSub(sub) { this.subs.push(sub); } removeSub(sub) { remove(this,subs, sub); } depend() { if (Dep.target) { this.addSub(Dep.target); } } notify() { const subs = this.subs.slices(); for (let i=0,l=subs.length; i&lt;l; i++) { subs[i].updates(); } } } function remove(arr, item) { if (arr &amp;&amp; arr.length) { const index = arr.indexOf(item); if (index &gt; -1) { return arr.splice(index, 1) } } } // Watcher export default class Watcher { constructor(vm, expOrFn, cb) { this.vm = vm; this.getter = parsePath(expOrFn); this.cb = cb; this.value = this.get(); } get() { Dep.target = this; let value = this.getter.call(this.vm, this.vm); Dep.target = null; return value; } update() { const oldValue= this.value; this.value = this.get(); this.cb.call(this.vm, this.value, oldValue); } } const bailRe = /[^λw.$]/ function parsePath(path) { if (bailRe.test(path)) { return; } const segments = path.split(&apos;.&apos;); return function (obj) { for (let i=0, l=segments.length; i &lt; l; i++) { if (!obj) return; obj = obj[segments[i]]; } return obj; } } 参考资料 vue2.6源码 最后精简版源码部分来自《深入浅出Vue.js》","categories":[{"name":"javascript","slug":"javascript","permalink":"https://foreverwang.github.io/categories/javascript/"},{"name":"vue","slug":"javascript/vue","permalink":"https://foreverwang.github.io/categories/javascript/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://foreverwang.github.io/tags/vue/"},{"name":"数据绑定原理","slug":"数据绑定原理","permalink":"https://foreverwang.github.io/tags/数据绑定原理/"}]},{"title":"少有人走的路","slug":"少有人走的路","date":"2019-03-30T16:00:00.000Z","updated":"2020-06-21T11:08:05.116Z","comments":true,"path":"2019/03/30/少有人走的路/","link":"","permalink":"https://foreverwang.github.io/2019/03/30/少有人走的路/","excerpt":"这是一篇《少有人走的路》的读书总结。作者斯科特·派克，美国精神科医生，畅销书作家，心灵导师。这是一本关于心智成熟的书。这本书诞生的背景，1970年代，美国笼罩在经济危机和越南战争的阴霾下，整个国民精神萎靡不振。这本书在当时风靡一时，成了美国人民的精神食粮，帮助人们走出那些阴暗的时刻。 「心智成熟」的定义是什么呢？不妨先保留这个疑问。 开篇派克写道：Life is difficult. (人生苦难重重)。当我们理解并接受这一点的时候，就不会对人生的苦难耿耿于怀。然而大多数人不愿意正视人生的问题和苦难，他们总是习惯于怨天尤人，抱怨命运的不公，埋怨自己为什么这么倒霉。面对并解决问题的过程正是心智成熟的过程。","text":"这是一篇《少有人走的路》的读书总结。作者斯科特·派克，美国精神科医生，畅销书作家，心灵导师。这是一本关于心智成熟的书。这本书诞生的背景，1970年代，美国笼罩在经济危机和越南战争的阴霾下，整个国民精神萎靡不振。这本书在当时风靡一时，成了美国人民的精神食粮，帮助人们走出那些阴暗的时刻。 「心智成熟」的定义是什么呢？不妨先保留这个疑问。 开篇派克写道：Life is difficult. (人生苦难重重)。当我们理解并接受这一点的时候，就不会对人生的苦难耿耿于怀。然而大多数人不愿意正视人生的问题和苦难，他们总是习惯于怨天尤人，抱怨命运的不公，埋怨自己为什么这么倒霉。面对并解决问题的过程正是心智成熟的过程。问题给我们带来痛苦，而逃避问题的趋向，正是很多心理疾病的根源。那么有没有解决问题的什么通用手段呢？派克的答案是–自律。 什么是自律？自律包含四个原则：延迟满足，承担责任，尊重事实，保持平衡。 首先延迟满足书中举了吃蛋糕的例子。吃蛋糕的时候是先吃奶油还是先吃蛋糕代表了先甜后苦还是先苦后甜（当然这并不绝对）。举个我们更能切身体会的例子。上学的时候，你是习惯先写完作业再愉快的玩耍，还是先玩够了，最后不得不写的时候才去写？ 前者就是推迟满足感。再如，面对一天的工作，你是习惯于先去做那些简单琐碎的任务，拖到最后再去做哪些艰巨却重要的任务，还是相反？ 延迟满足感，意味着不贪图暂时的安逸，重新设置人生快乐和痛苦的次序：先面对问题并感受痛苦，然后解决问题并享受更大的快乐。 为什么有的人能够拥有足够的自制力，能避一时的安逸，先苦后甜，而相当数量的人不懂得推迟满足感？派克认为，家庭教育在这方面起着主要作用（后面统一说家教对个人的影响）。 第二点承担责任我的理解，这里主要指对自己负责任。我们必须面对属于自己的问题。而很多人习惯于推卸责任，出了问题总是能把原因归结于其他人，认为这「不是我的问题」，因此应该由他人解决问题，自己却不去做任何努力。 派克举了一个他随军队驻扎冲绳岛做心理咨询时的一个案例。有个美军军官酗酒成瘾，问题严重。他否认自己饮酒成性，也认为酗酒不是他的个人问题。他说：”在冲绳岛，我们晚上无事可做，生活实在无聊，除了喝酒，还能做什么呢？”派克问他喜欢读书吗？他说当然喜欢；又问那晚上为什么不以读书替代酗酒？答营房太吵，没心思读；问那为什么不去图书馆呢， 答太远了；问难道图书馆比酒吧还远吗？这时军官说，其实他也不怎么喜欢读书。于是派克又问喜欢钓鱼吗？回答和对读书的回答如出一辙，总之各种借口，最后又不得不说其实自己也没那么喜欢钓鱼。 这个军官认为在冲绳这个小岛，人们整天只能靠喝酒打发时间，很多人如此，不是他自己的问题，即便总是饮酒过量，以至于违反军规，惹了很多麻烦。这位军官总是始终不肯承认酗酒是他的个人问题，也不接受派克的建议：只要凭借毅力和决心，再加上别人的帮助，就能彻底解决问题。最终也不肯接受建议，继续酗酒，最终被开除军职。 书中提到两个概念：神经官能症和人格失调症。 神经官能症：为自己强加责任，认为错在自己。人格失调症相反，总是把错误归咎于他人，不愿意承担责任。上面提到的军官就是有一定程度的人格失调症，把问题的原因归咎于外界因素， 不肯承担责任，去改变现状。这两种症状都是责任边界的模糊。神经官能症其实少见，人格失调症则很常见。 回看我们自己。是否有人总是抱怨自己的工作无聊，没有意义，自己却从来不想如何做些自己认为意义的事情，或者也不去尝试换工作。 是否有人总是抱怨工作加班太多，从来不去思考如何提升效率从而少加班，或者去换一个加班少的工作。 这是不是我们对自己的不负责呢？没有认清我们的责任边界，没有认识到自己本可以解决问题从而使自己走出困境。 第三点：尊重事实我们对某事物的态度，并不应该是一成不变的。一方面，我们的认知是在不断完善和修正的，另一方面我们所处的客观环境也是在发生变化的。而人们倾向于维护自己陈旧的观念，保持前后的一致性。然而这并没有意义，此时所谓的坚持如一不过是抱残守缺，脱离现实。 派克把认知比喻作人生的地图，我们需要不断的完善和修正自己的地图。 对于尊重事实这一点，可以概括为：实事求是，以发展的眼光看问题。观察身边的人其实能做到事事实事求是的人少之又少。比如我有时候会从不同的同事口中听到对同一个同事完全不同的反馈。 第四点：保持平衡书中说道，自律是艰难而复杂的工作，你需要用于足够的勇气和判断力。既要以追求诚实为己任，也需要保留部分事实和真相；既要承担责任，也要拒绝不改承担的责任；为使人生规范、高效、务实，必须学会推迟满足感，把眼光放远，又要尽可能过好眼下的生活，通过适当的努力让人生的快乐多于痛苦。这就是所说的保持平衡，自律本身也需要约束。 派克以生气为例来说解释持平衡。 我们心理或生理上受到侵犯，或者某人某事让我们伤心失望，我们就会感到生气。要获得生存，生气是一项必不可少的反击方式。从来不生气的人，更容易遭受欺凌和压制，甚至最终被摧毁和消灭。必要的生气，可以使我们更好的生存。我们收到侵犯，不见得是侵犯者对我们怀有敌意。有时他们即便果真有意而为，我们也要适当约束情绪。正面冲突只会是的处境更加不利。大脑的高级中枢–判断力，必须约束低级种树–情绪。在这个复杂多变的世界里，我们不但要有生气能力，还要具备即便生气也可抑制其爆发的能力。我们要以不同的方式，恰当的表达情绪：有时需要委婉，有时需要直接，有时需要心平气和，有时需要火冒三丈。表达生气还要注意时机和场合。 派克又说：保持平衡的最高原则是’放弃’。书中提到心理学家埃里克·艾瑞克森曾列举出人生八种危机。人生的各个阶段会出现各种危机，只有放弃过去时的观念和习惯，才能顺利进入人生的下一阶段。不少人不敢面对现实，后者无法放弃早已过时的过去，以至于无法克服心理危机和精神危机，只能止步不前。 以上就是派克所认为的自律的四个原则了。听完觉得心好累啊，怎样能做到自律呢？自律的原动力有是什么呢？为什么有的人能做到高度自律，有的人则不能，人与人之间的差距是怎么拉开的？ 答案是–爱，爱是自律的原动力爱的定义有很多种：肉体之爱，精神之爱，手足之爱….。派克对爱的定义是：为了促进自我和他人的心智成熟而具有的一种自我完善的意愿。 对于爱的定义总是很抽象。那么我们先来看看派克认为哪些不是爱。 坠入情网不是爱那是生理本能反应，是性冲动。因为坠入情网，不是出于主观意愿，不是有计划有意识的选择。你完全可能爱上某个与你毫不相称的人，甚至不愿接受对方身上的缺点，可你却对对方产生深深的依恋。与此同时，另一个人各方面都很出色，你却毫无感觉。 坠入情网是人类内正在的性的需求和外在的性的刺激产生的生理和心理反应，意义在于增加人类生殖机会，促进物种繁衍和生存。 过分依赖也不是爱有的人没有别人的关心和照顾，就认为人生不够完整，以至于无法正常生活，这就是心理学上的”依赖性”,过分的依赖只能导致病态。这里我们就得区分病态的依赖和正常的对于依赖的渴望。人人都有依赖的需求和渴望，都希望有更强大的人关心自己。 不管我们看起多么强大，尽管我们竭力表现出无需关心的样子，但是不得不承认，我们内心深处都渴望过依赖他人的感觉。我们承认这种感觉的合理性，同时我们要警惕他不让他控制我们的生活。假如他牢牢控制我们的一言一行，控制我们的一切感受和需要，那么它不再是单纯的渴望，而是会成为过分依赖的心里问题。心理学上叫”消极性依赖人格失调”。 “消极性依赖人格失调”的患者只是苦思如何获得他人的爱，甚至没有精力去爱别人，其人生价值依赖于同别人的情感关系。有的情侣一旦分手就无法生活，甚至可能会轻生，然而没过几天他就完全好了，因为又找到了新的恋爱对象。这就是对恋爱对象的病态依赖。依赖性过强的人，总是把失去伴侣当成及其恐怖的事情，他们丝毫不肯降低对他人的依赖性，不肯给对方更多的自由。在消极性依赖婚姻中，夫妻角色分工格外严格，不论做什么，总以过分依赖的心态为起点，致使婚姻变成可怕的陷阱。所谓的爱，也不过是依赖，而自由和独立并不存在。有些依赖性过强的人，婚后甚至宁可放弃婚前的本领和技能。书中提到一个例子：有人女人婚后突然不会开车了。她不是没有学过开车，而是婚后发生的某次事故，使她对开车产生恐惧。她的恐惧足以把丈夫拴在身边，毕竟没有丈夫她哪儿也去不了。丈夫也必须承担起购物的责任，或在她外出购物时充当司机。 自我牺牲也不是爱派克有个病例，有位牧师的家人都出现了心理问题，妻子患上抑郁症，两个儿子也都大学辍学。牧师非常苦恼，不知问题出在哪，他认为自己很爱家人，为家人操碎了心，工作生活都一人包揽。听起来这位牧师很伟大，为了家庭付出很多。而派克却指出问题出在牧师本身，他的大包大揽，极力的付出，只是在满足自己好人形象的心里需求，根本没把妻子和儿子的心智成熟当回事。后来在派克的建议下，扮演起”坏人”，不在对家人的请求有求必应，不再替妻子和儿子收拾家务，打扫卫生…而是让他们自行负担。不就后家人的状况都有了明显的好转，一个儿子回到了大学，一个儿子找了工作，妻子也感受到了独立的好处，心灵由此得到了成长，牧师本人则大大提高了工作效率，感受到真正的快乐。 自我牺牲严重了就是「被虐待狂」。无论是别人受苦，还是自己受苦，患者都会感受到某种生理快感。 爱，不是感觉我们再看作者对于爱的定义：爱是为了促进自我和他人的心智成熟而具有的一种自我完善的意愿。爱是实际行动，是真正的付出。 可是什么因素导致了人与人之间「爱」的能力的差异呢？为什么面对同样的处境有的人能坚强面对，从而变的更加强大，有的人则形成理疾病。派克认为是父母的教育起了决定性因素。父母不自律，不能给予孩子足够的关爱，是导致人们日后各种心理疾病的重要原因。即便我们过了父母教育的年龄，意识到这一点对我们仍然有指导意义。我们可以观察自己的性格优缺点，和好坏习惯，是否和从小的父母教育有关？清楚了问题的源头，对于认识问题自身也是有用的。不清楚问题的源头，我们更容易对问题视而不见，反之，我们更能坦然面对问题。 举个例子吧，比如从小家庭教育比较严苛，父母经常打骂的孩子，缺少父母的关爱，更容易变的’自卑’。从小自我价值感会比较弱，认为自己时间并不值钱，自律的动力也不足。 （写的有点累了… 前面主要是自己的总结思考，写到这后面就有点为了成文而凑篇幅了，写不动了，所以要结尾这篇文章了…) 最后以上讲的 自律和爱其实只是这本书的前半部分。 后半部分主要是将意识和潜意识的。后面的观点并不十分赞同，所以也没什么好总结的。 最后派克把心智等同于意识，认为心智的成熟就是意识的成长，同时意识的成长又是对潜意识的重新认识。这一观点是带有宗教色彩的，派克认为潜意识就是我们每个人的上帝云云。 如果问我这本书值不值得买来细度呢？ 如果读书对你来说是一件轻松的事情（阅读速度），推荐阅读；如果不是则不推荐。 整体这本书里的观点对我而言有一些指导意义， 但是本书的论述略显啰嗦，有些篇幅反复的在说同一个观点，书中举得很多例子说服力也不强。这也可能和翻译的水平有关。书中也有些硬伤，比如把各种心理疾病归因于家庭教育，把潜意识说成是上帝的化身，滥用物理学’熵’的概念。 更讽刺的是，作者派克在书中以心灵导师的身份教导读者要自律，自己却没有做到：酗酒，吸食大麻，婚外情和家人关系不和谐等。还真是： 讲过很多道理，以然过不好这一生。 最后我试图回答一下开头的问题：心智成熟的旅程就是直面人生问题，不断克服人生困难，让自己和他人变的更好的过程。","categories":[{"name":"读书","slug":"读书","permalink":"https://foreverwang.github.io/categories/读书/"}],"tags":[{"name":"心智成熟之路","slug":"心智成熟之路","permalink":"https://foreverwang.github.io/tags/心智成熟之路/"},{"name":"自律","slug":"自律","permalink":"https://foreverwang.github.io/tags/自律/"}]},{"title":"flex","slug":"你可能还不够懂flex布局","date":"2018-10-22T08:21:50.000Z","updated":"2020-06-21T11:08:05.116Z","comments":true,"path":"2018/10/22/你可能还不够懂flex布局/","link":"","permalink":"https://foreverwang.github.io/2018/10/22/你可能还不够懂flex布局/","excerpt":"flexflex布局中基本概念 两种元素类型：flex容器(flex container)、flex项目（flex item 容器成员)。 两个轴：主轴（main axis）、交叉轴（cross axis）。 占据的空间：项目占据的主轴空间（main size）、项目占据的交叉轴空间（cross size） 注意：设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。","text":"flexflex布局中基本概念 两种元素类型：flex容器(flex container)、flex项目（flex item 容器成员)。 两个轴：主轴（main axis）、交叉轴（cross axis）。 占据的空间：项目占据的主轴空间（main size）、项目占据的交叉轴空间（cross size） 注意：设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。 属性 容器属性6个 display: flex flex-direction justify-content flex-wrap (wrap-reverse) align-items (定义了项目在交叉轴上如何对齐，baseline | stretch) align-content (定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。stretch（默认值）：轴线占满整个交叉轴。) flex-flow (flex-direction和flex-wrap的简写，默认值： row nowrap) 项目属性6个 align-self（可覆盖align-items属性） flex-grow (默认值0) flex-shrink （默认值1） flex-basis（默认值为auto，即项目的本来大小） order flex (flex-grow、flex-shrink、flex-basis的简写，默认值：0 1 auto, 后两个属性可选。用两个快捷属性：auto(1 1 auto)、 none(0 0 auto),建议优先使用这两个属性，因为浏览器会推算相关值) flex 布局核心属性 flex-basis auto ： 优先设置的宽度，没设置则内容宽度 content： 一律内容宽度，不管有没有设置宽度 长度或百分比：没啥好说的 flex-grow：剩余空间按比例分配，与项目自身所占空间无关 flex-shrink：超出空间按比例挤压项目，项目自身所占空间参与权重计算 计算剩余空间 剩余空间 = 容器所占主轴空间 - 所有项所占主轴空间总和 剩余空间 &gt; 0,说明有剩余空间可分配,即可伸缩项有条件扩展,如何扩展看每一项的 flex-grow属性；剩余空间 &lt; 0 我们叫超出空间更方便理解,说明可伸缩项占主轴空间总和大于容器占主轴的空间，即可伸缩项目需要收缩才内适应容器空间，如何收缩看每一项的flex-shrink属性。 伸缩项扩展计算公式 伸缩项flex-grow权重值/各伸缩项flex-grow值总和 * 剩余空间 伸缩项收缩计算公式（注意了，这里很多人搞错了） （伸缩项flex-shrink权重值 该伸缩项flex-basis）/ （各伸缩项flex-shrink 各伸缩项flex-basis 总和) * 超出空间 注意，与flex-grow在扩展时简单地按比例分配不同，除考虑flex-shrink本身，也要考虑flex-basis。假设每一项flex-shrink都是默认值1，那其实就是按照每一项flex-basis的占比进行收缩。 易忘点 align-self比align-items属性多了一个auto,其余一样。 align-self:auto(默认值)，继承父元素的align-items。 flex属性是三个属性的简写：flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto； flex: 1 即 flex-grow:1; flex-shrink: 0; flex-basis: auto 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto) flex-basis: 计算剩余空间是根据该属性值计算的。默认值：auto,项目的本来大小。 flex-basis:auto; 如果项目设置了width属性值，则flex-basis实际值等于width值。 flex-basis: length 优先级大于width/ height值 flex-shrink 和 flex-grow的计算规则稍有不同，主要是避免被挤压没了","categories":[{"name":"布局","slug":"布局","permalink":"https://foreverwang.github.io/categories/布局/"}],"tags":[{"name":"flex","slug":"flex","permalink":"https://foreverwang.github.io/tags/flex/"}]},{"title":"当我们学习es6的时候我们在学什么","slug":"当我们学习es6的时候我们在学什么","date":"2018-04-21T08:21:50.000Z","updated":"2020-06-21T11:08:05.116Z","comments":true,"path":"2018/04/21/当我们学习es6的时候我们在学什么/","link":"","permalink":"https://foreverwang.github.io/2018/04/21/当我们学习es6的时候我们在学什么/","excerpt":"","text":"","categories":[{"name":"javascript","slug":"javascript","permalink":"https://foreverwang.github.io/categories/javascript/"}],"tags":[{"name":"javascript核心","slug":"javascript核心","permalink":"https://foreverwang.github.io/tags/javascript核心/"},{"name":"es6","slug":"es6","permalink":"https://foreverwang.github.io/tags/es6/"}]},{"title":"javascript朝花夕拾之继承","slug":"javascript朝花夕拾之继承","date":"2018-04-05T14:16:08.000Z","updated":"2020-06-21T11:08:05.115Z","comments":true,"path":"2018/04/05/javascript朝花夕拾之继承/","link":"","permalink":"https://foreverwang.github.io/2018/04/05/javascript朝花夕拾之继承/","excerpt":"从实现角度，在OO语言中的继承特性，有三种实现方案，包括基于类（class-based）、基于原型（prototype-based）和基于元类（metaclass-based）。 从形式上，许多OO语言都支持两种类型继承方式：接口继承和实现继承。接口继承只继承方法签名，实现继承则继承实际的方法。js 中函数没有签名，故js 中无法实现接口继承。js 中只支持实现继承，而其实现继承主要是依靠原型链来实现的。 构造函数，原型对象，实例对象的关系每一个构造函数都有一个prototype属性指向其原型对象；每一个原型对象都包含一个指向构造函数的指针（或者说属性）constructor;而实例对象都包含一个指向原型对象的内部指针(内部属性) [[prototype]]。 对象实例是无法直接通过实例属性来访问原型对象的，但是我们可以间接方式显式的访问其原型对象。 通过在实例上访问其constructor 属性可以引用到实例的构造函数，再访问构造函数的prototype属性访问原型对象。","text":"从实现角度，在OO语言中的继承特性，有三种实现方案，包括基于类（class-based）、基于原型（prototype-based）和基于元类（metaclass-based）。 从形式上，许多OO语言都支持两种类型继承方式：接口继承和实现继承。接口继承只继承方法签名，实现继承则继承实际的方法。js 中函数没有签名，故js 中无法实现接口继承。js 中只支持实现继承，而其实现继承主要是依靠原型链来实现的。 构造函数，原型对象，实例对象的关系每一个构造函数都有一个prototype属性指向其原型对象；每一个原型对象都包含一个指向构造函数的指针（或者说属性）constructor;而实例对象都包含一个指向原型对象的内部指针(内部属性) [[prototype]]。 对象实例是无法直接通过实例属性来访问原型对象的，但是我们可以间接方式显式的访问其原型对象。 通过在实例上访问其constructor 属性可以引用到实例的构造函数，再访问构造函数的prototype属性访问原型对象。 代码示例： function A() {} var instance = new A; 通过instance访问原型对象： instance.constructor.prototype 。对象实例内部属性[[prototype]]对程序而言是不可见的，即在代码里不能直接访问，供引擎来访问。 但在浏览器实现中每个对象都有一个__proto__ 属性，可以在代码层面直接访问原型对象。 基于原型链的继承上面我们理解了原型对象和构造函数及实例对象的关系。 如果我们让原型对象等于另一个类型的实例。 此时原型对象就包含一个指向另一个原型对象的指针，相应的另一个原型对象也包含一个指向另一个构造函数的指针。假如另一个原型对象又是另一个类型的对象的实例，那么上述关系依然存在，如此层层递进,就构成了实例和原型的链条，这就是原型链的概念。 实现原型链的基本模式，让一个原型对象等于一个对象的实例。 代码如下： function SuperType() { this.property = true; } SuperType.prototype.getSuperValue = function() { return this.property; }; function SubType() { this.subProperty = false; } SubType.prototype = new SuperType(); SubType.prototype.getSubValue = function() { ruturn this.subProperty; } var instance = new SubType(); console.log(instance.getSuperValue()); //true 引用关系图如下: 原型链的问题原型链虽然很强大，可以用它实现继承有两个明显的问题。 1.当原型对象中包含引用类型值时，会有问题。 由于原型对象的属性被所有实例共享，当一个实例去修改一个共享自原型上的引用类型的属性时，会影响到所有其他实例。示例代码如下： function SuperType() { this.colors = [\"red\", \"blue\", \"green\"]; } function SubType() {} SubType.prototype = new SuperType(); var instance1 = new SubType(); instance1.colors.push(\"black\"); var instance2 = new SubType(); console.log(instance2.colors); //\"red,blue,green,black\" 由于color属性是继承自SubType的原型，是引用类型值，当instance1修改其color属性时，实际上是修改的SubType原型里的color属性，由于instance2也继承了原型的color属性（其没有实例属性color）,所以instance2.color指向的color属性已经是被instance 修改过的了。 本来我们将属性放到构造函数里是为了其私有性考虑，可见这里的问题实质是属性的私有性被破坏了。 创建子类实例时，不能向父类构造函数中传参。 解决以上两个问题，我们可以通过 “类抄写”（或叫”借用构造函数”）的方式来实现。 （具体叫什么不重要，名字只是一个代号，方便我们交流，我们要做的就是知道他是什么）。 借用构造函数（类抄写）这种方法具体做法是：在子类构造函数内部通过call或apply方法调用父类构造函数。这样就可以在实现属性继承的同时，既能传参，又能保证实例属性的私有行。 function SuperType() { this.colors = [\"red\", \"blue\", \"green\"]; } function SubType() { SuperType.call(this); //如果要传参可以用apply //SuperType.apply(this,arguments) } var instance1 = new SubType(); instance1.colors.push(\"black\"); alert(instance1.colors); //\"red,blue,green,black\" var instance2 = new SubType(); alert(instance2.colors); //\"red,blue,green\" 在SubType子类里通过SuperType.call(this) 调用父类，当实例化子类时，就将父类实例上的实例方法都赋值给了子类实例。 类抄写也有其问题，方法都在构造函数中定义，函数无法复用，浪费内存。同时，在父类原型的属性对子类而言也是不可见的。所以实际应用中也很少单独使用借用构造函数的技术。而更常见的是将原型链和借用构造函数结合到一块，从而发挥两者之长的一种继承模式，及所谓的组合继承。这里就不展开细说了。 使用Object.create()实现原型继承ES5中新增Object.create() 来实现原型式继承。他使得原型继承不必依赖于构造函数，不用创建特定的对象类型。这里我们只需要关心Object.create() 只有一个参数时即可（第二个参数和继承无关）。他返回一个新的对象，新的对象的原型对象即传入的Object.create()第一个参数。 原型继承的本质原型其实也是一个对象实例。 原型的含义：如果构造函数有一个原型对象A，则有构造函数创建的实例都必然复制自A（先不考虑这里具体的复制实现问题）。 “原型也是对象实例” 这是一个最关键的性质。这使得很自然的理解原型对象也有其自己的原型对象，即原型对象的原型对象。这是原型继承和类继承体系在本质上的不同。 对于类继承体系，类不必是”对象”，因此也不具备对象的性质。 举例来说，“类”可以是一个内存块，也可能是一段描述文本，而不必是一个有对象特性（如可以调用方法或存取属性）的结构，（其实es6的class并不是通常意义上的class他还是对象）。 原型继承是一个典型的以时间换空间的解决方案。由于子类中直接读写一个成员而有无法存取到该成员时，将会回溯原型链以查找该成员的名字，因此直接结果是：继承层次中临近的成员访问更快，而试图访问一个不存在的成员时最耗时。 而现实的对象系统，我们其实更希望基类实现尽可能多的功能，希望通过较多的继承层次来使得类的粒度变小以便于控制。 从这里来看，访问更多的层次以及访问父类成员是复杂对象系统的基本特性。 而js 里更多层次的继承往往承意味着属性的存取要经过更多层次的查找，更多的cpu消耗。这跟js 创立初期其所运行的环境有关，空间占用是关键，时间消耗次要的多。而在现在硬件条件下的js运行环境这些问题已经不再明显，甚至时间消耗是在意的。 扩展-默认的原型这里借用一张网图： 理解上图有几个关键事实： 原型对象也是一个实例对象构造函数也是一个实例对象 而实例对象都有自己的原型对象 ，通过proto属性访问（浏览器环境）。构造函数的默认的原型对象是一个空的对象（empty objects），它是一个由Object创建的实例对象，所以其 proto 指向Object.prototype。Foo.prototype. proto === Objtct.prototype。 而构造函数又是谁创建的呢？所有的构造函数（包括内置对象，但除了Function它自身）都是由Function构造函数创建的，故构造函数也是个实例对象也有其原型，Foo. proto === Function.prototype。 同时Object也是Function 创建的，故Object. proto === Function.prototype。而Function.prototype 是一个Object创建的空的对象，故Function.prototype. proto === Object.prototype。 我们发现原型对象的源头是Object.prototype,那么Object.prototype 有自己的原型对象吗？有： Object.prototype. proto === null。 新世界 - ES6在es6 之前，生成实例对象的方法是通过构造函数。而在es6不一样了，ES6 提供了更接近传统语言的class写法，引入了 Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。通过extends关键字来实现继承。 这使得定义对象模板语法上更简洁了。然而它只不过是ES5的语法糖而已，javascript基于原型（prototype-based）继承的对象系统的实质是没有变的。 ES6非语法糖层面的改变,那应该是其静态方法可以被子类继承。其他还有吗？有的话告诉我。 关于es6 class 详情看这里。 参考资料 javascript 高级程序设计 javascript语言精髓与编程实践 ECMAScript 6 入门","categories":[{"name":"javascript","slug":"javascript","permalink":"https://foreverwang.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://foreverwang.github.io/tags/javascript/"},{"name":"继承","slug":"继承","permalink":"https://foreverwang.github.io/tags/继承/"}]},{"title":"测试travis 自动部署","slug":"测试travis自动化部署","date":"2018-03-25T08:21:50.000Z","updated":"2020-06-21T11:08:05.117Z","comments":true,"path":"2018/03/25/测试travis自动化部署/","link":"","permalink":"https://foreverwang.github.io/2018/03/25/测试travis自动化部署/","excerpt":"自动化部署hexo 是一套基于nodejs的静态博客生成系统，这往往需要有一套本地的hexo环境，将你本地编写的markdown 文件 生成静态网站需要的文件。这使得写博客依赖于这套环境，如果你换个电脑，要么重新装一遍环境，要么没法发布。 这里说的自动化部署最终效果是我在github上在线编写一片博文，提交后就会自动构建生成博客文件并上传到指定的git仓库，构建部署完成，博客就发布生效了。可以做到只要有网络你就可以发布博客。而且以后你只需要关心写博客，不需要关心构建部署。 具体细节不赘述，原理就是利用了 travis 和 github 的webhook。 github 上提交时出发travis 的自动构建部署。 之所以选travis 是因为他免费。","text":"自动化部署hexo 是一套基于nodejs的静态博客生成系统，这往往需要有一套本地的hexo环境，将你本地编写的markdown 文件 生成静态网站需要的文件。这使得写博客依赖于这套环境，如果你换个电脑，要么重新装一遍环境，要么没法发布。 这里说的自动化部署最终效果是我在github上在线编写一片博文，提交后就会自动构建生成博客文件并上传到指定的git仓库，构建部署完成，博客就发布生效了。可以做到只要有网络你就可以发布博客。而且以后你只需要关心写博客，不需要关心构建部署。 具体细节不赘述，原理就是利用了 travis 和 github 的webhook。 github 上提交时出发travis 的自动构建部署。 之所以选travis 是因为他免费。 问题记录travis login 报错 报错信息 Last Exception An error occurred running `travis login`: TypeError: no implicit conversion of nil into String from /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/json/common.rb:155:in `initialize&apos; ... 解决方案： 升级ruby 版本至2.5 # 安装rvm curl -L get.rvm.io | bash -s stable source ~/.rvm/scripts/rvm ssh 权限问题 报错信息 Warning: Permanently added the RSA host key for IP address &apos;192.30.253.113&apos; to the list of known hosts. To github.com:foreverwang/foreverwang.github.io.git 大概是要报github 这个ip 地址加入到known hosts 文件，这个电脑在第一次访问时会自己添加，不知道怎么在travis的服务器上添加。其实到这一步travis 服务器已经能通过ssh方式连接我的github仓库了。但是优于这个问题的存在，导致在hexo deploy时 无法push到仓库。尝试解决未果。 解决方案： 改用github token 方式连接 ok了 具体配置信息看这里 参考资料 http://kchen.cc/2016/11/12/hexo-instructions/ https://blog.csdn.net/woblog/article/details/51319364 后记是时候改用github actions了： https://hexo.fluid-dev.com/posts/actions-deploy/","categories":[{"name":"javascript","slug":"javascript","permalink":"https://foreverwang.github.io/categories/javascript/"}],"tags":[]},{"title":"非对称加密(公钥加密)及其应用","slug":"非对称加密及其应用","date":"2018-02-23T04:20:48.000Z","updated":"2020-06-21T11:08:05.119Z","comments":true,"path":"2018/02/23/非对称加密及其应用/","link":"","permalink":"https://foreverwang.github.io/2018/02/23/非对称加密及其应用/","excerpt":"什么是非对称加密维基百科已经解释的非常清楚了（只看对公开密钥加密的解释这部分，引用如下）。 公开密钥加密（英语：Public-key cryptography），也称为非对称加密（英语：asymmetric cryptography），是密码学的一种算法，它需要两个密钥，一个是公开密钥，另一个是私有密钥；一个用作加密的时候，另一个则用作解密。使用其中一个密钥把明文加密后所得的密文，只能用相对应的另一个密钥才能解密得到原本的明文；甚至连最初用来加密的密钥也不能用作解密。由于加密和解密需要两个不同的密钥，故被称为非对称加密；不同于加密和解密都使用同一个密钥的对称加密。虽然两个密钥在数学上相关，但如果知道了其中一个，并不能凭此计算出另外一个；因此其中一个可以公开，称为公钥，任意向外发布；不公开的密钥为私钥，必须由用户自行严格秘密保管，绝不通过任何途径向任何人提供，也不会透露给要通信的另一方，即使他被信任。 维基上说的说的有点啰嗦，精简一下就是：","text":"什么是非对称加密维基百科已经解释的非常清楚了（只看对公开密钥加密的解释这部分，引用如下）。 公开密钥加密（英语：Public-key cryptography），也称为非对称加密（英语：asymmetric cryptography），是密码学的一种算法，它需要两个密钥，一个是公开密钥，另一个是私有密钥；一个用作加密的时候，另一个则用作解密。使用其中一个密钥把明文加密后所得的密文，只能用相对应的另一个密钥才能解密得到原本的明文；甚至连最初用来加密的密钥也不能用作解密。由于加密和解密需要两个不同的密钥，故被称为非对称加密；不同于加密和解密都使用同一个密钥的对称加密。虽然两个密钥在数学上相关，但如果知道了其中一个，并不能凭此计算出另外一个；因此其中一个可以公开，称为公钥，任意向外发布；不公开的密钥为私钥，必须由用户自行严格秘密保管，绝不通过任何途径向任何人提供，也不会透露给要通信的另一方，即使他被信任。 维基上说的说的有点啰嗦，精简一下就是： 加密解密通过一个秘钥对即公开密钥和私有密钥完成的。用公钥加密明文得到的密文，只能通过对应的私钥解密得到明文。（类似私钥加密明文得到密的文，只能通过对应的公钥解密得到明文） 密钥对是数学相关的。 在现实世界上可作比拟的例子是，一个传统保管箱，开门和关门都是使用同一把钥匙，这是对称加密；而一个公开的邮箱，投递口是任何人都可以寄信进去的，这可视为公钥；而只有邮箱主人拥有钥匙可以打开邮箱，这就视为私钥。这就是非对称加密。（以下说的公钥加密和对对称加密是一回事） 与对称加密的比较对称加密的问题在于通信双方要事先交换密钥，而事先传递密钥的过程 存在密钥泄露的风险。密钥一旦泄露，数据就不安全了。而非对称加密，密钥对的私钥是保密的不需要事先传递或公开的，所以安全性更高。 注意，看网上的博文很多人对这里的理解是不太透彻的: 认为对称加密的问题在于加解密用同样的密钥，所以导致对称加密不安全的。 加解密使用同样的密钥-这是对称加密的概念也是其形式，把对称加密安全性差归咎于此不太妥（要强扯也┑(￣Д ￣)┍）。 对称加密的安全性低，问题在于两点： 由于加密解密用同样的密钥，其密钥需要通信双方事先交换（或单向传递），密钥交换的过程存在泄漏的风险。 由于密钥通信双方都知道，通信接收方可以泄漏发送方的密钥给其他人。 而以上两个问题非对称加密都解决了： 加密解密需要一对密钥来完成，其中私钥是不公开也不需要事先传递的，所以泄漏的概率更小。 公钥加密的信息只能通过其对应的私钥来解密，私钥是属于通信双方中某一方且保密的，而公钥是公开的，所以不存在泄漏对方密钥的风险。 所以，在保证密钥不被泄漏的前提下对称加密和非对称加密是一样安全的。 但是，对称加密中，通信双方在事后有泄漏对方密钥的可能。 如果再加一个条件通信双方的发送者对每一个接收者使用不同的密钥，这样就能保证对称加密和非对称加密一样安全了。 但是这两点都比较难保证：1.传递密钥过程的安全性依赖传递环境。2.需要每个人都要有很多很多密钥，不同的接收方用不同的密钥，密钥难以保管。 所以这个时候非对称加密华丽登场了。下面我们通过对具体的某一种非对称加密算法的学习来理解非对称加密的数学原理。这里我们选用应用最广泛的非对称加密算法之一：RSA加密算法。 RSA算法RSA算法的数学基础是：欧拉定理，此处不做解释。公钥加密算法根据其所依据的数学难题一般分为三类：大整数因式分解问题类、离散对数问题类，椭圆曲线类。RSA属于大数分解类，也是最好理解的。 下面直接介绍RSA算法的基础步骤； 1. 生成公钥（PK）和私钥(SK) (1) 随意选两个大的素数p和q，p不等于q (2) 将p、q两个素数相乘得到n，即n=pq (3) 计算n的欧拉函数φ(n):根据公式 φ(n)=(p-1)(q-1) (4) 选择一个整数e，作为密钥，使得e和φ(n)互质，且e &lt; φ(n) (5) 计算e对于φ(n)的模反元素d: 根据公式 ed mod φ(n) = 1 ,计算出d的值，作为另一个密钥。所谓”模反元素”就是指有一个整数d，可以使得ed被φ(n)除的余数为1。 12ed ≡ 1 (mod φ(n)) ==&gt; ed - 1 = kφ(n) //求解二元一次方程 k 从1带入试就行了 (6) 通过以上步骤计算出 n 、e 、d 3个数据，其中（n、e）作为公钥，（n、d）作为私钥（也可以互换） (7) 生成公钥和私钥后就可以公开公钥了。 2. 用公钥加密信息信息发送方收到接收方公钥PK后，就可以用PK对数据加密。加密步骤如下。 其中明文为M，加密后的密文为C，公钥（n,e） 加密： M^e mod n = C 3. 用私钥解密信息接收方持有私钥（N，D）,在接收到密文C后，通过私钥对其解密，得到明文M： 解密： C^d mod n = M RSA 安全性分析通常到这里我们会有个疑问？ 公钥和私钥存在一定的数学关系， 公钥公开，那么有没有可能通过公钥推导出私钥呢？ 如果能那不就不安全了吗。 答案是：能，但是很难。问题变成 能否在已知 n和e的前提下，推导出d ? 123ed ≡ 1 (mod φ(n)) //等价于 ed mod φ(n) = 1 φ(n)=(p-1)(q-1)n=pq 结论：如果n可以被因数分解，d就可以算出。但是，大整数的因式分解是很困难的，目前除了暴力破解，还没有更好的有效方式。 所以整数n的因式分解难度决定了RSA算法的可靠度。 RSA可靠性就是建立在分解两个大素数乘积的十分困难上。 这个难度是个什么概念呢？引用 RSA算法的破解与密钥的长度有关，最常见的破解方法是因式分解，如果密钥的长度小于等于256位，一台较快的电脑可以在几个小时内成功分解其因子。位数越高因式分解所需时间也越长。1999年，一台Cray超级电脑用了5个月时间分解了512位长的密钥。而目前典型密钥长度是1028位。在512位RSA算法破解10年之后，一群研究人员报告(PDF)他们因式分解了768位RSA算法。他们是在2009年12月9日分解了768位、232数位数字的RSA-768密钥。分解一个768位RSA密钥所需时间是512位的数千倍，而1024位所需时间则是768位的一千多倍，因此在短时间内1024位仍然是安全的。研究人员表示1024位密钥预计也将会在10年内攻破，因此在未来三到四年内应逐步淘汰1024位RSA密钥。 思考一下大整数n 因式分解为什么难？有多难？ RSA 算法实例生成公钥私钥 随机取大质数p=11，q=13，那n=11*13=143，φ(N)=(p-1)(q-1) = 120 取一个e=7，由 ed mod φ(n) = 1 计算出d=103。12公钥（n,e） 即 （143, 7）私钥 (n,d) 即 （143, 103） 用公钥加密由于手工计算，为了使计算量小一点，我们将上面的公钥和私钥交换： 即公钥 （143, 103），私钥（143, 7）。取明文 m =2,加密过程如下： 1234密文 c = m^e mod n = 2^103 mod 143 = 10141204801825835211973625643008 mod 143 = 63 用私钥解密收到密文c = 63,通过 私钥（143，7）进行解密，解密过程如下： 1234明文 m = c^d mod n = 63^7 mod 143 = 3938980639167 mod 143 = 2 至此，我们用RSA算法进行了一次加密解密，其实很简单，只是计算量可能会比较大。 常见的公钥加密算法除了RSA。还有ElGamal、背包算法、椭圆曲线加密算法（英语：Elliptic Curve Cryptography, ECC）等。下面我们说下非对称加密的应用。 非对称加密的应用先插入一个概念： 信息系统安全的基本属性。 信息系统安全的基本属性: 保密性、完整性、可用性、不可抵赖性。 保密性：是应用系统的信息不被泄露给非授权的用户。常用保密技术：最小授权原则，信息加密等。 完整性：完整性是信息未经授权不能进行改变的特性。完整性是一种面向信息的安全性。 可用性： 可用性是应用系统面向用户的安全性能，不做赘述。 不可抵赖性：不可抵赖性也称作不可否认性，在应用系统的信息交互过程中，确信参与者的真实同一性。即所有参与者都不可能否认或抵赖曾经完成的操作和承诺。利用信息源证据可以防止发信方不真实地否认已发送信息，利用递交接收证据可以防止收信方事后否认已经接收的信息。 加密技术也是用来加强信息安全的，接下来说的几个非对称加密实际应用也是如此。回归正题，接下来说非对称加密最广泛的应用之一：数字签名。 数字签名 数字签名在ISO7498—2标准中定义为：“附加在数据单元上的一些数据，或是对数据单元所作的密码变换，这种数据和变换允许数据单元的接收者用以确认数据单元来源和数据单元的完整性，并保护数据，防止被人（例如接收者）进行伪造” 首先搞清楚数字签名解决的是什么问题？ 然后看看什么是数字签名？最后分析下数字签名为什么能解决这些问题？ 数字签名解决什么问题？纸质书信或文件根据亲笔签名或印章来证明其真实性，及防抵赖。对应上述信息安全的 完整性和不可抵赖性。 而数字签名则可以看做是对在网络中传输的报文的签名，作用自然也是为了保证信息的完整性及不可抵赖性。 那下面我们看下数字签名是如何做到证明信息的完整性及防抵赖的？ 数字签名的实现方法？建立在公钥密码技术上的数字签名方法有很多，有RSA签名、DSA签名和椭圆曲线数字签名算法（ECDSA）等等。下面对RSA签名进行详细分析。 这里需要理解哈希-hash的概念。简单说hash 就是计算机可以对任意内容计算出一个固定长度的值，且不会重复。 直接看图： （1）发送方采用某种摘要算法从报文中生成一个128位的散列值（称为报文摘要）； （2）发送方用RSA算法和自己的私钥对这个散列值进行加密，产生一个摘要密文，这就是发送方的数字签名； （3）将这个加密后的数字签名作为报文的附件和报文一起发送给接收方： （4）接收方从接收到的原始报文中采用相同的摘要算法计算出128位的散列值； （5）报文的接收方用RSA算法和发送方的公钥对报文附加的数字签名进行解密； （6）如果两个散列值相同，那么接收方就能确认报文是由发送方签名的。 最常用的摘要算法叫做MD5（Message Digest 5）。MD5采用单向Hash函数将任意长度的“字节串”变换成一个128位的散列值，并且它是一个不可逆的字符串变换算法。 数字签名为什么能保证信息完整性及不可抵赖性？信息的完整性如果报文在网络传输过程中被修改，接收方收到此报文后，使用相同的摘要算法将计算出不同的报文摘要，这就保证了接收方可以判断报文自签名后到收到为止，是否被修改过。 信息的不可抵赖性如果发送方A想让接收方误认为此报文是由发送方B签名发送的，由于发送方A不知道发送方B的私钥，所以接收方用发送方B的公钥对发送方A加密的报文摘要进行解密时，也将得出不同的报文摘要，这就保证了接收方可以判断报文是否是由指定的签名者发送。同时也可以看出，当两个散列值相同时，发送方B无法否认这个报文是他签名发送的。 关于数字签名的一点问题关于数字签名就说完了。但有个疑问：传输过程中原文没有被加密吗？是的。上面是无保密机制的数字签名。具有保密机制的RSA签名机制自己看这边文章吧 。 数字证书关于上面数字签名有一个问题：信息接收方如何确认拿到的公钥就是期望的发送方的公钥？ 举个例子： 小红与小绿写信。 小绿写完信后 用自己的私钥对信件摘要生成 ‘数字签名’ 连同信件一块发给小红。 小红收到信件后用小绿的公钥解密信件里的数字签名得到信件摘要。 这个过程没有问题。 但是有一天，第三者-小强出现了。小强偷偷将小红电脑里的小绿的公钥换成他自己的了，但此时小红还以为那是小绿的公钥。 因此，小强就可以冒充小绿，用自己的私钥对信件摘要进行 ‘数字签名’，发给小红。小红用小强掉包后的公钥对数字签名解密，还以为对方是小绿。 后来小红感觉不对劲，他发现自己无法确定公钥是否真的是小绿的。于是她想了一个办法，让小绿找“证书中心”（certificate authority，简称CA） 为自己的公钥做认证。认证机构用自己的私钥对小绿的公钥和一些相关信息一起加密，生成‘数字证书’。 小绿拿到‘数字证书’后，再给苏珊写信，只要在签名的同时，再附上数字证书就行了。小红收信后，用CA的公钥解开数字证书，就可以拿到小绿的公钥了，然后就能验证数字签名是否是小绿的。 这里我们先大概知道CA是一个第三方机构，用来对个人身份认证的，而认证的形式就是‘数字证书’。这个例子中忽略了一个关键细节，如何确定证书的真实性呢？ 接下来我们细细介绍。 https 实例分析https 是数字证书的应用之一。我们通过对https的从简介绍来理解数字证书。 CACA（certificate authority）证书授权中心。 受信任的第三方机构。 CA为每个使用公开密钥的用户发放一个数字证书。证书生成的过程可以认为就是CA用自己的私钥对公钥持有方的公钥及一些相关信息进行数字签名。 数字证书是一个经证书授权中心（CA）数字签名的包含公钥拥有者信息以及公钥的文件。 数字证书的作用是证明证书中列出的用户合法拥有证书中列出的公钥。 根证书而CA的公钥叫做根证书。 这些根证书是预先被安装在浏览器里的,用来解密服务器的证书的。 https 访问通过https建立了一个安全 Web 事务之后，现代的浏览器都会自动获取所连接服务器的数字证书。如果服务器没有证书，安全连接就会失败。浏览器预先安装了一些CA的根证书。浏览器用对应的根证书去解密网站服务器的数字证书获取到网站服务器的公钥。然后浏览器发送一个随机字符串给服务器，服务器用自己的私钥加密这个随机字符串后返回给浏览器，浏览器通过获得的公钥解密后比较这个随机字符串是否和发出去的一样。 如果一样，则说明服务器的公钥和证书里的公钥一致，则证明服务器就是服务器。 当然真实的https过程 比这个复杂很多，这里只是为了方便理解证书在非对称加密应用中的作用，忽略了很多技术细节。 最后静静的学习完了，我们再来说下时下最热的加密币。加密币里的交易安全基础就是非对称加密算法。就以币王BTC（比特币）来说。 比特币钱包: 是用来存放私钥和公钥的，而不是存放币的。 比特币地址: 钱包公钥的哈希值（更短，方便保存和传播），用来收币的。 比特币使用了基于secp256k1椭圆曲线加密算法（非对称加密算法的一种）。 一笔交易实质就是一个地址的一定数量的比特币转移到另一个地址。而交易过程安全则是由其非对称加密算法保障。 最最后总结下本文： 什么是非对称加密 RSA算法的原理和用法 什么是数字签名 什么是数字证书及数字证书的作用 又要上班了。 参考资料数字签名技术原理介绍","categories":[],"tags":[{"name":"RSA","slug":"RSA","permalink":"https://foreverwang.github.io/tags/RSA/"},{"name":"非对称加密","slug":"非对称加密","permalink":"https://foreverwang.github.io/tags/非对称加密/"},{"name":"数字签名","slug":"数字签名","permalink":"https://foreverwang.github.io/tags/数字签名/"}]},{"title":"理解redux","slug":"理解redux","date":"2017-12-06T07:38:51.000Z","updated":"2020-06-21T11:08:05.118Z","comments":true,"path":"2017/12/06/理解redux/","link":"","permalink":"https://foreverwang.github.io/2017/12/06/理解redux/","excerpt":"redux简单介绍前面理解了flux,本篇来理解redux。redux的官方介绍 Redux is a predictable state container for JavaScript apps. 翻译一下：redux 是javascript 应用状态容器，他提供可预测化的状态管理。师出flux,作用和flux一样，作为应用的状态管理层。其核心思想也是单向数据流。 我们先看一个redux 最简单的原生使用实例；然后再胡乱解读一通redux概念；最后通过源码来看下其实现原理。","text":"redux简单介绍前面理解了flux,本篇来理解redux。redux的官方介绍 Redux is a predictable state container for JavaScript apps. 翻译一下：redux 是javascript 应用状态容器，他提供可预测化的状态管理。师出flux,作用和flux一样，作为应用的状态管理层。其核心思想也是单向数据流。 我们先看一个redux 最简单的原生使用实例；然后再胡乱解读一通redux概念；最后通过源码来看下其实现原理。 redux如何使用-代码示例Counter Vanilla 这是redux 官方一个原生代码使用redux的实例，非常好懂。 例子是一个计数器，点击+号 完成加一操作，点击 -号，完成减一操作。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Redux basic example&lt;/title&gt; &lt;script src=\"https://cdn.bootcss.com/redux/3.7.2/redux.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;p&gt; Clicked: &lt;span id=\"value\"&gt;0&lt;/span&gt; times &lt;button id=\"increment\"&gt;+&lt;/button&gt; &lt;button id=\"decrement\"&gt;-&lt;/button&gt; &lt;button id=\"incrementIfOdd\"&gt;Increment if odd&lt;/button&gt; &lt;button id=\"incrementAsync\"&gt;Increment async&lt;/button&gt; &lt;/p&gt; &lt;/div&gt; &lt;script&gt; //counter函数是一个reducer，现在只需要知道reducer就是操作应用数据的方法 function counter(state, action) &#123; if (typeof state === 'undefined') &#123; return 0 &#125; switch (action.type) &#123; case 'INCREMENT': return state + 1 case 'DECREMENT': return state - 1 default: return state &#125; &#125; //实例化一个 store ，store里可以持久化存储应用的数据 state //并且对外暴露几个方法 //其中 getState()用来获取应用的数据 //其中 subscribe()用来添加订阅者，供数据发生变化时通知 //其中 dispatch(action) 触发一个动作用来改变数据 var store = Redux.createStore(counter) var valueEl = document.getElementById('value') //render函数 将数据（state）呈现到view function render() &#123; valueEl.innerHTML = store.getState().toString() &#125; render() //将render 订阅store，数据变了的时候view重新渲染 store.subscribe(render) //通过dispatch触发一个操作 来修改数据 document.getElementById('increment') .addEventListener('click', function () &#123; store.dispatch(&#123; type: 'INCREMENT' &#125;) &#125;) document.getElementById('decrement') .addEventListener('click', function () &#123; store.dispatch(&#123; type: 'DECREMENT' &#125;) &#125;) document.getElementById('incrementIfOdd') .addEventListener('click', function () &#123; if (store.getState() % 2 !== 0) &#123; store.dispatch(&#123; type: 'INCREMENT' &#125;) &#125; &#125;) document.getElementById('incrementAsync') .addEventListener('click', function () &#123; setTimeout(function () &#123; store.dispatch(&#123; type: 'INCREMENT' &#125;) &#125;, 1000) &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 这个例子很简单。 数据存储在store； view（render函数）订阅store,store变化的时候会通知view 进行刷新； 通过store.dispatch 来修改数据 我们的应用无非就是这么几部分： 用户界面（呈现数据）； 应用数据； 操作数据和响应用户操作的方法。 这些即对应MVC架构的view、model、controller。在flux、redux里，也有这些角色，那他们和MVC架构有何不同呢？那就是 flux、redux强制单向数据流来使得数据可预测。 下面我们来看redux的概念和结构。 redux 结构上面这个例子中，状态变化的数据流向是下边这样的： dispatch actions --&gt; store | reducers --&gt; new state --&gt; view | | &lt;----------------------------------------------- 首先创通过createStore(counter)建了一个store。点击加号的过程：触发一个加一的action: store.dispatch({ type: ‘INCREMENT’ }),dispatch 会把这个action分发到reducer（这里是counter)里。reducer 接收当前的应用状态state,返回更改后的state。 到这里数据就完成了一次修改。 由于我们的view 事先订阅了store（store.subscribe(render)）,此时store 会通知view state 变了，view 刷新（调用render方法）。 actionaction概念和 flux里的概念一样，用来描述发生了什么。是一个普通对象，包含一个type属性来描述这个动作， 和其他数据属性。比如 { type: ‘INCREMENT’, num: 1},描述一个增加的动作，增加值为1。 action 扩展 createAction 也和flux 里一样，是一个生成action的函数，输入action中变化的部分作为参数，输出一个action对象.因为同样的action 在应用中可能多次用到，通过createAction函数可以减少重复代码,提高代码复用。 bindActionCreators redux里还提供了bindActionCreators。action只是描述一个行为(好比一个事件event),他本身是不会产生任何影响的，想要触发一个action 让这个描述变成现实，是通过dispatch 方法来触发的（dispatch一个action 好比触发一个event）。而bindActionCreators 就是对dispatch 行为的一个封装，是的业务方触发一个action时可以像普通函数一样调用，而不感知dispatch 的存在。更具体的下面解读源码再说。 reducerreducer 是纯函数。上面我们说了让一个action产生影响是通过dispatch(action)来触发的。 而这里的dispatch 只是触发而已，具体干活的就是reducer，dispatch内部调度reducer。reducer是一个函数，接收当前state和action 返回新的state。 reducer 和 dispatch 共同充当了flux里的dispatcher（registerCallback,dispatch）角色。 reducer扩展 combineReducers 方法实际应用中有不止一个reducer。redux里提供了一个combineReducers()方法来组织这些reducer。具体下边源码分析再说。 store上面我们知道了，我们使用action 来描述发生了什么，使用reducer来根据action更新state。 而store 就是把action 和reducer结合起来的对象，并持有state。store负责： 维持应用的state,并提供getState()方法获取state 提供 dispatch(action) 方法更新 state； 提供 subscribe(listener) / unsubscribe(listener) 来注册和解绑监听者。 Redux 应用只有一个单一的 store，当需要拆分数据处理逻辑时，你应该使用 reducer 组合 而不是创建多个 store。 redux 源码解读(基于redux3.7)先看下代码结构redux 对外暴露五个方法，分别对应五个同名js文件：12345createStore.js //保存应用状态 定义内部方法，输出对外暴露的方法combineReducers.js //将多个reducer 合并成一个bindActionCreators.js //把actionCreator 包了一层dispatch，使用时可以像普通函数一样调用actionCreatorapplyMiddleware.js //组合串联middlewarecompose.js //工具方法，将middleware中间件方法组合成一个调用链 createStore.js这是redux 最核心概念的实现部分。createStore方法的作用是创建一个store,并维持state。下面我们就通过源码看下store 是如何维持state的。 createStore方法接受三个参数：reducer [, preloadedState, enhancer],返回一个store对象，包含4个方法： dispatch //触发action subscribe// 添加监听者 getState //获取当前state replaceReducer observable 以下源码为方便阅读，去掉了原注释，和异常抛错信息。注释信息为解读信息。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177import $$observable from 'symbol-observable'import ActionTypes from './utils/actionTypes'import isPlainObject from './utils/isPlainObject'/** * [createStore description] 通过createStore方法创建一个store,store来维护和持有应用的state * @param &#123;Function&#125; reducer 函数 接收当前state和action为参数返回新的state * @param &#123;any&#125; preloadedState 默认的初始化state，如果你的reducer是通过combineReducers生成的一个顶层reducer, * 那初始state的key值和combineReducers的key是一一对应的 * @param &#123;Function&#125; enhancer store增强器 通常添加中间件 * @return &#123;Store&#125; store，允许你读取state,dispatch actions以及注册订阅者 */export default function createStore(reducer, preloadedState, enhancer) &#123; //允许使用方灵活传参：可以不传默认state 直接传 enhancer参数 if (typeof preloadedState === 'function' &amp;&amp; typeof enhancer === 'undefined') &#123; enhancer = preloadedState preloadedState = undefined &#125; if (typeof enhancer !== 'undefined') &#123; if (typeof enhancer !== 'function') &#123; throw new Error('Expected the enhancer to be a function.') &#125; //这行代码到 applyMiddleWare时说明 return enhancer(createStore)(reducer, preloadedState) &#125; if (typeof reducer !== 'function') &#123; throw new Error('Expected the reducer to be a function.') &#125; //这里是一些函数内的变量，由于闭包特性，这些变量在调用createStore函数后不会被销毁（因为导出的对象方法里面有这些变量的引用）。 //这里指的注意的一点是有两个listeners队列：currentListeners 和 nextListeners；这一点有点厉害了，下面介绍 let currentReducer = reducer let currentState = preloadedState let currentListeners = [] let nextListeners = currentListeners let isDispatching = false //nextListeners是currentListeners的拷贝，我们修改（subscribe）都是对nextListeners的修改 //在flush listeners 之前 nextListeners 同步 currentListeners //这么做可以保证 每次dispatch listener 过程中 subscribe/unsubscribe listerens不会影响当前dispatch 队列，改变值发生在nextListeners，下一次dispatch时生效。 //TODO：我只知道这里这么做有点屌，具体这么做有啥用，我还得研究下 function ensureCanMutateNextListeners() &#123; //nextListeners === currentListener 说明listeners已经被flush; //nextListeners !== currentListener 说明subscribe(listener)后 还未被dispatch if (nextListeners === currentListeners) &#123; nextListeners = currentListeners.slice() &#125; &#125; /** * 读取state * @returns &#123;any&#125; 返回应用的当前state树 */ function getState() &#123; if (isDispatching) &#123; throw new Error('') &#125; return currentState &#125; function subscribe(listener) &#123; if (typeof listener !== 'function') &#123; throw new Error('Expected listener to be a function.') &#125; if (isDispatching) &#123; throw new Error('') &#125; let isSubscribed = true ensureCanMutateNextListeners() nextListeners.push(listener) return function unsubscribe() &#123; if (!isSubscribed) &#123; return &#125; if (isDispatching) &#123; throw new Error('') &#125; isSubscribed = false ensureCanMutateNextListeners() const index = nextListeners.indexOf(listener) nextListeners.splice(index, 1) &#125; &#125; //唯一改变store里数据（state）的方式就是调用store.dispatch //dispatch 做了两件事情：1调用 reducer 更改数据 2 flush 所有listeners //这里和flux有点不同, flux里 观察数据的变化，以及数据变化后的通知，这些需要你自己去实现 这一环节的观察者模式。 //redux自身实现了这一环节的观察者模式，提供了 store.subscribe方法添加listeners，dispatch的时候会 flush这些listeners function dispatch(action) &#123; if (!isPlainObject(action)) &#123; throw new Error('') &#125; if (typeof action.type === 'undefined') &#123; throw new Error('') &#125; // reducer内部不允许再次调用dispatch，否则抛出异常 防止死循环？ if (isDispatching) &#123; throw new Error('Reducers may not dispatch actions.') &#125; try &#123; isDispatching = true currentState = currentReducer(currentState, action) &#125; finally &#123; isDispatching = false &#125; //触发所有的状态监听回调函数 const listeners = currentListeners = nextListeners for (let i = 0; i &lt; listeners.length; i++) &#123; const listener = listeners[i] listener() &#125; return action &#125; // 顾名思义，就是替换当前store在用的reducer // 有什么用呢？你想动态加载某些reducer时,加载后用该方法替换reducer; 如果你想为redux实现热更新机制，也需要该方法 function replaceReducer(nextReducer) &#123; if (typeof nextReducer !== 'function') &#123; throw new Error('Expected the nextReducer to be a function.') &#125; currentReducer = nextReducer dispatch(&#123; type: ActionTypes.REPLACE &#125;) &#125; // function observable() &#123; const outerSubscribe = subscribe return &#123; subscribe(observer) &#123; if (typeof observer !== 'object') &#123; throw new TypeError('Expected the observer to be an object.') &#125; function observeState() &#123; if (observer.next) &#123; observer.next(getState()) &#125; &#125; observeState() const unsubscribe = outerSubscribe(observeState) return &#123; unsubscribe &#125; &#125;, [$$observable]() &#123; return this &#125; &#125; &#125; dispatch(&#123; type: ActionTypes.INIT &#125;) return &#123; dispatch, subscribe, getState, replaceReducer, [$$observable]: observable &#125;&#125; 这里最值得关注的就是currentListeners 和nextListeners这两个listener队列及ensureCanMutateNextListeners方法。每次修改的是nextListeners。每次flush listeners时 将nextListeners和currentListeners同步。 bindActionCreators.js1234567891011121314151617181920212223242526272829//bindActionCreators 用法bindActionCreators(&#123; //第一个参数也可以是一个 actionCreator函数 addCreator, //属性值是actionCreator函数 anotherCreator, ...&#125;,dispatch)//bindActionCreatorfunction bindActionCreator(actionCreator, dispatch) &#123; return function() &#123; return dispatch(actionCreator.apply(this, arguments)) &#125;&#125;//bindActionCreators返回值=&gt; boundActionCreators = &#123; addCreator: bindActionCreator(addCreator, dispatch), anotherCreator: bindActionCreator(anotherCreator, dispatch), &#125;or =&gt; bindActionCreator(actionCreators, dispatch) =&gt; function (...arg) &#123; return dispatch(actionCreator(...arg))) &#125;//actionCreatoractionCreator() =&gt; action (对象)，用的时候dispatch(actionCreator()) bindActionCreators 主要是把actionCreator 包了一层dispatch，使用时可以像普通函数一样调用actionCreator。使得对redux 无感知。 applyMiddleWare12345678910111213141516171819202122import compose from './compose'export default function applyMiddleware(...middlewares) &#123; return (createStore) =&gt; (...args) =&gt; &#123; const store = createStore(...args) let dispatch = store.dispatch let chain = [] const middlewareAPI = &#123; getState: store.getState, dispatch: (...args) =&gt; dispatch(...args) &#125; chain = middlewares.map(middleware =&gt; middleware(middlewareAPI)) dispatch = compose(...chain)(store.dispatch) return &#123; ...store, dispatch &#125; &#125;&#125; compose.js123456789101112export default function compose(...funcs) &#123; if (funcs.length === 0) &#123; return arg =&gt; arg &#125; if (funcs.length === 1) &#123; return funcs[0] &#125; return funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)))&#125; 参考资料 github 中文文档 源码解读 极简教程 极简代码示例","categories":[{"name":"前端状态管理","slug":"前端状态管理","permalink":"https://foreverwang.github.io/categories/前端状态管理/"}],"tags":[{"name":"数据流","slug":"数据流","permalink":"https://foreverwang.github.io/tags/数据流/"},{"name":"redux","slug":"redux","permalink":"https://foreverwang.github.io/tags/redux/"}]},{"title":"《深度工作》笔记","slug":"《深度工作》笔记","date":"2017-10-08T14:54:47.000Z","updated":"2020-06-21T11:08:05.115Z","comments":true,"path":"2017/10/08/《深度工作》笔记/","link":"","permalink":"https://foreverwang.github.io/2017/10/08/《深度工作》笔记/","excerpt":"“深度工作”是现代人的一种非常重要的能力。随着网络智能手机的普及，在给我们生活带来便利的同时也增加了使我们分心的因素。在纷杂碎片化严重的现代人生活中专注力就显得格外重要。与深度工作相对的是浮浅工作。","text":"“深度工作”是现代人的一种非常重要的能力。随着网络智能手机的普及，在给我们生活带来便利的同时也增加了使我们分心的因素。在纷杂碎片化严重的现代人生活中专注力就显得格外重要。与深度工作相对的是浮浅工作。 影响深度工作的因素 开放式的工作空间：更容易受周边环境的打扰。-外因 “邮件系统、钉钉” 等频繁的打断。-外因 度量黑洞：脑力工作不好度量，通过表面上的忙碌，拉长工作时间，不断加班。-外因 最小阻力原则：心里倾向：当我们面前有两件以上事情要选择的时候，我们总是选择阻力最小更容易完成的事情，把难度的事情一直拖，很容易陷入“浮浅工作” 。 -内因 社交网络的成瘾： 微信、微博等。 -内因 四种深度工作模式 禁欲者模式：与世隔绝，通常稀世天才们可以做到。 双峰模式：将时间按照一定周期划分成深度工作和浮浅工作。在时间上集中处理浮浅工作，其他时间深度工作。注意：深度工作的单位至少是一天。 节奏模式：每天有规律的进行深度工作，从几点到几点必须专心的干一件是。一天内至少有一次深度工作和浮浅工作的切换。 比如好多大佬早起工作。 记着模式：随时可以进入深度工作，需要训练。 深度工作的六个技巧 刻意练习：明确的目的，针对需要练习的点不断练习，不断增加难度，逃离舒适区。练习中要及时获得反馈。 批处理浮浅工作。 获得意义感：认知重塑。当我们做的事情和我们的价值观相符合的时候就会有意义感。 改变环境：比如去图书馆看书。 适度休息： 工具优化：工具分两类-娱乐消遣类工具和生产力类工具。列出自己用了哪些生产力工具。 训练深度专注力：先肌肉一样训练 定量化：番茄工作法，不断的锻炼。看自己最多可以连续专注工作多长时间，如看书。可以先定个目标：连续深度看书一小时。 划分优先级：深度工作只给优先级高的工作，其他给浮浅工作。 感想现在自己的工作就感觉到深度工作的时间太少了，总感觉一天忙忙碌碌，最后好像也没干什么重要的事情。原因就在于一天过多的浮浅工作，不断的被别人打断。 以后 每天制定个深度工作的时间段（2到3小时），争取这段时间内不要看钉钉等被打扰的东西。 早起，早上9点到10点半这段时间可以用来学习 连续专注看书目标 1小时–&gt; 2小时。 不看手机。 深度工作的能力是在现代社会中的一个很大的优势。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://foreverwang.github.io/categories/读书笔记/"}],"tags":[{"name":"深度工作","slug":"深度工作","permalink":"https://foreverwang.github.io/tags/深度工作/"}]},{"title":"前端MVC","slug":"前端MVC","date":"2017-10-05T07:49:16.000Z","updated":"2020-06-21T11:08:05.116Z","comments":true,"path":"2017/10/05/前端MVC/","link":"","permalink":"https://foreverwang.github.io/2017/10/05/前端MVC/","excerpt":"前言本文是个人对前端MVC的理解。当我去查MVC资料的时候发现，一千篇文章有一千种MVC，搞的我很纠结。于是研究总结为本文。如果要先一句话介绍什么是MVC，那么： MVC是开发GUI（图形用户界面）程序的一种架构模式。","text":"前言本文是个人对前端MVC的理解。当我去查MVC资料的时候发现，一千篇文章有一千种MVC，搞的我很纠结。于是研究总结为本文。如果要先一句话介绍什么是MVC，那么： MVC是开发GUI（图形用户界面）程序的一种架构模式。 是的，我这里想要搞清的就是前端MVC（包括web前端，客户端开发），不涉及服务端MVC。 说说历史MVC模式最初是在1979年由 TrygveReenskaug在研究Smalltalk-80期间设计出来的。本文称之为经典MVC（以和现代的一千种MVC相区别）。 这么多年过去了，如今的软件环境和当年已大不相同，所以我们今天所看到的MVC已不同往日。比如经典MVC中说 “view永远不应该知道用户输入，比如鼠标操作和按键。” –经典MVC 显然在今天的前端开发中是做不到的，用户输入必须通过监听view上的事件来获得。 因为当年View的功能及其弱，比如鼠标的光标都需要程序自己绘制。经典MVC中，Controller要做的事情多数是派发用户输入给不同的View，并且在必要的时候从View中获取Editor来更改Model，而Web以及绝大多数现在的UI系统中，Controller的这部分职责已经被系统实现了。即现在的view 系统实现的更强大了，比如view自身能响应事件并带有一些事件数据。 经典MVC中称”controller是用户和系统之间的链接”，也就不难理解解了。 所以，如今 view.onclick = … ，在当年就是 mouse.onclick = … 知道了当年和现在软件环境的差异后，那么我们就重点关注那些些没变的东西就好了，也没要去纠结 Smalltalk-80 MVC最初的实现了。变的是环境，不变的是思想。 MVC强制将业务数据（Model）与用户界面（View）隔离，Controller管理业务逻辑和用户输入。 MVC接下来介绍 MVC的各个部件： ModelModel 代表特定领域数据？？，不了解用户界面（view 和controller)；当一个model 发生变化时，他会通知他的观察者（view）； ViewView 描绘的是Model的当前状态。view 通过观察者模式观察 model以了解model何时更新。 Controller在view-controller 对中作用是处理用户交互（如按键和点击等动作），为view 做决定。 MVC的依赖关系 Controller和View 都依赖Model: view 的数据来源为model，controller 调用model的 数据处理方法。 controller和view互相依赖,在一些网上的资料Controller和View之间的依赖关系可能不一样，有些是单向依赖，有些是双向依赖，这个其实关系不大，后面会看到它们的依赖关系都是为了把处理用户行为触发的事件处理权交给Controller。 MVC调用关系 用户交互来源主要是view (或者输入url),view 捕获到操作后，将处理权委托给controller,controller对来自view 的数据预处理，决定调用那个model的那个接口（应用逻辑）；然后有model 执行相应的业务逻辑； model 更新后，通过观察者模式通知view ;view 接收到通知后向model请求最新数据（或者model主动传递）更新自己。 MVC实例http://jsfiddle.net/uVBvq/ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;form action=\"\"&gt; &lt;span id=\"num\"&gt;&lt;/span&gt;&lt;br /&gt; &lt;button type=\"button\" id=\"increase\"&gt;+&lt;/button&gt; &lt;button type=\"button\" id=\"decrease\"&gt;-&lt;/button&gt;&lt;/form&gt;&lt;script&gt;var myapp = &#123;&#125;;myapp.Model = function () &#123; var val = 0; this.add = function (v) &#123; if (val &lt; 100) val += v; &#125;; this.sub = function (v) &#123; if (val &gt; 0) val -= v; &#125;; this.getVal = function () &#123; return val; &#125;; //model拥有 view 的引用？ var views = []; this.register = function (view) &#123; views.push(view); &#125; //model 变化时通知model更新 this.notify = function () &#123; for (var i = 0; i &lt; views.length; i++) &#123; views[i].render(this); &#125; &#125;;&#125;;//view 拥有controller的引用myapp.View = function (controller) &#123; var $incBtn = $('#increase'); var $decBtn = $('#decrease'); var $num = $('#num'); this.render = function (model) &#123; $num.text(model.getVal() + 'px'); &#125;; $incBtn.click(controller.increase); $decBtn.click(controller.decrease);&#125;; myapp.Controller = function () &#123; var model = null; var view = null; this.init = function () &#123; //controller初始化 model 和view model = new myapp.Model(); view = new myapp.View(this); //view 向model 注册自己 model.register(view); model.notify(); &#125;; //controller 负责更新model this.increase = function () &#123; model.add(1); model.notify(); &#125;; this.decrease = function () &#123; model.sub(1); model.notify(); &#125;;&#125;;//外界只接触到controller $(function () &#123; var controller = new myapp.Controller(); controller.init();&#125;);&lt;/script&gt; MVC优缺点优点 耦合性降低：视图和模型分离，利于项目工程化（分工等）。 Model可复用性增强： 因为Model是独立于view的。 缺点 （以下直接引用） Controller测试困难。因为视图同步操作是由View自己执行，而View只能在有UI的环境下运行。在没有UI环境下对Controller进行单元测试的时候，应用逻辑正确性是无法验证的：Model更新的时候，无法对View的更新操作进行断言。 View无法组件化。View是强依赖特定的Model的，如果需要把这个View抽出来作为一个另外一个应用程序可复用的组件就困难了。因为不同程序的的Domain Model是不一样的。 MVC其他ios里的MVC（todo）kvo … 服务端MVC服务端也有MVC，但是经典的MVC模式只是解决客户端图形界面应用程序的问题，而对服务端无效，服务端MVC的变种也有自己的一个名字 MVC Model2 这里不介绍了。 MVC衍生–MVP顺便把mvp说一下吧。MVP是MVC的衍生品。MVP有两种： Passive View Supervising Controller 常见的是Passive View（被动视图），这里也只说这种。 MVP依赖关系 MVP打破了View原来对于Model的依赖，其余的依赖关系和MVC模式一致。 MVP（Passive View）的调用关系 view和model 完全解耦后，model更新是如何同步view的呢？ 是通过presenter。mvc 中是model更新后通知view更新。mvp中是model更新后，通过观察者告知presenter而不是view了。presenter获取到Model变更的消息以后，通过View提供的接口更新界面。 MVP（Passive View）的优缺点（以下直接引用）优点： 便于测试。Presenter对View是通过接口进行，在对Presenter进行不依赖UI环境的单元测试的时候。可以通过Mock一个View对象，这个对象只需要实现了View的接口即可。然后依赖注入到Presenter中，单元测试的时候就可以完整的测试Presenter应用逻辑的正确性。这里根据上面的例子给出了Presenter的单元测试样例。 View可以进行组件化。在MVP当中，View不依赖Model。这样就可以让View从特定的业务场景中脱离出来，可以说View可以做到对业务完全无知。它只需要提供一系列接口提供给上层操作。这样就可以做到高度可复用的View组件。 缺点： Presenter中除了应用逻辑以外，还有大量的View-&gt;Model，Model-&gt;View的手动同步逻辑，造成Presenter比较笨重，维护起来会比较困难。 //todo: 待实例验证优缺点 资料 winter http://www.cnblogs.com/winter-cn/p/4285171.html EFE http://efe.baidu.com/blog/mvc-deformation/ https://github.com/livoras/blog/issues/11 https://speakerdeck.com/jaceju/understanding-the-mvc-mvp-mvvm-in-javascript","categories":[{"name":"架构模式","slug":"架构模式","permalink":"https://foreverwang.github.io/categories/架构模式/"},{"name":"设计模式","slug":"架构模式/设计模式","permalink":"https://foreverwang.github.io/categories/架构模式/设计模式/"}],"tags":[{"name":"MVC","slug":"MVC","permalink":"https://foreverwang.github.io/tags/MVC/"},{"name":"MVP","slug":"MVP","permalink":"https://foreverwang.github.io/tags/MVP/"}]},{"title":"理解Flux","slug":"理解Flux","date":"2017-09-16T13:16:08.000Z","updated":"2020-06-21T11:08:05.117Z","comments":true,"path":"2017/09/16/理解Flux/","link":"","permalink":"https://foreverwang.github.io/2017/09/16/理解Flux/","excerpt":"什么是fluxflux是一种架构模式，用来指导（或约束）我们的软件结构。其核心是“单向数据流模式”。同MVC架构是同样的存在。(举例 ：React 说自己是 MVC 里面 V 的部分，那么 Flux 就相当于添加 M 和 C 的部分) 单向数据流Flux 的核心“单向数据流“的结构和流程： Action –&gt; Dispatcher –&gt; Store –&gt; View","text":"什么是fluxflux是一种架构模式，用来指导（或约束）我们的软件结构。其核心是“单向数据流模式”。同MVC架构是同样的存在。(举例 ：React 说自己是 MVC 里面 V 的部分，那么 Flux 就相当于添加 M 和 C 的部分) 单向数据流Flux 的核心“单向数据流“的结构和流程： Action –&gt; Dispatcher –&gt; Store –&gt; View 首先要有 action，通过定义一些 action creator方法 根据需要创建 Action。 View 层通过用户交互（比如 onClick）会触发 Action Dispatcher 会分发 所触发的 Action 到所有注册的 Store 的回调函数。 Store 回调函数根据接收的 Action 更新自身数据之后会触发一个 change 事件通知 View 数据更改了 View 会监听这个 change 事件，拿到对应的新数据并 更新组件 UI(如调用 setState) 基本概念 View： 视图层 （视图组件） Action（动作）：视图层发出的消息 ：包括消息类型和消息的数据。 Dispatcher（派发器）：用来接收Actions、执行回调函数。 Store：包含应用状态和逻辑。 Action （每个Store有一堆）每个Action都是一个对象，包含一个actionType属性（说明动作的类型）和一些其他属性（用来传递数据）。 Dispatcher (全局一个)Dispatcher 是中心枢纽，其作用是将 Action 派发到 Store，管理所有数据流向。Dispatcher 本质上就是一个事件系统。你可以把它看作一个路由器，负责在 View 和 Store 之间，建立 Action 的正确传递路线。以Facebook 的 Dispatcher 库为例，Dispatcher有两个核心方法： dispatch：派发action到store 注册的回调。 register： store 会调用该方法注册其回调，回调里对不同的action做处理。 Dispatcher 只用来派发 Action，不应该有其他逻辑。且Dispatcher 只能有一个，而且是全局的。各Store在dispatcher上注册自己的回调，这样dispatcher上就有一张回调注册表，与各Store建立联系。 Store（多个） 响应action(事件)Stores 包含应用的状态和逻辑，不同的 Store 管理应用中不同部分的状态。Store响应 Dispatched Actions （被分发的事件）。重点：应用中唯一知道如何更新数据的就是 Store。store在dispatcher上注册的回调接受一个action参数，回调里面是一个switch语句，根据action的type分发给具体state更新方法，store更新完毕后，通过广播事件来告诉view某些状态变了，对应的view取新的状态更新自己。 view （多个）接收用户操作触发action。 action通过dispatcher派发到store里处理更新数据状态，并发出改变的通知，view获取新的状态更新自己。 有什么好处？这里引用尤雨溪知乎的一个回答： 视图组件变得很薄，只包含了渲染逻辑和触发 action 这两个职责，即所谓 “dumb components”。（个人理解：数据层和view层分离） 要理解一个 store 可能发生的状态变化，只需要看它所注册的 actions 回调就可以。（个人理解：和1说的一回事，关注点分离后，是的结构更清晰，代码可读性和可维护性提高） 任何状态的变化都必须通过 action 触发，而 action 又必须通过 dispatcher 走，所以整个应用的每一次状态变化都会从同一个地方流过。其实 Flux 和传统 MVC 最不一样的就在这里了。React 在宣传的时候一直强调的一点就是 “理解你的应用的状态变化是很困难的 (managing state changing over time is hard)”，Flux 的意义就在于强制让所有的状态变化都必须留下一笔记录，这样就可以利用这个来做各种 debug 工具、历史回滚等等。（个人理解：使数据可预测） 参考资料具体实例可以参考阮老师的这边文章 ：Flux 架构入门教程 这篇总结的非常到位，但是前提是得你先大概理解了flux：flux总结 facebook 官方提供的 dispatcher","categories":[{"name":"前端状态管理","slug":"前端状态管理","permalink":"https://foreverwang.github.io/categories/前端状态管理/"}],"tags":[{"name":"flux","slug":"flux","permalink":"https://foreverwang.github.io/tags/flux/"},{"name":"数据流","slug":"数据流","permalink":"https://foreverwang.github.io/tags/数据流/"}]},{"title":"设计模式之工厂模式","slug":"设计模式之工厂模式","date":"2017-08-27T09:13:22.000Z","updated":"2020-06-21T11:08:05.118Z","comments":true,"path":"2017/08/27/设计模式之工厂模式/","link":"","permalink":"https://foreverwang.github.io/2017/08/27/设计模式之工厂模式/","excerpt":"设计模式-创建型之工厂模式创建型设计模式共六种： 简单工厂模式 工厂方法模式 抽象工厂模式 建造者模式 原型模式 单例模式 本篇讲三个工厂模式： 简单工厂、工厂方法、抽象工厂。","text":"设计模式-创建型之工厂模式创建型设计模式共六种： 简单工厂模式 工厂方法模式 抽象工厂模式 建造者模式 原型模式 单例模式 本篇讲三个工厂模式： 简单工厂、工厂方法、抽象工厂。 创建型设计模式是用来创建对象的，在面向对象的编程中最常用的一种创建对象方式是用new操作符产生一个对象实例。创建型模式对类的实例化过程进行了抽象，能够将对象的创建与对象的使用过程分离。 简单工厂模式模式定义简单工厂模式：又称静态工厂模式。在该模式中可以通过参数的不同返回不同的实例。简单工厂模式专门定义一个类来负责创建其他类的实例。被创建的实例通常都具有共同的分类。 模式的结构 Factory-工厂角色： 负责实现创建所有实例的内部逻辑。 Product-抽象产品角色： 创建的所有对象的父类，负责描述所有实例所共有的公共接口。 ConcreteProduct-具体产品角色：创建的目标，所有创建的对象都充当这个角色的某个具体类的实例。 当然，实际应用中可能没有这么严格的三个角色。但 Factory和 ConcreteProduct是必须的。 简单工厂的核心定义是：有一个工厂方法（也可以是工厂类）根据接收的参数 实例化具体的类，并且返回这个类的实例。 实例分析这里用一个生产宝马汽车的例子。现在有两个型号的宝马车：BMW320和BMW523。假设此时没有宝马工厂。用户需要这个这两个型号的车的时候需要 自己去制造生产。代码如下： 没有工厂的时候： 123456789101112131415161718public class BMW320 &#123; public BMW320 &#123; System.out.println('生产320型号的宝马车'); &#125;&#125;public class BMW523 &#123; public BMW523 &#123; System.out.println('生产320型号的宝马车'); &#125;&#125;public class Customer &#123; public static void main(String[] args) &#123; BMW320 bmw320 = new BMW320(); BMW523 bmw523 = new BMW523(); &#125;&#125; 这样客户也造出了汽车，似乎也没啥毛病。问题在于：客户需要知道怎么去创建一款车（具体new 哪个类） 这样客户和车是耦合在一起的。但车型有很多的时候，客户就需要知道每一个型号的车对应哪个类。为了解耦，我们引入简单那工厂模式 ：创建一个工厂，将创建具体那个型号的宝马车的操作细节放到工厂里，客户直接使用工厂的创建产品的方法，传入具体的型号就好了。 有了简单工厂： 产品类1234567891011121314abstract class BMW &#123;&#125;public class BMW320 extends BMW &#123; public BMW320() &#123; System.out.println(\"制造--&gt;BMW320\"); &#125;public class BMW523 extends BMW &#123; public BMW523()&#123; System.out.println(\"制造--&gt;BMW523\"); &#125; &#125; 工厂类 1234567891011121314151617public class BMWFactory &#123; public BMW createBMW (int type) &#123; switch (type) &#123; case: 320 return new BMW320(); case: 523 return new BMW523(); default: break; &#125; return null; &#125;&#125; 客户类 1234567public class Customer &#123; public static void main(Sting[] args) &#123; BMWFactory factory = new BMWFactory(); BMW bmw320 = factory.createBMW(320); BMW bmw523 = factory.createBMW(523); &#125; &#125; 可以看到 具体实例化某一个class 的操作放到了工厂类里，客户只需要调用工厂方法并传参就OK了。 模式分析简单工厂的优点： 客户端更方便了：无需记忆众多复杂的类名，只需要知道具体产品类所对应的参数。 责任分割： 创建产品的逻辑都放在工厂，客户端仅仅是消费产品，从而免去了直接创建产品对象的责任。 简单工厂的缺点： 违背开闭原则的 对修改关闭。当需要新增加一类产品的时候，除了增加创建该类产品的代码外还需要修改工厂类。 简单工厂适用场景 工厂类负责创建的对象比较少：由于创建的对象少，不会造成工厂法法中的业务逻辑泰国复杂。 工厂方法上面我们知道了，当产品种类多了后，工厂就会很庞大，且新增一类产品就要改工厂类。此时工厂方法模式就上场了。 模式定义在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。 模式的结构 Factory-抽象工厂类： 声明了工厂方法(Factory Method)，用于返回一个产品。抽象工厂是工厂方法模式的核心，所有创建对象的工厂类都必须实现该接口。 ConcreteFactory-具体工厂类： 它实现了抽象产品接口，一类工厂生产一类产品。 Product-抽象产品类： 定义产品的接口。可以是抽象类或接口。 ConcreteProduct-具体产品类： 实现抽象产品类的接口，产品和工厂一一对相应。 实例分析还是接着上边简单工厂造宝马车的例子。 产品类，和简单工厂里一样12345678910111213141516171819202122232425262728293031323334353637383940 abstract class BMW &#123; public BMW()&#123; &#125; &#125; public class BMW320 extends BMW &#123; public BMW320() &#123; System.out.println(\"制造--&gt;BMW320\"); &#125; &#125; public class BMW523 extends BMW&#123; public BMW523()&#123; System.out.println(\"制造--&gt;BMW523\"); &#125; &#125; ``` 工厂类： 抽象工厂类定义工厂类接口，工厂类创建具体的一类产品。``` java interface FactoryBMW &#123; BMW createBMW(); &#125; public class FactoryBMW320 implements FactoryBMW&#123; @Override public BMW320 createBMW() &#123; return new BMW320(); &#125; &#125; public class FactoryBMW523 implements FactoryBMW &#123; @Override public BMW523 createBMW() &#123; return new BMW523(); &#125; &#125; 客户类：客户生产某类产品 直接实例化具体的工厂。 123456789public class Customer &#123; public static void main(String[] args) &#123; FactoryBMW320 factoryBMW320 = new FactoryBMW320(); //可通过配置文件实现 BMW320 bmw320 = factoryBMW320.createBMW(); FactoryBMW523 factoryBMW523 = new FactoryBMW523(); BMW523 bmw523 = factoryBMW523.createBMW(); &#125; &#125; 模式分析工厂方法模式是简单工厂模式的进一步抽象。由于使用了面向对象的多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。工厂方法模式可以允许在不修改工厂角色的情况下引进新产品。 基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，是因为所有的具体工厂类都具有同一抽象父类。 工厂方法模式优点 符合开闭原则（克服了简单工厂的缺点）。引入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。 工厂方法模式的缺点 系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。 工厂方法模式的适用场景 当需要的产品种类多变，系统需要有比较好的扩展性时，可以考虑工厂模式，不同的产品用不同的实现工厂来组装。 工厂方法模式疑问到这里我是有点疑问的：工厂方法模式中，客户端就得知道生产某类产品对应的工厂类，当产品种类多的时候，那不就面临没有任何工厂模式时同样的问题？这个问题可以通过配置文件解决。通过配置文件来存储具体工厂类ConcreteFactory的类名，更换新的具体工厂时无须修改源代码，系统扩展更为方便。 那么问题又来了：那我不用工厂方法模式，我生产具体的产品（new ConcreteProduct）时，也通过配置文件来存储产品类的类名，那不就不需要工厂类了吗？ 那工厂方法模式的意义是啥呢？我的理解是 ：实际工作中，工厂类 不只是简单的new ConcreteProduct(), 同时还做一些初始化操作，比如处理前置依赖等。把这些封装在工厂类内，使得代码封装程度更高。 抽象工厂为了更好的理解抽象工厂模式，先说两个概念： 产品等级结构 ：产品等级结构即产品的继承结构，如一个抽象类是电视机，其子类有海尔电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。 产品族 ：产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中。 当系统所提供的工厂所需生产的具体产品并不是一个简单的对象，而是多个位于不同产品等级结构中属于不同类型的具体产品时需要使用抽象工厂模式。 模式的结构 Factory-抽象工厂类 定义了一组用于创建一组产品的方法，每个方法对应一种产品。 ConcreteFactory-具体工厂类 实现抽象工厂中定义的创建一组产品的方法，生产一组产品。一对多。 Product-抽象产品类 定义产品接口 ConcreteProduct-具体产品类：它定义具体工厂生产的具体产品对象，实现抽象产品接口中声明的业务方法。 抽象工厂中声明了多个工厂方法，用于创建不同类型的产品。 实例分析这里改造一下上面生产宝马汽车的例子。现在我们不是生产汽车了而是生产汽车配件。现需要两种汽车配件：汽车发动机，汽车空调。还是有两个宝马型号的汽车 BMW320、BMW523。 产品类1234567891011121314151617181920212223242526272829//发动机以及型号 public interface Engine &#123; &#125; public class EngineA extends Engine&#123; public EngineA()&#123; System.out.println(\"制造--&gt;EngineA\"); &#125; &#125; public class EngineBextends Engine&#123; public EngineB()&#123; System.out.println(\"制造--&gt;EngineB\"); &#125; &#125; //空调以及型号 public interface Aircondition &#123; &#125; public class AirconditionA extends Aircondition&#123; public AirconditionA()&#123; System.out.println(\"制造--&gt;AirconditionA\"); &#125; &#125; public class AirconditionB extends Aircondition&#123; public AirconditionB()&#123; System.out.println(\"制造--&gt;AirconditionB\"); &#125; &#125; 创建工厂类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//创建工厂的接口 public interface AbstractFactory &#123; //制造发动机 public Engine createEngine(); //制造空调 public Aircondition createAircondition(); &#125; //为宝马320系列生产配件 public class FactoryBMW320 implements AbstractFactory&#123; @Override public Engine createEngine() &#123; return new EngineA(); &#125; @Override public Aircondition createAircondition() &#123; return new AirconditionA(); &#125; &#125; //宝马523系列配件 public class FactoryBMW523 implements AbstractFactory &#123; @Override public Engine createEngine() &#123; return new EngineB(); &#125; @Override public Aircondition createAircondition() &#123; return new AirconditionB(); &#125; &#125; //客户端 public class Customer &#123; public static void main(String[] args)&#123; //生产宝马320系列配件 FactoryBMW320 factoryBMW320 = new FactoryBMW320(); factoryBMW320.createEngine(); factoryBMW320.createAircondition(); //生产宝马523系列配件 FactoryBMW523 factoryBMW523 = new FactoryBMW523(); factoryBMW320.createEngine(); factoryBMW320.createAircondition(); &#125; &#125; 模式分析抽象工厂模式的优点 首先是该模式适应了某种业务场景 符合“开闭原则”：增加新的具体工厂和产品族很方便，无须修改已有系统。 抽象工厂模式的缺点 在添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便。 开闭原则的倾斜性（增加新的工厂和产品族容易，增加新的产品等级结构麻烦） 抽象工厂模式的适用场景 当系统所提供的工厂所需生产的具体产品并不是一个简单的对象，而是多个位于不同产品等级结构中属于不同类型的具体产品时需要使用抽象工厂模式。 一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是重要的。 系统提供一个产品类的库，所有的 产品以同样的接口出现，从而使客户端不依赖于具体实现。 与工厂方法的区别抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构，一个工厂等级结构可以负责多个不同产品等级结构中的产品对象的创建 。当一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象时，抽象工厂模式比工厂方法模式更为简单、有效率。 工厂模式的退化 当抽象工厂模式中每一个具体工厂类只创建一个产品对象，也就是只存在一个产品等级结构时，抽象工厂模式退化成工厂方法模式； 当工厂方法模式中抽象工厂与具体工厂合并，提供一个统一的工厂来创建产品对象将创建对象的工厂方法设计为静态方法时，工厂方法模式退化成简单工厂模式。 三个工厂模式 完。 http://blog.csdn.net/jason0539/article/details/44956775 https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/creational.html","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://foreverwang.github.io/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://foreverwang.github.io/tags/设计模式/"},{"name":"工厂模式","slug":"工厂模式","permalink":"https://foreverwang.github.io/tags/工厂模式/"},{"name":"创建型模式","slug":"创建型模式","permalink":"https://foreverwang.github.io/tags/创建型模式/"}]},{"title":"随笔：《王者荣耀》-论网游成瘾","slug":"随笔：《王者荣耀》-论网游成瘾","date":"2017-07-16T16:34:35.000Z","updated":"2020-06-21T11:08:05.118Z","comments":true,"path":"2017/07/16/随笔：《王者荣耀》-论网游成瘾/","link":"","permalink":"https://foreverwang.github.io/2017/07/16/随笔：《王者荣耀》-论网游成瘾/","excerpt":"随笔：游戏成瘾以前一直不明白那些网瘾少年为什么网络游戏如此痴迷。都是些虚虚假假的游戏，有什么好沉迷的。大概正是因为我没有深入玩过任何一款网络游戏所以才有这个疑惑。就好像一直不明白传销的那些人如何被洗脑的一样，怎么会那么啥？ 入手《王者荣耀》初衷是想探探网络游戏究竟是什么如此令人着迷。也断断续续的完了好长时间了。来做个记录吧。","text":"随笔：游戏成瘾以前一直不明白那些网瘾少年为什么网络游戏如此痴迷。都是些虚虚假假的游戏，有什么好沉迷的。大概正是因为我没有深入玩过任何一款网络游戏所以才有这个疑惑。就好像一直不明白传销的那些人如何被洗脑的一样，怎么会那么啥？ 入手《王者荣耀》初衷是想探探网络游戏究竟是什么如此令人着迷。也断断续续的完了好长时间了。来做个记录吧。 着迷的并不是游戏本身着迷的并不是游戏本身，而是游戏设计者在游戏中设计的很多”陷阱”。一下从简说下我的感受吧。这些陷阱包括：好胜心，贪婪，虚荣心… 好胜心：我们在杀掉他人并取得胜利的时候会有爽快感觉。 贪婪：我们在赢了之后还想再赢，再输了之后还想赢回来 虚荣心：我们行不断提升段位，获得更多的MVP成就数据，因为这些能被游戏好友、微信好友看到。 吸引你的更多的是游戏本身之外的东西 如果这个游戏没有了段位设定，还会有这么多人如此痴迷吗？ 如果这个游戏里不是基于微信或qq帐号体系的，甚至游戏里不能互相交流也永远不知道谁是谁 还会有这么多人如此痴迷？ 网游的根本目标是盈利游戏策划者在游戏里设计那么多陷阱，最终是为了实现盈利的目标。首先要有人玩，有很多人玩，然后这其中有部分人愿意花钱买单就行了。举几个例子： 首冲游戏里首冲一般都有奖励，这个是先建立你的支付习惯。 抽奖概率每个玩家每个阶段中奖概率肯定不一样。通常前期中奖概率会高一点，好引诱你冲更多的值。后面会根据玩家的行为做概率调整，比如判定大拿玩家和普通玩家的概率，对不同阶段的概率都会有波动调整。最终为了让你花钱或化更多的钱来参与。 匹配机制这也是影响有游戏声明周期的关键环节。在保证游戏的平衡性大前提下，根据你的游戏记录适当倾斜下难易程度，比如当你连赢几把的时候，肯定就要给你匹配些强对手和弱队友了。让你不那么容易的升到顶级。实时证明王者荣耀这个匹配做的很极致。 社交属性当然网友还有一大属性是社交属性，先不说这点了… 等等吧不断增加英雄，赛季重置等 这都是延长游戏生命周期的又一手段。增加皮肤，抽奖等都是为了增加盈利… 最初我们为什么玩游戏？这里不说职业玩家，就说普通玩家。本来我们玩游戏是为了放松，休闲。然而我发现每次我玩完都会很累。当我们得到的结果不符合我们的目标预期的时候，我们就要注意了，肯定有坑。然而游戏策划们就是利用人们的各种人性的弱点或者优点让你玩更久的游戏话更多的钱。而这一切都是你愿意的。 结语没啥逻辑，想到啥就写了。总之手游大多是坑，他们都是为了赚钱。我已经不再主动玩这这个游戏了（好友邀请可以玩一把，这就是他的社交属性的体现了）。 真正的结语再想想这些网友的沉迷，往往并不是对有游戏的热爱和痴迷，而是更多的是对自己的暂时性失控。玩玩单机游戏吧，坑少些。有个电影叫《爆裂鼓手》，其中男主的偏执最后算是一种痴迷吧。玩网友的沉迷算是一种痴迷吗？也算是吧，对职业玩家来说。也算是吧，只是并不是我们想要的。","categories":[{"name":"随笔","slug":"随笔","permalink":"https://foreverwang.github.io/categories/随笔/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://foreverwang.github.io/tags/随笔/"},{"name":"游戏","slug":"游戏","permalink":"https://foreverwang.github.io/tags/游戏/"}]},{"title":"深入理解JSX","slug":"深入理解JSX","date":"2017-07-09T16:06:54.000Z","updated":"2020-06-21T11:08:05.117Z","comments":true,"path":"2017/07/09/深入理解JSX/","link":"","permalink":"https://foreverwang.github.io/2017/07/09/深入理解JSX/","excerpt":"JSX 是啥? JSX = JS + XML JSX提供了一种可以在JS里写XML的语法。 JSX的运行环境 没有环境可以直接直接执行JSX代码","text":"JSX 是啥? JSX = JS + XML JSX提供了一种可以在JS里写XML的语法。 JSX的运行环境 没有环境可以直接直接执行JSX代码 最终JSX代码在运行前都被转换成了JS。转换方式： 静态编译器编译（工具babel） 运行期通过jsxtransform.js 进行转换。（已被facebook废弃，性能问题） 思考：浏览器或者js引擎为什么不直接支持jsx? –&gt;继续看下边 JSX的由来JSX是伴随着facebook的javascript类库 react 的出现被发明的。jsx 的出现和虚拟DOM有直接关系的。 一句话介绍虚拟DOM： 在内存中创建的描述DOM节点的js对象。为了减少对实际DOM的操作从而提升性能。（这里可以先不管什么是虚拟DOM） 如何创建虚拟DOM：123var child1 = React.createElement('li', null, 'First Text Content');var child2 = React.createElement('li', null, 'Second Text Content');var root = React.createElement('ul', &#123; className: 'my-list' &#125;, child1, child2); ==&gt; ‘虚拟Dom对象 ‘ ==&gt; 1234&lt;ul class=\"my-list\"&gt; &lt;li&gt; 'First Text Content' &lt;/li&gt; &lt;li&gt; 'Second Text Content' &lt;/li&gt;&lt;/ul&gt; 使用这样的机制，我们完全可以用JavaScript构建完整的界面DOM树，但是代码编写麻烦，可读性差（IOS类似，ios是否可以借鉴jsx?）。于是React发明了JSX，利用更友好的HTML语法来创建虚拟DOM： 123456 var root =( &lt;ul className=\"my-list\"&gt; &lt;li&gt;First Text Content&lt;/li&gt; &lt;li&gt;Second Text Content&lt;/li&gt; &lt;/ul&gt;); 一句话总结jsx存在的意义 让我们更直观的愉快的写代码。 前端界面的最基本功能在于展现数据，为此大多数框架都使用了模板引擎，就对应了自己的模板语法：如angular.js 123456&lt;div ng-if=\"person != null\"&gt; Welcome back, &lt;b&gt;&#123;&#123;person.firstName&#125;&#125; &#123;&#123;person.lastName&#125;&#125;&lt;/b&gt;!&lt;/div&gt;&lt;div ng-if=\"person == null\"&gt; Please log in.&lt;/div&gt; jsx的优势之一就是不需要掌握一门模板语法。如果说掌握一种模板语言并不是很大的问题，那么其实由模板带来的架构复杂性则是让框架也变得复杂的重要原因：http://www.infoq.com/cn/articles/react-jsx-and-component React直接放弃了模板而发明了JSX。 JSX的语法这里不会对jsx语法详细介绍，只介绍一些注意点。详情 一、通过{}插入js表达式1var person = &lt;Person name=&#123;window.isLoggedIn ? window.name : ''&#125; /&gt;; 这个功能就很强大了，你可以尽情的使用js的功能： 二、组件tag 大小写敏感这里还不是一般的敏感，大小写是有限制的。所有对应证实节点的tag 要小写开头，所有组件节点tag 要大写开头。大小写是告诉转换工具（babel）要如何转换。我们看个例子： 123React.render(&lt;div&gt;xxx&lt;/div&gt;)React.render(&lt;App/&gt;) 转换后==&gt; 1234567React.render(React.createElement( \"div\", //小写tag会编成字符串 null, \"xxx\"));React.render(React.createElement(App, null));//大写编成变量 一句话总结标签大小写注意点： 可以不用关心这些细节，这些都是给框架用的，只需要知道何时大写何时小写就好。 三、绑定事件绑定方式：1&lt;div onClick=&#123;this.handler.bind(this)&#125;&gt;Submit&lt;/div&gt; 无需手动解绑事件在JSX中你不需要关心什么时机去移除事件绑定，因为React会在对应的真实DOM节点移除时就自动解除了事件绑定。 事件代理React并不会真正的绑定事件到每一个具体的元素上，而是采用事件代理的模式：在根节点document上为每种事件添加唯一的Listener，然后通过事件的target找到真实的触发元素。这样从触发元素到顶层节点之间的所有节点如果有绑定这个事件，React都会触发对应的事件处理函数。这就是所谓的React模拟事件系统。 四、在JSX中使用样式通常情况下我们应该把样式写到css文件里，当有时对于特定组件而言其样式比较简单且或固定，那么可将其直接写在jsx中。在jsx中通过style属性来定义，但和真实DOM不同的是，属性值不能是字符串而必须为对象。 1&lt;div style=&#123;&#123;color: '#ff0000', fontSize: '14px'&#125;&#125;&gt;Hello World.&lt;/div&gt; 这里有两层大括号，外面的大括号是JSX的语法，变的大括号是js对象。 属性名转驼峰在JSX中可以使用所有的的样式，基本上属性名的转换规范就是将其写成驼峰写法，如background-color –&gt; backgroundColor。 JSX 与babel如何让babel将JSX传换成js时指定自定义方法名而不是React.createElement()。这个babel支持配置：.babelrc文件 详情 1234567&#123; \"plugins\": [ [\"transform-react-jsx\", &#123; \"pragma\": \"dom\" // default pragma is React.createElement &#125;] ]&#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"https://foreverwang.github.io/categories/javascript/"},{"name":"React","slug":"javascript/React","permalink":"https://foreverwang.github.io/categories/javascript/React/"}],"tags":[{"name":"JSX","slug":"JSX","permalink":"https://foreverwang.github.io/tags/JSX/"},{"name":"React","slug":"React","permalink":"https://foreverwang.github.io/tags/React/"}]},{"title":"javascript函数节流（throttle）和函数防抖（debounce）及其实现","slug":"javascript函数节流(throttle)和函数防抖(debounce)及其实现","date":"2017-05-07T15:37:39.000Z","updated":"2020-06-21T11:08:05.114Z","comments":true,"path":"2017/05/07/javascript函数节流(throttle)和函数防抖(debounce)及其实现/","link":"","permalink":"https://foreverwang.github.io/2017/05/07/javascript函数节流(throttle)和函数防抖(debounce)及其实现/","excerpt":"throttle(节流)和debounce(防抖)说来很相似：作用是防止一个函数内的某些代码在一定的时间间隔内高频率调用。当然两者也是有细微差别的，下面分别看下这两个概念。","text":"throttle(节流)和debounce(防抖)说来很相似：作用是防止一个函数内的某些代码在一定的时间间隔内高频率调用。当然两者也是有细微差别的，下面分别看下这两个概念。 使用场景当遇到触发频率很高的事件时，其事件回调也会随之高频率的被调用，这样就可能会出现页面卡顿现象，为了解决这类问题，通常使用throttle(节流)或debounce(防抖)来控制事件回调主要逻辑代码被执行的频率。这些事件需要包括： 鼠标事件：mousemove(拖曳)/mouseover(划过)/mouseWheel(滚屏) click(连续点击) 键盘事件：keypress(基于ajax的用户名唯一性校验)/keyup(文本输入检验、自动完成)/keydown(游戏中的射击) window的resize/scroll事件(DOM元素动态定位) 接下来看看具体概念和区别。 概念及区别函数在一定的时间间隔内只能被调用一次： debounce 若在这段时间间隔内又想要调用函数，则将重新计算时间间隔。 throttle 若在这段时间间隔内又想调用该函数，则函数调用将会被提前阻止从而放弃这次调用。 直到上一次调用函数后的时间间隔过后，下一次企图调用函数才能得逞。 注意：上面是说的是函数调用的频率，具体到业务里代码里可能不是具体某个函数而是函数内某些代码。 打个比方如果上面的区别还是不太明了，那我们举个电梯的栗子吧：假设电梯门在有人进入10s后会关闭，我们简称这一过程为–关门指令。每次有人键入电梯，电梯就企图创建一个关门指令。 deboucce 你进入电梯，一个关门指令被电梯创建；如果10s内又有人进入电梯，则这个10s的间隔会重新计算-相当于销毁上一个关门指令，重新创建一个；直到最后一个10s的间隔内没有人再进入了，电梯门才会被关闭，即最后一个关门指令生效。 throttle 你进入电梯，一个关门指令被电梯创建；如果10s内又有人进入电梯，则这段间隔内企图10s后再关门这个指令会被丢弃，即10s内只有第一个关门指令会生效。10s后不管还有么有人向上电梯，电梯门都将关闭。–这种电梯简直是反人类，大概只会出现在我这个例子里。 概念说了，比方也打了，接下来我们一步一步实现deboucce和throttle。 再多说一句，其实你也不必非要严格区分这两个概念。你只要知道他俩都是用来避免连续高频触发一些代码的执行的。他俩的区别是debouce在指定的间隔内再次试图触发某些代码执行的时候 这个时间间隔会被重新计算，而throttle不会。然后能在具体的场景选择响应的方法就好了。 具体实现这一部分我们通过一个实际场景一步一步分析来实现。假设的场景：页面中有一个按钮，这个按钮点击后会执行页面跳转的动作。此时我们不希望快速点击会触发多次这个动作。 分析： 因为页面跳转后通常我们是没有回调即收不到通知的，所以这里防止连续点击触发回调只能通过约定时间间隔来实现，这里我们用600ms作为这个时间间隔。 点击按钮后600ms内的点击无效。 这个事件间隔可以通过标志变量+setTimeout来实现；也可以通过前后点击的时间戳的差值来实现。这里我们先用第一种方式。 1&lt;div class=\"btn\"&gt;我是一个按钮&lt;/div&gt; 下面是只考虑实现上述需求，没有任何封装性。 12345678910111213141516171819202122232425var btn = document.querySelector('.btn');//方案一：时间间隔:标志变量 + setTimeoutvar canRun = true; //标志变量var immediate = true;//第一次响应时是否需要执行响应的代码btn.onclick = function()&#123; if(!canRun)&#123; console.log('点击太频繁'); return; &#125; //只要函数被执行了就把标志变量的状态置反，直到约定的时间间隔到了再置回。 canRun = false; function handler()&#123; console.log('click'); canRun = true; &#125; if(immediate)&#123; handler();//第一次调用 console.log('首次立即调用'); immediate = false; &#125;else&#123; setTimeout(handler,600); &#125;&#125; 标志变量canRun 初始值true;当click事件回调执行时先判断这个变量，如果为真则后面的代码会被执行。并且 标志变量canRun赋值为false; 后边的代码包括 根据immediate标志位（初始值true）是否立即调用handler；immediate为假则开一个定时器600ms后调用handler，handler会把标志变量置位true; 在上一次点击后的600ms内再次点击这时候canRun 为false，函数会直接返回，后边的代码不会被执行。 功能很简单，上面就是实现了函数节流（throttle）的功能。加下来我们将throttle抽象一下封装成可供外部调用的throttle方法。 throttle实现分析：我们要实现的throttle方法只负责 是否能执行某些代码的逻辑实现。时间间隔、要执行的函数、是否立即执行 这些都是使用方决定的，即这些作为throttle方法的参数传入。12345678910111213141516171819202122function throlle(handler,delay,immediate)&#123; var canRun = true; return function()&#123; if(!canRun)&#123; return; &#125; canRun = false; if(immediate)&#123; handler(); immediate = false; setTimeout(function()&#123; canRun = true; &#125;, delay); &#125;else&#123; setTimeout(function()&#123; handler(); //todo:参数传递 canRun = true; &#125;, delay); &#125; &#125;&#125; debounce实现分析：让我们回一下debounce和throttle的区别：debounce事件间隔会被重新计时，及在非空闲期内触发了回调,回调内会把定时器clear掉，重新创建一个定时器，事件间隔也即随之重新计算了。12345678910111213141516171819202122function debounce(handler,delay,immediate)&#123; var canRun = true; var timer = null; return function()&#123; if(!canRun)&#123; clearTimeout(timer); //唯一的区别就在这里 &#125; canRun = false; if(immediate)&#123; handler(); immediate = false; setTimeout(function()&#123; canRun = true; &#125;, delay); &#125;else&#123; timer = setTimeout(function()&#123; handler(); //todo:参数传递 canRun = true; &#125;, delay); &#125; &#125;&#125; 以上也只是一个简单的实现，还有些可以优化的地方。除了用setTimeout来控制时间间隔，亦可以通过时间戳来实现：即比较前后两次出发的时间出之差是否大于阈值。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://foreverwang.github.io/categories/javascript/"}],"tags":[{"name":"函数节流（throttle）","slug":"函数节流（throttle）","permalink":"https://foreverwang.github.io/tags/函数节流（throttle）/"},{"name":"函数防抖（debounce）","slug":"函数防抖（debounce）","permalink":"https://foreverwang.github.io/tags/函数防抖（debounce）/"}]},{"title":"Javascript之执行上下文","slug":"Javascript之执行上下文","date":"2017-04-09T08:21:50.000Z","updated":"2020-06-21T11:08:05.114Z","comments":true,"path":"2017/04/09/Javascript之执行上下文/","link":"","permalink":"https://foreverwang.github.io/2017/04/09/Javascript之执行上下文/","excerpt":"关键词 执行期上下文（excution context简称EC）：简称上下文（又叫执行环境） 作用域链 （scope chain） 变量对象（variable object简称VO） 活动对象（activation object简称AO） 概述执行上下文是Javascript中最重要的一个概念。每一段代码的执行都与它息息相关。理解了它，才能真正理解我们写的的javascript代码是如何运行的。ECMA-262（5.1）中写道：当控制器转入 ECMAScript的可执行代码时，控制器会进入(注：创建)一个执行上下文。","text":"关键词 执行期上下文（excution context简称EC）：简称上下文（又叫执行环境） 作用域链 （scope chain） 变量对象（variable object简称VO） 活动对象（activation object简称AO） 概述执行上下文是Javascript中最重要的一个概念。每一段代码的执行都与它息息相关。理解了它，才能真正理解我们写的的javascript代码是如何运行的。ECMA-262（5.1）中写道：当控制器转入 ECMAScript的可执行代码时，控制器会进入(注：创建)一个执行上下文。 可执行代码这里先解释下上面提到的可执行代码，我们看一下ES5规范（以下从简了） 全局代码：是指被作为ECMAScript程序处理的源代码文本。一个特定程序的全局代码不包括作为函数体被解析的源代码文本。 函数代码：是指作为函数体被解析的源代码文本。不包括作为其嵌套函数的 函数体 被解析的源代码文本。 Eval 代码 是指提供给eval内置函数的源代码文本。（现在应用比较少，这一点本文忽略） 现在可以对上面关于上下文的说法换一种说法： 当控制器转入 ECMAScript的全局代码，控制器会创建一个全局上下文。 当转入函数代码，控制器会创建一个函数上下文。 执行上下文我们已经知道了什么时候会创建一个上下文，那接下来就要说下上下文具体是个什么东西。ES5规范里说：执行上下文包含所有用于追踪与其相关的代码的执行进度的状态。翻译一下是说：执行上下文里有代码执行时需要用到的东西。现在问题就具体到了：执行上下文里都有什么？那么我们来看一下： 执行上下文的组成 组件 内部组成 作用 变量对象（VO） {vars:…,function declarations:…,arguments:…,…} 指定一个词法环境对象，其环境数据用于保存由该执行上下文内的变量声明 和 函数声明。 作用域链（scope chain） [ variable object + [[scope]]） 指定一个词法环境对象，用于解析该执行环境内的代码创建的标识符引用。 this指针 指定该执行上下文内的 ECMAScript代码中this关键字所关联的值。 为了方便理解，一个执行上下文可以抽象为object。每一个执行上下文都有一系列的属性（我们称为上下文状态，即上面表格做左侧组件一列的属性）。接下来就对上面表格中的三个状态属性来一一说明。 变量对象 （VO）变量对象是与执行上下文相关的数据作用域(scope of data) ,用于存储被定义在上下文中的变量声明和函数声明(注意：不包括函数表达式详见) 。定义已经很明确了，我们通过具体的栗子看下全局上下文的VO： 12345678var foo = 2; function bar() &#123;&#125; // 函数声明(function baz() &#123;&#125;); // 函数表达式 console.log( this.foo == foo, // true window.bar == bar // true); console.log(baz); // Uncaught ReferenceError: baz is not defined 该例中全局上下文中变量对象会有以下属性： global VO foo undefined –&gt; 10 bar function… built-ins（忽略） 一些内置的全局变量 这是全局上下文中的变量对象，除了全局上下文还有函数上下文，那么函数上下文是否是一样的呢？答案是稍微有点不一样：函数内活动对象（AO）用作变量对象。接下来我们看下AO。 在global全局上下文中，变量对象也是全局对象自身[global object],如浏览器中是window,此时我们可以通过全局对象的属性来指向全局变量,通过this来访问全局对象。然而在函数上下文内我们是无法直接访问这个对象的,this也不指向这个对象。 函数的活动对象（AO）当函数被调用者激活（即函数调用），活动对象 就被创建了。它包含普通参数即形参(formal parameters) 与特殊参数(arguments)对象(具有索引属性的参数映射表)。活动对象在函数上下文中作为变量对象使用。 还是举个栗子看下函数的活动对象:12345678function foo(x, y) &#123; console.log(z); //undefined var z = 3; console.log(z);//3 function bar() &#123;&#125; // 函数声明 (function baz() &#123;&#125;); // 函数表达式&#125;foo(1, 2); 上面当foo被调用时，foo函数上下文的活动对象(AO)被创建，其内容如下表格： Activation object x 1 y 2 arguments { {0:{x:1}, {1:{y:1}} } z undefined–&gt;3 bar funciton 前面我们已经知道变量对象中不包含函数表达式，这里活动对象内也不包括函数表达式。 我们已经知道了VO和AO的内容组成了，那么他们是什么时候被创建的，又是什么时候改变的呢？ VO|AO在每次创建上下文时作为上下文的组成部分被创建，并填入初始值;值的更新出现在代码执行阶段。 上面两个例子中我们知道了，全局上下文中，我们定义的变量和声明的函数都作为全局上下文的变量对象的属性来保存，代码执行时标志符的查找也是从全局上下文的变量对象中查找。在某一个函数上下文中也类似，在当前上下文中的标志符会先在当前变量对象（函数上下文中是活动对象）中查找。但是当在当前上下文的变量对象找不到的时候会发生什么呢？答案是：完整的标志符解析是通过作用域链（scope chain）机制来完成的。（不容易啊，终于比较自然的把作用域链给引出来了）。那么我们来看一下什么是作用域链。 作用域链（scope chain）作用域链是一个 对象列表(list of objects) ，用以检索上下文代码中出现的 标识符(identifiers) 。先说结果： scope chain = VO|AO + [[scope]] 依然看个栗子：12345678910var x = 1;function foo() &#123; var y = 2; function bar() &#123; console.log(x + y); &#125; return bar; &#125; foo()(); // 3 这段代码执行完，共创建了三个执行上下文：执行流进入这段全局代码会创建一个全局上下文，foo调用时创建foo上下文，bar被调用时创建bar上下文(foo()–&gt;bar调用)。这里我们暂且只看一下bar的上下文，我们已经知道一个上下文的数据域即一个上下文的变量对象,在函数上下文即是活动对象（AO），那我们就看下bar函数的活动对象。当执行流进入bar函数，且函数体内代码执行之前，javascript引擎会创建这个函数的AO： AO arguments [callee: function, Symbol(Symbol.iterator): function] 我们看到bar函数提内代码执行之前创建的这个AO并没有函数体中需要用到的变量x和y,那么当代码执行到console.log(x + y)时，x和y是从哪里读取的呢？不难看出：y存在创建的foo函数上下文的活动对象中；x存在创建的全局上下文的变量对象中。好像是函数内可以访问到函数祖父级上下文的变量对象里的东西。实际上也是这样的。而能访问到祖父上下文的变量对象，正是通过函数的一个内部属性–[[scope]]实现的。 [[scope]][[scope]]是ECMA262规定的对象的私有属性，理论上只有JS引擎可以访问。 [[scope]]是所有祖父变量对象的层级链。 [[scope]]在函数创建时被存储－－静态（不变的），直至函数销毁。 拓展阅读例子。 所以一个函数内代码执行时，函数内遇到的标志符就是这样先从当前上下文的活动对象内查找，若找不着继续查找父上下文的变量对象，直到查到全局上下文。而这也正是javascript中的变量标志符查找机制。 标志符解析机制我们直接看规范（ES3 10.1.4章节）： 每个执行上下文都有一个与之相关联的作用域链（scope chain）。作用域链是一个由对象组成的链表，求值标志符的时候会对它搜索。当创建一个上下文时，根据当前上下文的代码类型（全局代码或函数代码）一个作用域链被创建，并用初始化对象填充（函数代码被填充为函数的[[scope]]属性值-接下来讲；全局代码初始化为空吧。当VO|AO被创建后，VO|AO被推到作用域链的前端）。一个上下文中代码执行时，其作用域链只会被 with 声明（见 12.10）和 catch 语句（见 12.14）所影响。标志符解析的具体规则： 获取作用域链中的下一个对象。如果没有，转到步骤 5。 调用结果(1) 的 [[HasProperty]] 方法，把标识符（Identifier）作为属性名传递。 如果结果(2) 为true，返回一个引用类型的值，其基对象（base objecqit）是结果(1),其property name是该Identifier。符。 转到步骤 1。 返回一个引用类型的值，其base object为 null，其property name 是Identifier。求值标识符的结果总是一个引用类型的值，其成员名字组件与标识符字符串相等。 注：Reference(引用)类型的值是JS引擎使用的一种数据类型，它分为base object和property name两个部分。假设在JS代码中有obj.prop这样的表达式，那么解释成Reference类型，base object是对象obj,而property name是字符串”prop”。–winter this至此上下文里还有this没说，我的总结是：this通常指向激活当前上下文的那个对象。this值在进入上下文时确定，并且在上下文运行期间不能被改变。123456console.log(this);// global objectvar obj = &#123; a: function()&#123; console.log(this) &#125; &#125;; obj.a();//obj 可以理解为：obj.a的上下文是被obj这个对象激活的。 当然this绑定还有一些其他规则。详见另一篇博文javascript之蜜汁this。 总结一下上下文：上下文分为全局上下文和函数上下文。全局上下文没啥好总结的，我们就看在函数上下文的整个生命周期。 执行流进入一个函数时，引擎不是简单的立即执行函数体内的代码，可分为两个阶段： 第一阶段：上下文创建阶段 一个函数上下文被创建，同时作为上下文的一部分的作用域链也被创建，并被初始化为函数[[scope]]属性的值。 接着javascript引擎创建当前上下文的活动对象（AO）,并且将AO推入作用域链的最前端。 确定this的值。 第二阶段：代码逐行执行–变量赋值、函数引用等 。 上下文栈（EC）以上部分我们对单个上下文的创建和组成做了详细的说明。而一段代码的执行往往是涉及到很多个上下文。而在代码执行过程中这些上下文之间是什么关系呢？ 活动的上下文在逻辑上组成一个上下文栈。栈底是全局上下文，而栈顶是当前激活的上下文。当js引擎执行全局代码前，会首先创建一个全局上下文。全局上下文创建完毕后，全局代码开始逐行被执行。代码执行过程中当一个函数被调用时，此时引擎会创建一个函数上下文，并且将其推入到上下文栈顶。引擎总是执行当前在栈顶的上下文的代码，函数执行完毕，上下文栈将该函数上下文弹出，控制权返回给之前的上下文。ECMAScript程序中的执行流正式被这个机制控制者。 相关推荐： 大叔的深入理解JavaScript系列（10）：JavaScript核心 What is the Execution Context &amp; Stack in JavaScript? (译文) winter的JavaScript中的[[scope]]和Scope Chain 结语本文主要参考了ES3规范的第10章节Execution Contexts。行文上部分参考上面两篇博文。写的过程中，发现把这个主题涉及的内容很连贯的串起来还是不容易的。而网上的关于该主题的博文也没有（我没找到）很好的把这些内容连贯的串起来的。所以整理此文。不管怎样，至少自己梳理来了一边，更清晰了。执行上下文大概就这些东西了吧。这大概也是整个javascript这门语言最核心且没有之一的东西了。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://foreverwang.github.io/categories/javascript/"}],"tags":[{"name":"作用域链","slug":"作用域链","permalink":"https://foreverwang.github.io/tags/作用域链/"},{"name":"执行期上下文","slug":"执行期上下文","permalink":"https://foreverwang.github.io/tags/执行期上下文/"},{"name":"javascript核心","slug":"javascript核心","permalink":"https://foreverwang.github.io/tags/javascript核心/"}]},{"title":"Javascript语言之蜜汁this","slug":"Javascript语言之蜜汁this","date":"2017-03-26T17:51:38.000Z","updated":"2020-06-21T11:08:05.114Z","comments":true,"path":"2017/03/26/Javascript语言之蜜汁this/","link":"","permalink":"https://foreverwang.github.io/2017/03/26/Javascript语言之蜜汁this/","excerpt":"this关键字是Javascript中最重要的机制之一。关于介绍他的文章也比比皆是，而大多都浅尝辄止，浮于表面,不够系统。故整理此篇。 先看几个题目题目1 //默认绑定 严格模式 非严格模式 12345678function foo()&#123; console.log(this.a);&#125;var a = '2';(function()&#123; 'use strict'; foo(); &#125;)()","text":"this关键字是Javascript中最重要的机制之一。关于介绍他的文章也比比皆是，而大多都浅尝辄止，浮于表面,不够系统。故整理此篇。 先看几个题目题目1 //默认绑定 严格模式 非严格模式 12345678function foo()&#123; console.log(this.a);&#125;var a = '2';(function()&#123; 'use strict'; foo(); &#125;)() 题目2 //隐式绑定1234567891011121314function foo()&#123; console.log(this.a);&#125;var a = 1;var obj2 = &#123; a: 2, foo:foo&#125;var obj1 = &#123; a: 1, obj2: obj2&#125;obj1.obj2.foo() 题目3 1234567891011function foo()&#123; console.log(this.a);&#125;var a = 2;var o = &#123;a:3,foo:foo&#125;;var p = &#123;a:4&#125;;(p.foo = o.foo)() //知识点：赋值表达式的返回值 题目4123456789var obj1 = &#123; a: 1, foo: function()&#123; console.log(this.a); &#125;&#125;;var obj2 = &#123; a: 2 &#125;;var obj3 = &#123; a: 3&#125;;obj1.foo.bind(obj2).call(obj3) //知识点： bind实现 上面4个题目的答案都是：2 。 如果你都答对了，那可以继续往下看了,以下是正文。本文先说为什么要用this，再说怎么用this。 为什么要用this?先看以下这段简单的代码123456789101112131415function speak() &#123; var greeting = \"Hello, I'm \" + this.name; console.log( greeting );&#125;var me = &#123; name: \"小a\"&#125;;var you = &#123; name: \"小b\"&#125;;speak.call( me ); // Hello, I'm 小aspeak.call( you ); // Hello, I'm 小b 以上代码可以在不同上下文对象（me 和 you）中重复使用speak函数。 如果不使用this,就要给 speak显示传入一个上下文对象（如下） 1234567function speak(content) &#123; var greeting = \"Hello, I'm \" + content.name; console.log( greeting );&#125; speak(me); // Hello, I'm 小aspeak(you); // Hello, I'm 小b 显然，this提供了一种更优雅的方式来隐式传递一个对象的引用，因此可以使API设计得更加简洁且易于复用。随着使用的模式越来越复杂，显示传递上下文对象会让代码变得越来越混乱，使用this则不会这样。 this是什么？说起this,这要看执行上下文是什么。javascript中根据可执行的种类分全局执行上下文和函数执行上下文（ES6有了块级上下文）。（关于执行上下文见另一篇博文）在全局执行上下文中（在任何函数体外部）很简单，this指向全局对象（不管是否是严格模式下）。以下说的都是在函数上下文中的this。 this常见误区 this 不指向函数自身（就没必要附加例子了） this 任何情况下也不指向函数的词法作用域（es6 箭头函数 本身没有this，那是他外部作用域的this） 123456789function foo()&#123; var a = 2; this.bar();&#125;function bar()&#123; console.log(this.a);&#125;foo()//undefined 这段代码试图通过this联通 foo和bar的词法作用域，从而让bar可以访问foo作用域里的变量a,当然这里是不能如愿的。不能使用this来引用一个词法作用域内部的东西。 this到底是啥 this 是在运行时进行绑定的，并不是在编写时绑定，他的上下文取决于函数调用时的各种条件。 （this的值只和函数调用有关，和函数定义无关—这个说法是不对的，有两个例外：bind 和箭头函数，后面说） 当一个函数被调用的时候，进入这个函数的执行上下文。执行上下文里包含：函数的活动对象（函数传入的参数等）；作用域链 （函数调用栈等）；this就是上下文的其中一个属性，会在函数执行过程中用到。 函数作用域内this绑定规则（4个）先确定函数的调用位置，调用栈 1.默认绑定先说结论： 什么是默认绑定： 非严格模式下，this指向全局对象；严格模式下，this为undefined 何时会走默认绑定：独立函数调用 函数在不带任何修饰的进行调用（即独立函数调用）的时候，this会走默认绑定规则。非严格模式下：this指向全局对象12345function foo()&#123; console.log(this.a);&#125;var a = 2;foo();//2 严格模式下：this为undefined123456function foo()&#123; 'use strict'; console.log(this.a);&#125;var a = 2;foo()//Cannot read property 'a' of undefined 这里要注意一点， 对于默认绑定，决定this绑定对象的不是调用位置是否处于严格模式，而是函数体是否处于严格模式，这也是题目1中 看似是在严格模式下，this却绑定到了全局对象1234567891011function foo()&#123; //foo函数体处于非严格模式 console.log(this.a);&#125;var a = '2';(function()&#123; 'use strict'; //该立即执行的函数表达式内处于严格模式这里的this为undefined console.log(this);//undefined foo(); //2&#125;)() 2.隐式绑定先说结论:当函数被调用时，函数引用有上下文对象，隐式绑定规则会把函数调用中的this绑定到这个上下文对象再看题目2123456789101112131415function foo()&#123; console.log(this.a);&#125;var a = 1;var obj2 = &#123; a: 2, foo:foo&#125;var obj1 = &#123; a: 1, obj2: obj2&#125;obj1.obj2.foo() //2//对象属性引用链中只有最顶层(属性的直接调用方)会影响调用位置 隐式丢失（严格来说此处并没有绑定过，也没有丢失一说，只是看上去像是丢失了）1234567891011function foo()&#123; console.log(this.a);&#125;var obj = &#123; a: 1, foo: foo&#125; var bar = obj.foo;//函数别名var a = 2;bar(); 虽然bar是obj.foo的一个引用，实际上，他引用的是foo本身，此时的bar调用 就是一个不带任何修饰的函数调用，因此应用了默认绑定。 其实本例有两个关键点： 赋值表达式的返回值（犀牛书6版81页）： var bar = obj.foo;返回的是右值，右值指向foo的引用 不管如何引用，只看调用时 调用是bar() —&gt; foo() 此时再看题目3，就很清晰了 1234567891011function foo()&#123; console.log(this.a);&#125;var a = 2;var o = &#123;a:3,foo:foo&#125;;var p = &#123;a:4&#125;;//o.foo();//3(p.foo = o.foo)() //p.foo = o.foo的返回值是等号的右值--&gt;foo的引用，此处相当于直接调用foo()//p.foo()//4 3.显示绑定先说结论： 函数调用时通过 apply 或者 call 硬绑定this 对象(apply和call的区别这里就不赘述了) 通过ES5的 Function.prototype.bind 返回一个绑定了this了的新函数 看一个硬绑定的典型应用场景:接受不确定参数1234567891011121314function foo(sth)&#123; console.log( this.a,sth ); return this.a + sth;&#125;var obj = &#123; a: 1&#125;var bar = function()&#123; return foo.apply(obj,arguments);&#125;var b = bar(1);console.log(b);// 2 另一种方法是创建一个可复用的辅助函数（bind）12345678910111213141516171819function foo(sth)&#123; console.log( this.a,sth ); return this.a + sth;&#125;//简单的辅助绑定函数function bind(fn,obj)&#123; return function()&#123; return fn.apply(obj,arguments); &#125;&#125; var obj = &#123; a: 1&#125;var bar = bind(foo,obj);var b = bar(1);console.log(b);//2 由于硬绑定是一种很常用的模式，ES5提供了内置的Function.prototype.bind方法： bind方法(犀牛书第6版190页)将返回一个新的函数，以函数调用的方式调用新的函数将会把原始函数当做bind的第一个参数的方法来调用，传入新函数的任何实参都将传入原始函数。根据定义，用ES3很容易模拟bind方法，即上面代码中我们自定义的bind函数（这里只是把最基本的绑定this模拟了，参数柯里化等没有模拟，可以看MDN bind的polyfill写法，这里不贴了）。 此时，再看题目4应该就很清晰了：123456789var obj1 = &#123; a: 1, foo: function()&#123; console.log(this.a); &#125;&#125;;var obj2 = &#123; a: 2 &#125;;var obj3 = &#123; a: 3&#125;;obj1.foo.bind(obj2).call(obj3) 最后一行中 obj1.foo.bind(obj2) 等价于以下123function bar()&#123; obj1.foo.apply(obj2,arguments)&#125; 所以foo.bind(obj2)后返回了一个新的函数，这个函数被调用的时候的this被绑定到obj2，再call(obj3) 也是改变不了这个事实。 bind方法和this的关系就是以上了，由于bind方法实在是很重要并且很好用，所以这里把bind方法说完。 bind方法不仅是把函数绑定至一个对象，他还附带其他功能： bind()的另一个常用的场景是使一个函数拥有预设的初始参数。这些参数（如果有的话）作为bind()的第二个参数开始跟在this（或其他对象）后面，之后它们会被插入到目标函数的参数列表的开始位置，调用绑定函数时传递给绑定函数的参数会跟在它们的后面。这个附带的应用即是函数式编程中的”柯里化”(currying)的一种。 123456function foo(y,z)&#123; return this.x + y + z;&#125;var baz = fo.bind(&#123;x:1&#125;,2);baz(3); bind方法返回一个函数对象我们叫绑定函数，绑定函数的length属性值是被调函数（绑定函数的目标函数）的形参个数减去绑定实参个数（length值不能小于0）。 bind返回的函数被用作构造函数，将忽略传入bind的this,原始函数就会以构造函数的形式调用。bind时传入的实参会原封不动的传入原始函数，调用绑定函数是传入的参数紧跟其后。 4.new 绑定先看下new 一个构造函数都发生了什么： 新建一个新对象（继承自Constructor.prototype） 将构造函数的作用域赋给新对象，因此this指向这个新对象 执行构造函数内的代码（为这个对象添加属性） 隐式返回这个对象（如果构造函数内没有显示return 非null对象值） 很清晰，new 的时候 this绑定到 创建的新对象。通常是返回的那个对象实例。多说一句，起始在js中没有构造函数一说，只有构造调用一说。 绑定优先级四种绑定规则说完了，那么问题来了，如果有多重规则同时作用时，优先级是怎样的呢？先回顾一下四种规则： 默认绑定（严格模式、非严格模式） 隐式绑定（对象属性调用） 显示绑定（apply/call、bind） new 绑定 直接说结论吧 new 绑定 &gt; 显示绑定 &gt; 隐士绑定在没有前三种绑定规则的时候就应用默认绑定。 至此，貌似事件处理函数中的 this还没说。事件处理函数又分DOM2级事件处理函数（addEventListener）;和内联事件处理函数。前者指向绑定事件的DOM可以归到显示绑定吧，只是这一步引擎帮你做了。后者this指向全局对象属于默认绑定，不再赘述。 绑定例外在规则的世界里一切秩序井然，然而世事总有些例外，this绑定也不例外。 被忽略的this当把 null或者undefined作为this的绑定对象传入 call,apply,bind,这些值在调用时会被忽略，通常实际应用的是默认绑定规则。12345function foo()&#123; console.log(this.a);&#125;var a = 2;foo.call(null);//2 既然有这个机制，通常他就应该是有用的。那什么时候我们会用到null 、nudefined值呢?当你只想用来传递参数而不关心this的话，这是个不错的选择 1234567891011//使用apply(...)来展开一个数组，并当做参数传入一个函数function foo(a,b)&#123; console.log('a:'+a,'b:'+b);&#125;//当然，ES6中我们可以用 ...操作符来代替apply展开数组了foo.apply(null,[2,3]) //a:2,b:3//使用bind(...)对参数进行柯里化（预设一些参数）var bar = foo.bind(null,2);bar(3);//a:2,b:3 至此，this讲解就接近尾声了–还有关于this的最后一点：this词法。 this词法 我们知道javascript使用了词法作用域，但javascript的this机制某种程度上很像动态作用域，因为this的值通常跟函数调用有关，而跟词法作用域无关。 事情一直到ES6之前是这样的。ES6箭头函数使得this的值和词法作用域联系起来。 箭头函数里this值不使用前面的任何规则，而是定义该箭头函数时执行上下文里this的值。 箭头函数的this绑定无法被修改 (new 也不行) （实际上箭头函数内没有自己的this） 又到了举个栗子的时候了：1234567891011function foo()&#123; return (a) =&gt; &#123; //this继承自foo console.log(this.a); &#125;&#125;var obj1 = &#123;a:2&#125;;var obj2 = &#123;a:3&#125;;var bar = foo.call(obj1); bar.call(obj2);//2 感觉这个箭头函数里的this值似曾相识？是的，在ES6之前，我们就经常使用一种和箭头函数一样的模式。123456789function foo()&#123; var self = this; setTimeout(function()&#123; console.log(self.a); &#125;,100);&#125; var obj = &#123;a:2&#125;;foo.call(obj);//2 （完） 关于this的细节就讲完了。this作为执行上下文的一个属性，由于他的规则比较多所以单独拿出来说。关于执行上下文的其他内容甚至更为重要，接下来建议拓展阅读另一篇博文javascript之执行上下文。私以为搞透执行上下文，是真正理解javascript这门语言的必要条件。 参考资料 《你不知道的javascipt》 《javascript权威指南》","categories":[{"name":"javascript","slug":"javascript","permalink":"https://foreverwang.github.io/categories/javascript/"}],"tags":[{"name":"javascript核心","slug":"javascript核心","permalink":"https://foreverwang.github.io/tags/javascript核心/"},{"name":"this","slug":"this","permalink":"https://foreverwang.github.io/tags/this/"}]},{"title":"hexo + github pages搭建个人博客","slug":"hello-hexo","date":"2017-02-23T04:20:48.000Z","updated":"2020-06-21T11:08:05.114Z","comments":true,"path":"2017/02/23/hello-hexo/","link":"","permalink":"https://foreverwang.github.io/2017/02/23/hello-hexo/","excerpt":"Hexo官网 hexo报错解决","text":"Hexo官网 hexo报错解决 hexo init 报错 1npm uninstall dtrace-provider hero server 报错 1npm install hexo --no-optional 通常这个命令能解决，（我这解决不了 就找到报错的地方，看了下这个报错没啥影响就注释掉了，不然强迫症） github pages在github 新建仓库仓库命名： username.github.io, 此时就可以访问 username.github.io了 github pages 和 hexo 关联 hexo -g 会生成一个静态网站（第一次会生成一个public目录），这个静态文件可以直接访问。 需要将hexo生成的静态网站，提交(git commit)到github上。 通过hexo 命令将静态站点push到github 安装插件hexo-deployer-git 1npm install hexo-deployer-git --save 修改 hexo的 _config.yml 1234deploy: type: git repo: https://github.com/username/username.github.io.git branch: master 更换hexo主题 克隆主题到themes路径下 1git clone https://github.com/theme-next/hexo-theme-next.git themes/next 注意：主题文件夹放到themes下 文件夹命名和配置文件里保持一致 修改站点配置文件 _config.yml 1theme: next hexo添加分类页面 新建分类页 1hexo new page categories 在 source/categories 目录的 index.md 中修改: title: 分类 date: 2015-12-02 12:44:45 type: &apos;categories&apos; hexo 常用命令 新建一篇博客 1hexo new filename 起本地服务 1hexo s 生成静态站点 1hexo g 发布 1hexo d 清除本地缓存 123456789101112 hexo clean ``` #### 使用技巧* git deploy 面用户名和密码提交github 在github 添加ssh key 公钥后 通过ssh 的方式提交代码 ```bash deploy: type: git repo: git@github.com:xxx branch: master","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://foreverwang.github.io/categories/Hexo/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://foreverwang.github.io/tags/博客/"},{"name":"hexo","slug":"hexo","permalink":"https://foreverwang.github.io/tags/hexo/"}]}],"categories":[{"name":"javascript","slug":"javascript","permalink":"https://foreverwang.github.io/categories/javascript/"},{"name":"vue","slug":"javascript/vue","permalink":"https://foreverwang.github.io/categories/javascript/vue/"},{"name":"读书","slug":"读书","permalink":"https://foreverwang.github.io/categories/读书/"},{"name":"布局","slug":"布局","permalink":"https://foreverwang.github.io/categories/布局/"},{"name":"前端状态管理","slug":"前端状态管理","permalink":"https://foreverwang.github.io/categories/前端状态管理/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://foreverwang.github.io/categories/读书笔记/"},{"name":"架构模式","slug":"架构模式","permalink":"https://foreverwang.github.io/categories/架构模式/"},{"name":"设计模式","slug":"架构模式/设计模式","permalink":"https://foreverwang.github.io/categories/架构模式/设计模式/"},{"name":"设计模式","slug":"设计模式","permalink":"https://foreverwang.github.io/categories/设计模式/"},{"name":"随笔","slug":"随笔","permalink":"https://foreverwang.github.io/categories/随笔/"},{"name":"React","slug":"javascript/React","permalink":"https://foreverwang.github.io/categories/javascript/React/"},{"name":"Hexo","slug":"Hexo","permalink":"https://foreverwang.github.io/categories/Hexo/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://foreverwang.github.io/tags/javascript/"},{"name":"事件循环","slug":"事件循环","permalink":"https://foreverwang.github.io/tags/事件循环/"},{"name":"异步","slug":"异步","permalink":"https://foreverwang.github.io/tags/异步/"},{"name":"vue","slug":"vue","permalink":"https://foreverwang.github.io/tags/vue/"},{"name":"数据绑定原理","slug":"数据绑定原理","permalink":"https://foreverwang.github.io/tags/数据绑定原理/"},{"name":"心智成熟之路","slug":"心智成熟之路","permalink":"https://foreverwang.github.io/tags/心智成熟之路/"},{"name":"自律","slug":"自律","permalink":"https://foreverwang.github.io/tags/自律/"},{"name":"flex","slug":"flex","permalink":"https://foreverwang.github.io/tags/flex/"},{"name":"javascript核心","slug":"javascript核心","permalink":"https://foreverwang.github.io/tags/javascript核心/"},{"name":"es6","slug":"es6","permalink":"https://foreverwang.github.io/tags/es6/"},{"name":"继承","slug":"继承","permalink":"https://foreverwang.github.io/tags/继承/"},{"name":"RSA","slug":"RSA","permalink":"https://foreverwang.github.io/tags/RSA/"},{"name":"非对称加密","slug":"非对称加密","permalink":"https://foreverwang.github.io/tags/非对称加密/"},{"name":"数字签名","slug":"数字签名","permalink":"https://foreverwang.github.io/tags/数字签名/"},{"name":"数据流","slug":"数据流","permalink":"https://foreverwang.github.io/tags/数据流/"},{"name":"redux","slug":"redux","permalink":"https://foreverwang.github.io/tags/redux/"},{"name":"深度工作","slug":"深度工作","permalink":"https://foreverwang.github.io/tags/深度工作/"},{"name":"MVC","slug":"MVC","permalink":"https://foreverwang.github.io/tags/MVC/"},{"name":"MVP","slug":"MVP","permalink":"https://foreverwang.github.io/tags/MVP/"},{"name":"flux","slug":"flux","permalink":"https://foreverwang.github.io/tags/flux/"},{"name":"设计模式","slug":"设计模式","permalink":"https://foreverwang.github.io/tags/设计模式/"},{"name":"工厂模式","slug":"工厂模式","permalink":"https://foreverwang.github.io/tags/工厂模式/"},{"name":"创建型模式","slug":"创建型模式","permalink":"https://foreverwang.github.io/tags/创建型模式/"},{"name":"随笔","slug":"随笔","permalink":"https://foreverwang.github.io/tags/随笔/"},{"name":"游戏","slug":"游戏","permalink":"https://foreverwang.github.io/tags/游戏/"},{"name":"JSX","slug":"JSX","permalink":"https://foreverwang.github.io/tags/JSX/"},{"name":"React","slug":"React","permalink":"https://foreverwang.github.io/tags/React/"},{"name":"函数节流（throttle）","slug":"函数节流（throttle）","permalink":"https://foreverwang.github.io/tags/函数节流（throttle）/"},{"name":"函数防抖（debounce）","slug":"函数防抖（debounce）","permalink":"https://foreverwang.github.io/tags/函数防抖（debounce）/"},{"name":"作用域链","slug":"作用域链","permalink":"https://foreverwang.github.io/tags/作用域链/"},{"name":"执行期上下文","slug":"执行期上下文","permalink":"https://foreverwang.github.io/tags/执行期上下文/"},{"name":"this","slug":"this","permalink":"https://foreverwang.github.io/tags/this/"},{"name":"博客","slug":"博客","permalink":"https://foreverwang.github.io/tags/博客/"},{"name":"hexo","slug":"hexo","permalink":"https://foreverwang.github.io/tags/hexo/"}]}